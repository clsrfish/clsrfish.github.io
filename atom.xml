<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱吃胡萝卜</title>
  
  
  <link href="https://clsrfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://clsrfish.github.io/"/>
  <updated>2023-08-05T13:22:13.000Z</updated>
  <id>https://clsrfish.github.io/</id>
  
  <author>
    <name>Clsrfish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LSM-Tree</title>
    <link href="https://clsrfish.github.io/2023/07/29/a22615e5cdae.html"/>
    <id>https://clsrfish.github.io/2023/07/29/a22615e5cdae.html</id>
    <published>2023-07-29T13:16:22.000Z</published>
    <updated>2023-08-05T13:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2023/lsm-tree.png" alt="LSM tree"></p><blockquote><p>The Log-Structured Merge-tree (LSM-tree) is a disk-based data structure designed to provide low-cost indexing for a file experiencing a high rate of record inserts (and deletes) over an extended period.</p></blockquote><p>LSM tree 基于“磁盘批量顺序写性能高于随机写”这一理论基础，提供高性能写入能力，代价是牺牲一部分读性能和空间效率。为了弥补读取性能，需要进一步设计，这也是其名字——Log-Structured Merge Tree 的由来。</p><h2 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h2><p>LSM Tree 由存在于内存与磁盘上的部分组成，<code>Memtable</code> 和 <code>SSTable</code>，内存中又可以进一步划分成两个，如上图所示，顶部区域实际包含 <code>Mutable memtable</code> 和 <code>Immutable memtable</code>。</p><p><strong>Mutable memtable</strong>：</p><p>所有操作直接写入 <code>Mutable memtable</code>，数据会按照 key 有序存储。一般基于 <code>Balanced binary tree</code> 实现。</p><p><strong>Immutable memtable</strong>：</p><p>当 <code>Mutable memtable</code> 达到特定大小时，就会转换成 <code>Immutable memtable</code>，然后 flush 到磁盘上。<code>Immutable memtable</code> 只是数据写入磁盘（SSTable）前的临时状态，新数据会写入一个新的 <code>Mutable memtable</code>，避免了新数据写入被转储过程影响。</p><p>**SSTable(Sorted String Table)**：</p><p>有序键值对集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-----------+-----------+-----------+</span><br><span class="line">| key:value | key:value | key:value | key:value |</span><br><span class="line">+-----------+-----------+-----------+-----------+</span><br></pre></td></tr></table></figure><p>根据现实场景，文件内部结构可能不一样，key&#x2F;value 分开存储，建立索引等。</p><blockquote><p>对于 Delete 操作，LSM Tree 通过特殊的 <em>tombstone</em> 标记完成，这一点是比较反直觉的，因为删除操作并没有释放空间。</p></blockquote><p>可以预想，SSTable 数量会不断增长，由此带来两个问题：</p><ol><li>查询操作需要按时间由近至远查询每个 SSTable 直到找到对应 key。</li><li>空间冗余，同一 key 可能存在于多个 SSTable 中，但除了最新的那条，其余都是冗余数据。</li></ol><p>为了缓解这两个问题，就需要适当对 SSTable 做 Compaction。</p><h2 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h2><p>Compaction 的一般规则是将上一层 SSTable 合并进入下一层 SSTable，也就是说磁盘上会有多层 SSTable，越下层 SSTable 存储数据也越旧。</p><p>不同 Compaction 策略在以下三个指标间进行权衡与取舍：</p><ol><li>Read amplification。比如需要从上往下在每层 SSTable 中搜索某个 key。</li><li>Write amplification。比如写入时触发 Compaction 带来额外磁盘 IO。</li><li>Space amplification。比如某个key存在多条冗余记录，compaction 完成前新的 SSTable 和原始 SSTable 同时存在，最坏情况下 compaction 期间数据膨胀为原来的两倍。</li></ol><h3 id="size-tiered-Compaction"><a href="#size-tiered-Compaction" class="headerlink" title="size-tiered Compaction"></a>size-tiered Compaction</h3><p>size-tiered Compaction 策略比较简单，即限制一层中 SSTable 的数量，当数量达到阈值时，将该层 SSTable 合并成为一个更大的 SSTable 存入下一层。</p><p>在这种策略下，某个 key 还是有可能出现在多个 SSTable 中，也即空间放大。</p><h3 id="leveled-Compaction"><a href="#leveled-Compaction" class="headerlink" title="leveled Compaction"></a>leveled Compaction</h3><p>leveled compaction 是 sized-tiered compaction 的改进，大致思路是：对于 L1（第一层 SSTable 为 L0）SSTable 及以上 level，将 size-tiered compaction 中的大 SSTable 拆分成较小且 key range 互不相交的小 SSTable，这种情况下一个 key 不会有多个记录。当发生 L<sub>N</sub> compaction 时，从中挑选若干 SSTable（其 key range 不与其余 SSTable 相交），与 L<sub>N+1</sub> 层 key range 相交的若干 SSTable（必定连续）合并并拆分成新的小 SSTable，如果下层没有匹配 key range 的 SSTable，则 L<sub>N</sub> 层的 SSTable 直接进入 L<sub>N+1</sub> 层。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://www.cs.umb.edu/~poneil/lsmtree.pdf">The Log-Structured Merge-Tree</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=I6jB0nM9SKU">The Secret Sauce Behind NoSQL: LSM Tree</a></p><p><a target="_blank" rel="noopener" href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/">Log Structured Merge Trees</a></p><p><a target="_blank" rel="noopener" href="https://muzinuo.com/archives/lsm-tree-compact">LSM-Tree 的Compact策略</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/437151725">LSM-Tree的存储引擎的Compact机制</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/2023/lsm-tree.png&quot; alt=&quot;LSM tree&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Log-Structured Merge-tree (LSM-tree) is a disk-based data struc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Rate-limiting algorithms</title>
    <link href="https://clsrfish.github.io/2023/07/17/49937ddf50aa.html"/>
    <id>https://clsrfish.github.io/2023/07/17/49937ddf50aa.html</id>
    <published>2023-07-17T14:17:28.000Z</published>
    <updated>2023-07-18T13:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fixed-window"><a href="#Fixed-window" class="headerlink" title="Fixed window"></a>Fixed window</h2><p>固定窗口算法又叫计数法，在固定时间窗口里记录请求次数，当计数达到阈值时，拒绝请求。当前时间窗口结束后，重置计数器。</p><p>这种算法到优点是简单易实现。缺点是可能存流量尖刺，即请求集中在两个时间窗口交界处。</p><h2 id="Sliding-window"><a href="#Sliding-window" class="headerlink" title="Sliding window"></a>Sliding window</h2><p>滑动窗口算法是固定窗口算法的改进版，在固定窗口的基础上又划分若干子窗口，每个字窗口单独计数，每次只往前移动一个子窗口。相比固定窗口，随着子窗口数量增加，其限流计算更加准确。</p><p>不过这种方式也只是缓解了固定窗口算法的缺点，并不能彻底解决。</p><h2 id="Sliding-log"><a href="#Sliding-log" class="headerlink" title="Sliding log"></a>Sliding log</h2><p>滑动日志算法会记录每个请求的时间戳，然后计算最近一个时间窗口内的请求数量，如果达到上限，则请求拒绝。</p><p>这种算法的优点是限流精确，缺点也很明显，因为要在内存中记录每一条请求的时间戳，会占用较多内存。</p><h2 id="Leaky-bucket"><a href="#Leaky-bucket" class="headerlink" title="Leaky bucket"></a>Leaky bucket</h2><p>漏桶算法会维护一个单端队列，从请求在尾部排队，以固定速率从队列头部取出请求进行处理，队列长度达到上限时拒绝服务。因这种模型就像一个水桶，底部以固定流速漏水，所以称为漏桶算法。</p><p>这种算法能够对突发流量进行整形并以恒定速率进行处理，保证系统的稳定运行。缺点是，它不能很好处理流量波动的场景，当流量短时间少量增加时无法提供更快的处理速度。</p><h2 id="Token-bucket"><a href="#Token-bucket" class="headerlink" title="Token bucket"></a>Token bucket</h2><p>令牌桶和漏桶算法虽然都有桶，但是处理的角度确不太一样，漏桶桶里装的是请求，而令牌桶内装的是server的处理能力。当请求到来时，只有桶内有足够令牌时，才会消耗令牌并处理请求。桶内令牌以固定速率进行补充，直到达到上限。</p><p>通过调整令牌生成速率和桶大小，可以灵活应对流量波动。缺点是实现相对复杂。</p><h2 id="Distributed-limiter"><a href="#Distributed-limiter" class="headerlink" title="Distributed limiter"></a>Distributed limiter</h2><p>前面的算法都是在本地维护一个 limiter，不能跨 server instance 进行流量控制。当需要支持分布式流量控制时，可以使用 Redis 保存 limiter。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">Sentinel</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Fixed-window&quot;&gt;&lt;a href=&quot;#Fixed-window&quot; class=&quot;headerlink&quot; title=&quot;Fixed window&quot;&gt;&lt;/a&gt;Fixed window&lt;/h2&gt;&lt;p&gt;固定窗口算法又叫计数法，在固定时间窗口里记录请求次数，当计数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Consistent hashing</title>
    <link href="https://clsrfish.github.io/2023/07/16/44c822c98a72.html"/>
    <id>https://clsrfish.github.io/2023/07/16/44c822c98a72.html</id>
    <published>2023-07-16T06:24:30.000Z</published>
    <updated>2023-07-16T06:24:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般大型系统中，数据通常分布在多台机器上，并且为了稳定的性能表现，数据还需要均匀分布。</p><h2 id="初步的做法"><a href="#初步的做法" class="headerlink" title="初步的做法"></a>初步的做法</h2><p><img src="/img/2023/consistent-hash-simple.png" alt="simple"></p><p>首先计算 <code>hash(object_key)</code>，然后对 <code>numbers_of_servers</code> 取模得到目标 server。</p><p>这种方式的问题核心是，<code>numbers_of_servers</code> 在 server 下线或新 server 加入时会发生变化，从而 <code>object_key</code> 的计算结果也因此发生变化。</p><h2 id="hash-环"><a href="#hash-环" class="headerlink" title="hash 环"></a>hash 环</h2><p><img src="/img/2023/consistent-hash-ring.png" alt="ring"></p><p>既然 <code>numbers_of_servers</code> 是一个不稳定因素，那么就需要将其替换成稳定的因素。</p><p>这里的做法是，对 <code>server_name</code> 或 <code>server_ip</code> 应用相同的 hash 函数，这时得到了 <code>v_object</code> 和 <code>v_server</code>。将 hash 函数的取值区间首位相连得到一个环， 然后根据 <code>v_object</code> 和 <code>v_server</code> 环上的位置，为 <code>object</code> 选择对应的 <code>server</code>。这里的规则一般是，按照顺时针方向搜索第一个 <code>server</code>。</p><p>理想情况下，现有节点下线或新节点加入都将不会导致所有 <code>object_key</code> 的重新分配。</p><p>但是现实中，数据可能不是完全均匀分布，也就是不同节点的上下线带来的影响也是不稳定的，无法预测的。比方说，两台机器，80%的数据分布在机器A，20%的数据分布在机器B，机器B下线将导致机器A负载变成原来5倍。</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p><img src="/img/2023/consistent-hash-virtual-nodes.png" alt="virtual nodes"></p><p>为了缓解数据在 server 上不均匀分布带来的影响，引入虚拟节点，使一个 server 在环上出现多次，即将 <code>hash(server_name)</code> 替换成 <code>hash(server_name#N)</code>，<code>server_name#N</code> 表示虚拟节点。</p><p>这样，某台机器下线带来的影响将由其它节点共同承担，保证了稳定的性能。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consistent_hashing">Consistent hashing wikipedia</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=UF9Iqmg94tk">Consistent Hashing</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般大型系统中，数据通常分布在多台机器上，并且为了稳定的性能表现，数据还需要均匀分布。&lt;/p&gt;
&lt;h2 id=&quot;初步的做法&quot;&gt;&lt;a href=&quot;#初步的做法&quot; class=&quot;headerlink&quot; title=&quot;初步的做法&quot;&gt;&lt;/a&gt;初步的做法&lt;/h2&gt;&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bloom filter</title>
    <link href="https://clsrfish.github.io/2023/07/15/f74286649fc7.html"/>
    <id>https://clsrfish.github.io/2023/07/15/f74286649fc7.html</id>
    <published>2023-07-15T14:19:02.000Z</published>
    <updated>2023-07-16T06:16:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Bloom filter 是用来回答“某元素是否在集合中”这个问题的，答案可能是“Firm no”或“Probably yes”，但是 Bloom filter 相比 hash table 占用内存更少，空间效率更高。也就是说，Bloom filter 通过牺牲准确性交换空间。Bloom filter 主要用在需要减少访问速度更慢的更低一级存储（或数据源）次数的场景，比如优化内存穿透。</p><h2 id="Bloom-filter-如何工作"><a href="#Bloom-filter-如何工作" class="headerlink" title="Bloom filter 如何工作"></a>Bloom filter 如何工作</h2><p>Bloom filter 由 m 个比特的字节数组和 k 个 hash 函数组成。当一个元素被添加到 filter 中时，会先调用 k 个 hash 函数计算得到 k 个整数，将字节数组中对应 bit 置为 1。当查询时，如果对应 bit 全部为 1，则元素可能在集合中（hash 冲突）；如果任一位置 bit 为 0，则元素一定不在集合中。</p><p><img src="/img/2023/bloomfilter_bukets.png" alt="bukets"></p><p>使用多少个 hash 函数取决于期望的错误率是多少，m 大小则与 k 和集合规模成正比。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter wikipedia</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=V3pzxngeLqw">Bloom Filter</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Bloom filter 是用来回答“某元素是否在集合中”这个问题的，答案可能是“Firm no”或“Probably yes”，但是 Bloom filter 相比 hash table 占用内存更少，空间效率更高。也就是说，Bloom filter 通过牺牲准确性交换空</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cache problems</title>
    <link href="https://clsrfish.github.io/2023/07/12/524fd56f9760.html"/>
    <id>https://clsrfish.github.io/2023/07/12/524fd56f9760.html</id>
    <published>2023-07-12T13:37:02.000Z</published>
    <updated>2023-07-12T13:37:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存穿透（cache-penetration）"><a href="#缓存穿透（cache-penetration）" class="headerlink" title="缓存穿透（cache penetration）"></a>缓存穿透（cache penetration）</h2><p>缓存穿透指既不存在缓存也不存在于数据库的数据被访问，所有的查询请求都直接打到数据库。这种数据可能被恶意请求，对数据库造成压力。</p><p>Solution：</p><ol><li>对请求进行初步检查，过滤掉显然非法的访问。</li><li>在缓存写入 empty 数据，并设置一个较短的过期时间。</li><li>使用 Bloom filter。</li></ol><h2 id="缓存击穿（cache-breakdown）"><a href="#缓存击穿（cache-breakdown）" class="headerlink" title="缓存击穿（cache breakdown）"></a>缓存击穿（cache breakdown）</h2><p>缓存击穿指某条热点数据不在缓存中，同时有大量的请求访问该数据，所有的请求将打到数据库。</p><p>Solution：</p><ol><li>热点数据永不过期，同时使用后台任务主动更新缓存，而不是被动写入缓存。</li><li>使用互斥锁，当缓存不存在时，只允许一个请求查询数据，其它未获取到锁的请求将挂起直到缓存ready。为避免过多挂起请求，挂起的请求到一定数量后将直接返回失败响应。</li></ol><h2 id="缓存雪崩（cache-avalanche）"><a href="#缓存雪崩（cache-avalanche）" class="headerlink" title="缓存雪崩（cache avalanche）"></a>缓存雪崩（cache avalanche）</h2><p>缓存雪崩指短时间内大批量缓存失效或者缓存服务不可用，请求压力直接来到数据库。通常同样的过期时间可能引起类似的问题。</p><p>Solution：</p><ol><li>为缓存过期时间加上一个随机的偏移量。</li><li>如果是热点数据，在服务启动时就主动将数据加载进缓存，同时不设置过期时间。</li><li>设置 backup 缓存服务提高缓存可用性。</li><li>对数据库访问限流，避免大量请求将数据库击溃。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缓存穿透（cache-penetration）&quot;&gt;&lt;a href=&quot;#缓存穿透（cache-penetration）&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透（cache penetration）&quot;&gt;&lt;/a&gt;缓存穿透（cache penetr</summary>
      
    
    
    
    
    <category term="Cache" scheme="https://clsrfish.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Distributed Locks with Redis</title>
    <link href="https://clsrfish.github.io/2023/06/12/cbeb3acfef26.html"/>
    <id>https://clsrfish.github.io/2023/06/12/cbeb3acfef26.html</id>
    <published>2023-06-11T17:21:42.000Z</published>
    <updated>2023-07-12T00:46:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式锁原则"><a href="#分布式锁原则" class="headerlink" title="分布式锁原则"></a>分布式锁原则</h2><ul><li>安全性：任意时刻，只有一个客户端能持有锁，保证临界资源的安全访问。</li><li>可用性：无死锁，锁总是能够在某一时刻被释放，即使持有锁的客户端未释放锁便意外结束。</li><li>容错性：只要集群中大多数节点存活，客户端就能正常加锁释放锁。</li></ul><h2 id="Redis-based-分布式锁"><a href="#Redis-based-分布式锁" class="headerlink" title="Redis-based 分布式锁"></a>Redis-based 分布式锁</h2><blockquote><p>到 Redlock 之前都基于单实例 redis 实现。</p></blockquote><h3 id="SETNX-EXPIRE"><a href="#SETNX-EXPIRE" class="headerlink" title="SETNX + EXPIRE"></a>SETNX + EXPIRE</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock_key = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">if</span> redis.setnx(lock_key, lock_value) == <span class="number">1</span>:</span><br><span class="line">  redis.expire(lock_key, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># process</span></span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    redis.<span class="keyword">del</span>(lock_key)</span><br></pre></td></tr></table></figure><p><code>setnx</code> 和 <code>expire</code> 不是原子操作，如果 <code>setnx</code> 后正要 <code>expire</code> 时客户端进程 crash 或者 Redis 重启，锁将无法得到释放。</p><h3 id="SETNX-value-x3D-datetime"><a href="#SETNX-value-x3D-datetime" class="headerlink" title="SETNX + value&#x3D;datetime"></a>SETNX + value&#x3D;datetime</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lock_key = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">expiration = datetime.now() + <span class="number">1000</span></span><br><span class="line"><span class="keyword">if</span> redis.setnx(lock_key, expiration) == <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  current_expiration = redis.get(lock_key)</span><br><span class="line">  <span class="keyword">if</span> current_expiration &lt; datetime.now():</span><br><span class="line">    old_expiration = redis.getset(lock_key, expiration)</span><br><span class="line">    <span class="keyword">return</span> current_expiration == old_expiration</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>现在获取锁操作成为了一个原子操作，但是这种方式存在以下问题：</p><ul><li>各个客户端时钟必须保持同步</li><li>锁过期时多个客户端同时请求锁，可能出现一个客户端获取成功，但是过期时间被其它客户端覆盖</li></ul><h3 id="SET-EX-PX-NX"><a href="#SET-EX-PX-NX" class="headerlink" title="SET EX PX NX"></a>SET EX PX NX</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock_key = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">if</span> redis.<span class="built_in">set</span>(lock_key, lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="string">&quot;100s&quot;</span>) == <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do somthing</span></span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    redis.<span class="keyword">del</span>(lock_key)</span><br></pre></td></tr></table></figure><p>这种方式问题在于，锁可能被其它客户端释放。</p><h3 id="SET-EX-PX-NX-unique-value"><a href="#SET-EX-PX-NX-unique-value" class="headerlink" title="SET EX PX NX + unique value"></a>SET EX PX NX + unique value</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock_key = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">if</span> redis.<span class="built_in">set</span>(lock_key, random_lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="string">&quot;100s&quot;</span>) == <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do somthing</span></span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> redis.get(lock_key) == random_lock_value:</span><br><span class="line">      redis.<span class="keyword">del</span>(lock_key)</span><br></pre></td></tr></table></figure><p>锁的释放不是原子操作，在并发环境下还是可能被其它客户端释放锁。</p><h3 id="Lua-script"><a href="#Lua-script" class="headerlink" title="Lua script"></a>Lua script</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>通过 Lua 脚本组合多个操作，实现原子化操作。</p><h3 id="Extending-lock"><a href="#Extending-lock" class="headerlink" title="Extending lock"></a>Extending lock</h3><p>当获取锁成功后，为锁持有线程开启一个守护线程，定时检测锁并延长锁的 TTL。</p><p>到这里基本上解决了安全性和可用性。</p><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p>以上实现方式在单实例情况下够用了，如果想实现更高的容错性，就需要引入多实例的分布式实现。</p><p>N 个独立的实例（无 replica）。</p><p>客户端按照如下步骤获取锁：</p><ol><li>获取当前时间戳（initia timestamp）。</li><li>使用相同的 key 和 random value 顺序地向 N 个 Redis 实例获取锁，获取锁的超时时间比锁的生存时间小很多，比如超时时间是 5~50ms，锁生存时间是 10s。</li><li>只有当成功获取到 <em>N&#x2F;2 + 1</em> 个锁，并且总 elapsed time 小于锁的生存时间才认为成功获取到了锁。</li><li>成功获取到锁后，锁的有效时间 &#x3D; initial validity time - elapsed time。</li><li>如果客户端未能成功获取到锁，它需要释放已经获取到的部分锁。</li></ol><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://redis.io/docs/manual/patterns/distributed-locks/">Distributed Locks with Redis</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分布式锁原则&quot;&gt;&lt;a href=&quot;#分布式锁原则&quot; class=&quot;headerlink&quot; title=&quot;分布式锁原则&quot;&gt;&lt;/a&gt;分布式锁原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安全性：任意时刻，只有一个客户端能持有锁，保证临界资源的安全访问。&lt;/li&gt;
&lt;li&gt;可用性：无</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Reactor pattern</title>
    <link href="https://clsrfish.github.io/2023/06/05/ff306b2184fc.html"/>
    <id>https://clsrfish.github.io/2023/06/05/ff306b2184fc.html</id>
    <published>2023-06-05T07:54:03.000Z</published>
    <updated>2023-06-11T09:14:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2023/multithreadloggingserver.png" alt="Multi-threaded Logging Server"></p><p>早期服务端程序处理用户请求时，会为每一个新连接创建线程处理请求，随着并发量越来越高，“thread-per-connection” 这种模式的弊端开始显现。一来线程创建本身有开销，二来上下文切换也会带来额外开销。引入线程池可以一定程度上缓解，但更深层次的问题开始浮现，连接建立（<code>accept</code>）后通常不能马上读取到client的请求数据（<code>recv</code>），也就是说线程池内线程处于挂起状态。</p><p>一个直观的想法就是，连接建立后<strong>直到有数据可读时</strong>才开启线程进行处理，避免线程挂起。</p><h2 id="单线程-Reactor"><a href="#单线程-Reactor" class="headerlink" title="单线程 Reactor"></a>单线程 Reactor</h2><p><img src="/img/2023/reactor_uml.png" alt="Reactor UML"></p><ul><li><code>Synchronous Event Demultiplexer</code>: 指代各种多路复用机制。</li><li><code>Handle</code>: 文件描述符或句柄。</li><li><code>Event Handler</code>: 处理 <code>Handle</code> 的上的各种事件，比如 <code>READ</code>, <code>WRITE</code>。</li><li><code>Initiation Dispatcher</code>: 核心类，维护一个基于 <code>Synchronous Event Demultiplexer</code> 的事件循环监听 <code>Handle</code> 各种事件并分发给 <code>Event Handler</code> 进行处理。</li></ul><p><img src="/img/2023/reactor_connect.png" alt="client connect"></p><p><code>Logging Acceptor</code> 是 <code>Event Handler</code> 一个实现类，专门处理 socket 上的 READ 事件，即客户端连接建立，大致流程：</p><ol><li>将 <code>Logging Acceptor</code> 注册至 <code>Initiation Dispatcher</code>。</li><li><code>Initiation Dispatcher</code> 启动事件循环。</li><li><code>Initiation Dispatcher</code> 通过 <code>select</code> 等待客户端发起 <code>connect</code>。</li><li>客户端发起 <code>connect</code>。</li><li><code>Initiation Dispatcher</code> 从 <code>select</code> 返回并将连接建立事件交由 <code>Logging Acceptor</code> 处理。</li><li><code>Logging Acceptor</code> 调用 <code>accept</code> 获取连接。</li><li><code>Logging Acceptor</code> 为了连接创建一个 <code>Logging Handler</code> </li><li><code>Logging Acceptor</code> 将新创建的 <code>Logging Handler</code> 注册到 <code>Initiation Dispatcher</code> 的事件循环中，开始新一轮的事件等待直到客户端发送数据（<code>send</code>）。</li></ol><p><img src="/img/2023/reactor_send.png" alt="client send"></p><p>当客户端开始发送数据，大致流程：</p><ol><li>客户端发送数据。</li><li><code>Initiation Dispatcher</code> 从 <code>select</code> 返回并将发生 READ 事件的连接交给对应 <code>Logging Handler</code> 处理。</li><li><code>Logging Handler</code> 调用 <code>recv</code> 读取客户端数据。</li><li><code>Logging Handler</code> 处理数据（注意这里的 <code>write</code> 在论文里是用作把客户端数据写入存储用的）。</li><li>回到 <code>Initiation Dispatcher</code> 处理下一个事件或进入下一轮事件循环。</li></ol><p>上面这两个过程基本就是 Reactor pattern 的核心流程了，回消息给客户端的流程类似，<code>Logging Handler</code> 处理完后再注册一个 WRITE 事件的监听，然后再写入数据。整个流程都在一个线程内工作，没有上下文切换。</p><p>Reactor pattern 除了使用多路复用外，还用到了非阻塞IO。设想 <code>Logging Handler</code> 一次事件响应中没能读到一个完整请求的数据，那么就需要立即返回等待下一次事件，而不是阻塞在 <code>recv</code> 上。</p><p>下面是示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EventType</span> &#123;</span><br><span class="line">    CONNECT,</span><br><span class="line">    READ,</span><br><span class="line">    WRITE,</span><br><span class="line">    CLOSE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventHandler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventHandler</span>(<span class="type">const</span> <span class="type">int</span> fd) : <span class="built_in">fd</span>(fd) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventHandler</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(EventType event)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InitiationDispatcher</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_EVENTS = <span class="number">16</span>;</span><br><span class="line">    <span class="function">EventHandler *<span class="title">get_handler</span><span class="params">(epoll_event *ev)</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InitiationDispatcher</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">InitiationDispatcher</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_handler</span><span class="params">(<span class="type">const</span> EventHandler* handler, EventType et)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_handler</span><span class="params">(<span class="type">const</span> EventHandler* handler)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_events</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">        epoll_event events[MAX_EVENTS];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// update epfd instance</span></span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, <span class="comment">/*fd*/</span>, <span class="comment">/*ev*/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> nevents = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nevents; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> ev = events[i];</span><br><span class="line">                <span class="keyword">if</span> (<span class="comment">/*is CONNECT*/</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> logging_acceptor = <span class="built_in">get_handler</span>(&amp;ev);</span><br><span class="line">                    logging_acceptor-&gt;<span class="built_in">accept</span>(EventType::CONNECT);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/*is READ*/</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> logging_handler = <span class="built_in">get_handler</span>(&amp;ev);</span><br><span class="line">                    logging_handler-&gt;<span class="built_in">accept</span>(EventType::READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/*is WRITE*/</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> logging_handler = <span class="built_in">get_handler</span>(&amp;ev);</span><br><span class="line">                    logging_handler-&gt;<span class="built_in">accept</span>(EventType::WRITE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* else */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingHandler</span> : <span class="keyword">public</span> EventHandler &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    InitiationDispatcher* dispatcher;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LoggingHandler</span>(<span class="type">const</span> <span class="type">int</span> fd, InitiationDispatcher* dispatcher) : <span class="built_in">EventHandler</span>(fd), <span class="built_in">dispatcher</span>(dispatcher) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">LoggingHandler</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(EventType event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event == EventType::READ) &#123;</span><br><span class="line">            <span class="type">int</span> size = <span class="built_in">read</span>(<span class="keyword">this</span>-&gt;fd, <span class="comment">/*buf*/</span>, <span class="comment">/*buf_size*/</span>)</span><br><span class="line">            <span class="keyword">if</span> (size == EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* process */</span></span><br><span class="line">            <span class="type">int</span> written = <span class="built_in">write</span>(<span class="keyword">this</span>-&gt;fd,  <span class="comment">/*buf*/</span>, <span class="comment">/*data_size*/</span>);</span><br><span class="line">            <span class="keyword">if</span> (written == EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;dispatcher-&gt;<span class="built_in">register_handler</span>(<span class="keyword">this</span>, EventType::WRITE);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == EventType::WRITE) &#123;</span><br><span class="line">            <span class="comment">/*continue writing*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingAcceptor</span> : <span class="keyword">public</span> EventHandler &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    InitiationDispatcher* dispatcher;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LoggingAcceptor</span>(<span class="type">const</span> <span class="type">int</span> fd, InitiationDispatcher* dispatcher): <span class="built_in">EventHandler</span>(fd), <span class="built_in">dispatcher</span>(dispatcher) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">LoggingAcceptor</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(EventType event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> conn_fd = <span class="built_in">accept4</span>(<span class="keyword">this</span>-&gt;fd, <span class="comment">/*addr*/</span>, <span class="comment">/*addr_len*/</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> handler = <span class="keyword">new</span> <span class="built_in">LoggingHandler</span>(conn_fd, <span class="keyword">this</span>-&gt;dispatcher);</span><br><span class="line">        <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">        <span class="keyword">this</span>-&gt;dispatcher-&gt;<span class="built_in">register_handler</span>(handler, EventType::READ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> socket_fd = <span class="built_in">socket</span>(<span class="comment">/* args */</span>);</span><br><span class="line">    <span class="built_in">listen</span>(socket_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> dispatcher = <span class="keyword">new</span> <span class="built_in">InitiationDispatcher</span>();</span><br><span class="line">    <span class="keyword">auto</span> acceptor = <span class="keyword">new</span> <span class="built_in">LoggingAcceptor</span>(socket_fd, dispatcher);</span><br><span class="line">    dispatcher-&gt;<span class="built_in">register_handler</span>(acceptor, EventType::CONNECT);</span><br><span class="line">    dispatcher-&gt;<span class="built_in">handle_events</span>();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程-Reactor"><a href="#多线程-Reactor" class="headerlink" title="多线程 Reactor"></a>多线程 Reactor</h2><p>单线程 Reactor 中所有的操作在单个线程中完成，如果某个请求处理非常耗时，将导致其它请求无法处理，无法建立新连接。所以就可以将请求处理的逻辑交由线程池进行处理。</p><h2 id="多线程-Multi-Reactor"><a href="#多线程-Multi-Reactor" class="headerlink" title="多线程 Multi-Reactor"></a>多线程 Multi-Reactor</h2><p>不管单线程还是多线程 Reactor，所有的文件描述符&#x2F;句柄都在同一个事件循环里处理，也就无法同一时间处理大量新连接建立和读写事件。所以可以将两种不同的文件描述符分别在不同的事件循环里处理，交由不同线程处理，提高吞吐量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InitiationDispatcher</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;InitiationDispatcher*&gt; sub_dispathcers;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>root <code>InitiationDispatcher</code> 只负责建立新连接建立，然后已建立的连接则交给 <code>sub_dispatchers</code>（RR）处理，每个 <code>sub_dispacther</code> 都会创建线程开启事件循环。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="http://www.kegel.com/c10k.html">The C10K problem</a></p><p><a target="_blank" rel="noopener" href="https://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf">reactor</a></p><p><a target="_blank" rel="noopener" href="https://nicky-chin.cn/2020/06/11/net-nio-netty">nio netty</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/2023/multithreadloggingserver.png&quot; alt=&quot;Multi-threaded Logging Server&quot;&gt;&lt;/p&gt;
&lt;p&gt;早期服务端程序处理用户请求时，会为每一个新连接创建线程处理请求，随着并发量越来越高，“</summary>
      
    
    
    
    
    <category term="I/O" scheme="https://clsrfish.github.io/tags/I-O/"/>
    
    <category term="Reactor" scheme="https://clsrfish.github.io/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>I/O Multiplexing</title>
    <link href="https://clsrfish.github.io/2023/06/03/b735be0f5723.html"/>
    <id>https://clsrfish.github.io/2023/06/03/b735be0f5723.html</id>
    <published>2023-06-02T18:38:21.000Z</published>
    <updated>2023-06-02T18:38:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><code>select</code> 允许程序同时监听多个文件描述符，直到一个或多个文件描述符变为<strong>ready</strong>状态（可读、可写、异常），最多支持同时监听 <code>FD_SETSIZE(default 1024 on Linux)</code> 个文件描述符。当 <code>select</code> 返回时，传入的三个 <code>fd_set</code> 将被（in-place）修改，用于标识那些<strong>ready</strong>的文件描述符，也就是说，每次调用 <code>select</code> 都需要重新初始化 <code>fd_set</code> 并拷贝至 Kernel space，当监听文件描述符数量多时，拷贝开销也是相当可观的。<code>FD_SETSIZE</code> 的限制是由于文件描述符在 <code>fd_set</code> 中以数组形式保存。</p><h3 id="select-使用示例"><a href="#select-使用示例" class="headerlink" title="select 使用示例"></a>select 使用示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// initialize fd_set</span></span><br><span class="line">  fd_set rfds;</span><br><span class="line">  FD_ZERO(&amp;rfds);</span><br><span class="line">  FD_SET(<span class="number">0</span>, &amp;rfds); <span class="comment">// stdin</span></span><br><span class="line">  <span class="comment">// timeout</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">  tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> nfds = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> retval = select(nfds, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">  <span class="keyword">if</span> (retval == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">    <span class="comment">// retval fds ready</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; nfds; n++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(fds[n], &amp;rfds)) &#123;</span><br><span class="line">        <span class="comment">// perform I/O operation</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// no fd ready</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h2><p><code>poll</code> 与 <code>select</code> 类似，只是针对 <code>select</code> 文件描述符数量限制和每次都需要 reinitialize <code>fd_set</code> 进行了改进，不过每次调用 <code>poll</code> 还是需要拷贝文件描述符至内核空间。在 <code>poll</code> 实现中，文件描述符在以链表形式管理，所以没有了数量限制。</p><p><code>pollfd</code> 则解决了 <code>select</code> 每次调用都需要初始化 <code>fd_set</code> 的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">  <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">  <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="poll-使用示例"><a href="#poll-使用示例" class="headerlink" title="poll 使用示例"></a>poll 使用示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* poll_input.c</span></span><br><span class="line"><span class="comment">Licensed under GNU General Public License v2 or later.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> nfds = argc - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> num_open_fds = nfds;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">pfds</span> =</span> <span class="built_in">calloc</span>(nfds, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nfds; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    pfds[j].fd = open(argv[j + <span class="number">1</span>], O_RDONLY);</span><br><span class="line">    pfds[j].events = POLLIN; <span class="comment">// set requested events to be monitored</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (num_open_fds &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> ready = poll(pfds, nfds, <span class="number">-1</span>); <span class="comment">// block until an event occurs </span></span><br><span class="line">    <span class="keyword">if</span> (ready == <span class="number">-1</span>)</span><br><span class="line">      errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nfds; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (pfds[j].revents == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pfds[j].revents &amp; POLLIN) &#123;</span><br><span class="line">        <span class="comment">// perform I/O operation</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pfds[j].fd);</span><br><span class="line">        num_open_fds--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><p>从 <code>select</code> 到 <code>poll</code>，已经解决了数量限制、参数重新初始化的问题，但是还有两个问题没有解决，一是需要每次都要拷贝完整文件描述符到内核空间，二是需要遍历所有文件描述符执行 I&#x2F;O 操作。<br><code>epoll</code> 通过在内核空间维护一个 epoll instance 解决这两个问题，可以理解为一个包含 <code>interest</code> 和 <code>ready</code> 两个集合的数据结构，前者表示需要监听的文件描述符，后者则记录了进入 <code>ready</code> 状态的文件描述符。这样用户程序就可以通过 epoll instance 修改 <code>interest</code> 动态调整需要监听的文件描述符了。</p><h3 id="epoll-使用示例"><a href="#epoll-使用示例" class="headerlink" title="epoll 使用示例"></a>epoll 使用示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> listen_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> epollfd = epoll_create(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// monitor socket fd</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">  ev.events = EPOLLIN;</span><br><span class="line">  ev.data.fd = listen_sock;</span><br><span class="line">  epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev)</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; nfds; ++n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (events[n].data.fd == listen_sock) &#123;</span><br><span class="line">        <span class="comment">// register connection to the epoll instance</span></span><br><span class="line">        <span class="type">int</span> conn_sock = accept(listen_sock, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">        ev.events = EPOLLIN;</span><br><span class="line">        ev.data.fd = conn_sock;</span><br><span class="line">        epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &amp;ev)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// connection ready</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Edge-triggered-amp-Level-triggered"><a href="#Edge-triggered-amp-Level-triggered" class="headerlink" title="Edge-triggered &amp; Level-triggered"></a>Edge-triggered &amp; Level-triggered</h3><p>这两个其实是数字电路里面的术语，可以参考<a href="#key-takeaways">Key takeaways</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1          +----------+          +----------+          +----------+</span><br><span class="line">           |          |          |          |          |          |</span><br><span class="line">           |          |          |          |          |          |</span><br><span class="line">           |          |          |          |          |          |</span><br><span class="line">0----------+          +----------+          +----------+          +----------</span><br></pre></td></tr></table></figure><p>Edge-triggered 监听的是竖线表示的状态变化，Level-triggered 监听的是水平线表示的状态。</p><p>举例来说，当一个文件描述符从 not read ready（0） 变为 read ready（1） 时，不论 Edge-triggered 还是 Level-triggered，都会通知可读事件；如果应用程序只读了一半数据，或者压根没读取，那该文件描述符的状态还是 read ready；下一次调用 <code>epoll_wait</code> 时，Edge-triggered 因为没有状态变化不会再次通知，Level-triggered 则检测到仍是可读状态，还会继续通知。</p><p>默认以 Level-triggered 方式监听文件描述符，可使用 <code>ev.events = EPOLLIN | EPOLLET</code> 调整为 Edge-triggered 模式。由于 Edge-triggered 不会再次通知可读文件描述符，所以需要用户程序自行维护好文件描述符的可读状态（EGAIN）。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw"></a></p><p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/edge-triggering-and-level-triggering">edge-triggering and level-triggering</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Select&quot;&gt;&lt;a href=&quot;#Select&quot; class=&quot;headerlink&quot; title=&quot;Select&quot;&gt;&lt;/a&gt;Select&lt;/h2&gt;&lt;p&gt;&lt;code&gt;select&lt;/code&gt; 允许程序同时监听多个文件描述符，直到一个或多个文件描述符变为&lt;str</summary>
      
    
    
    
    
    <category term="I/O" scheme="https://clsrfish.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>Cache pattern</title>
    <link href="https://clsrfish.github.io/2023/05/29/8154982c759c.html"/>
    <id>https://clsrfish.github.io/2023/05/29/8154982c759c.html</id>
    <published>2023-05-29T05:06:25.000Z</published>
    <updated>2023-05-29T05:06:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Cache-aside"><a href="#1-Cache-aside" class="headerlink" title="1. Cache-aside"></a>1. Cache-aside</h2><p><img src="/img/2023/cache-aside.png" alt="cache-aside"></p><p>这是最常用的 pattern，实现简单也足够灵活，系统能够承受一定程度的 cache failure。</p><h3 id="1-1-Pros"><a href="#1-1-Pros" class="headerlink" title="1.1. Pros"></a>1.1. Pros</h3><ul><li>简单灵活。</li></ul><h3 id="1-2-Cons"><a href="#1-2-Cons" class="headerlink" title="1.2. Cons"></a>1.2. Cons</h3><ul><li>使用方（Application）需管理缓存与下一级存储。</li><li>写请求有可能造成缓存与下一级存储不一致，通过<strong>写数据库后删缓存</strong>可以降低不一致的可能性，根据系统要求可以再配合 TTL、异步任务甚至是分布式事务。</li></ul><h2 id="2-Read-through"><a href="#2-Read-through" class="headerlink" title="2. Read-through"></a>2. Read-through</h2><p><img src="/img/2023/read-through.png" alt="read-through"></p><p>相比较 <strong>Cache-aside</strong>，<strong>Read-through</strong> 为使用方管理了缓存与第一级存储，使用更加方便，表现上就像是一个自带缓存的存储接口。</p><h3 id="2-1-Pros"><a href="#2-1-Pros" class="headerlink" title="2.1. Pros"></a>2.1. Pros</h3><ul><li>接口简单，使用方便。</li></ul><h3 id="2-2-Cons"><a href="#2-2-Cons" class="headerlink" title="2.2. Cons"></a>2.2. Cons</h3><ul><li>灵活性相比 <strong>Cache-aside</strong> 低一些。</li></ul><h2 id="3-Write-through"><a href="#3-Write-through" class="headerlink" title="3. Write-through"></a>3. Write-through</h2><p><img src="/img/2023/write-through.png" alt="write-through"></p><p>结构与 <strong>Read-through</strong> 一样，提供简单的接口。写入缓存后同步写入下一级存储，整个写操作完成，适用写少的情况。</p><h3 id="3-1-Pros"><a href="#3-1-Pros" class="headerlink" title="3.1. Pros"></a>3.1. Pros</h3><ul><li>接口简单，使用方便。</li></ul><h3 id="3-2-Cons"><a href="#3-2-Cons" class="headerlink" title="3.2. Cons"></a>3.2. Cons</h3><ul><li>写操作延迟稍高，除了写库外，还有一次额外写缓存。</li></ul><h2 id="4-Write-behind"><a href="#4-Write-behind" class="headerlink" title="4. Write-behind"></a>4. Write-behind</h2><p><img src="/img/2023/write-back.png" alt="write-back"></p><p>与 <strong>Write-through</strong> 类似，不过写库操作变为异步。</p><h3 id="4-1-Pros"><a href="#4-1-Pros" class="headerlink" title="4.1. Pros"></a>4.1. Pros</h3><ul><li>写性能大大提高。</li></ul><h3 id="4-2-Cons"><a href="#4-2-Cons" class="headerlink" title="4.2. Cons"></a>4.2. Cons</h3><ul><li>数据由丢失可能。</li><li>实现复杂。</li></ul><h2 id="5-Key-takeaways"><a href="#5-Key-takeaways" class="headerlink" title="5. Key takeaways"></a>5. Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p><p><a target="_blank" rel="noopener" href="https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/">Caching Strategies and How to Choose the Right One</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Cache-aside&quot;&gt;&lt;a href=&quot;#1-Cache-aside&quot; class=&quot;headerlink&quot; title=&quot;1. Cache-aside&quot;&gt;&lt;/a&gt;1. Cache-aside&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/2023/cach</summary>
      
    
    
    
    
    <category term="Cache" scheme="https://clsrfish.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Redis Key eviction（缓存淘汰）</title>
    <link href="https://clsrfish.github.io/2023/05/20/f997e124837a.html"/>
    <id>https://clsrfish.github.io/2023/05/20/f997e124837a.html</id>
    <published>2023-05-20T07:15:23.000Z</published>
    <updated>2023-05-23T07:42:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="maxmemory-配置"><a href="#maxmemory-配置" class="headerlink" title="maxmemory 配置"></a>maxmemory 配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure><p>64 bit 系统下默认行为没有内存上限，32 bit 系统则默认是 3GB。虽然 64 bit 系统能够提供近乎无穷大的地址空间，但是物理内存是有限的，如果 Redis 占用内存超过物理内存上限，访问键时可能导致频繁的缺页异常，吞吐量降低。</p><p>设置上限后的另一个问题：满了怎么办？</p><table><thead><tr><th>maxmemory-policy</th><th>description</th></tr></thead><tbody><tr><td>noeviction</td><td>内存达到上限时，拒绝添加新键</td></tr><tr><td>allkeys-lru</td><td>在键空间中根据 LRU 算法淘汰键</td></tr><tr><td>allkeys-lfu</td><td>在键空间中根据 LFU 算法淘汰键</td></tr><tr><td>volatile-lru</td><td>在 <code>expires</code> 中根据 LRU 算法淘汰键</td></tr><tr><td>volatile-lfu</td><td>在 <code>expires</code> 中根据 LFU 算法淘汰键</td></tr><tr><td>allkeys-random</td><td>在键空间中随机选择键淘汰</td></tr><tr><td>volatile-random</td><td>在 <code>expires</code> 中随机选择键淘汰</td></tr><tr><td>volatile-ttl</td><td>淘汰 <code>expires</code> 中 ttl 最小的键</td></tr></tbody></table><p>经验法则（a rule of thumb）：</p><ul><li><code>*-lru</code> 或 <code>*-lfu</code> 适用于键的访问频次符合幂律分布（power-law）分布的情况。</li><li><code>*-random</code> 适用于键拥有相同的被访问概率。</li><li><code>volatile-ttl</code> 适用于客户端想根据实际情况灵活调整建议 Redis 淘汰键，即自行配置过期时间。</li></ul><h2 id="典型-LRU-x2F-LFU-实现"><a href="#典型-LRU-x2F-LFU-实现" class="headerlink" title="典型 LRU &#x2F; LFU 实现"></a>典型 LRU &#x2F; LFU 实现</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Latest                                              Oldest</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">|  A  | ---&gt; |  B  | ---&gt; |  C  | ---&gt; |  D  | ---&gt; |  E  |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line"></span><br><span class="line"># D accessed</span><br><span class="line">Latest                                              Oldest</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">|  D  | ---&gt; |  A  | ---&gt; |  B  | ---&gt; |  C  | ---&gt; |  E  |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br></pre></td></tr></table></figure><p>按照访问时间由近至远排序，处在队尾的即最长时间未被访问的数据，优先被淘汰。</p><p>时间开销：O(1)<br>空间开销：O(N)</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>LRU 在淘汰缓存时只考虑了最近 1 访问，不能很好区分热点与非热点数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">|  1  | ---&gt; |  2  | ---&gt; |  3  | ---&gt; |  4  | ---&gt; |  5  |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">   |            |            |            |            |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">|     |      |     |      |     |      |     |      |     |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">   |            |                         |            |</span><br><span class="line">+-----+      +-----+                   +-----+      +-----+</span><br><span class="line">|     |      |     |                   |     |      |     |</span><br><span class="line">+-----+      +-----+                   +-----+      +-----+</span><br><span class="line">                |                                      |</span><br><span class="line">             +-----+                                +-----+</span><br><span class="line">             |     |                                |     |</span><br><span class="line">             +-----+                                +-----+</span><br></pre></td></tr></table></figure><p>按照最近一短时间访问频次排序，频次相同的再按照访问时间由近至远排序。</p><p>时间开销：O(N)<br>空间开销：O(N)</p><blockquote><p>不同的实现方式可以带来不同的时空复杂度组合，这里只是为了说明相比比 LRU，LFU 解决的问题和实现方式都更复杂。</p></blockquote><h2 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a>Redis 实现</h2><p>不论是 LRU 还是 LFU，都需要一个额外的结构记录键的访问信息，但是 Redis 通过近似实现规避了额外的记录，同时还保证了不错的效果。</p><p>LRU 和 LFU 简化后本质都是基于某种规则排序，然后淘汰对应的数据。同时 LRU 和 LFU 也是理想化的模型，并不能完全匹配现实情况，所以有可能使用一个接近 LRU&#x2F;LFU，但是开销更小的方式做到相同的效果。事实上 Redis 变通的方式很简单————采样，默认配置 <code>maxmemory-samples 5</code> 就能达到很好的效果，具体可以参考 <a target="_blank" rel="noopener" href="https://redis.io/docs/reference/eviction/" title="Eviction">Eviction</a>。</p><h3 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                           * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                           * and most significant 16 bits access time). */</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><blockquote><p>把 <a href="./20230505-Redis-Object.md">Redis Object</a> 的坑填上。</p></blockquote><p>每次访问键前都会调用 <code>lookupKey</code>，里面会更新 <code>redisObject.lru</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">         updateLFU(val);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         val-&gt;lru = LRU_CLOCK();</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU-CLOCK-实现"><a href="#LRU-CLOCK-实现" class="headerlink" title="LRU_CLOCK 实现"></a>LRU_CLOCK 实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_CLOCK_MAX ((1&lt;&lt;LRU_BITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_CLOCK_RESOLUTION 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the LRU clock, based on the clock resolution. This is a time</span></span><br><span class="line"><span class="comment"> * in a reduced-bits format that can be used to set and check the</span></span><br><span class="line"><span class="comment"> * object-&gt;lru field of redisObject structures. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">getLRUClock</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is used to obtain the current LRU clock.</span></span><br><span class="line"><span class="comment"> * If the current resolution is lower than the frequency we refresh the</span></span><br><span class="line"><span class="comment"> * LRU clock (as it should be in production servers) we return the</span></span><br><span class="line"><span class="comment"> * precomputed value, otherwise we need to resort to a system call. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">LRU_CLOCK</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        atomicGet(server.lruclock,lruclock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了减少系统调用，<code>lruclock</code> 会使用缓存好的 <code>server.lruclock</code>，最终都是调用 <code>getLRUClock</code>。<code>lruclock</code> 的单位是秒，最大可记录 <code>2^24-1</code> 秒 ~&#x3D; 194 天。</p><h4 id="updateLFU-实现"><a href="#updateLFU-实现" class="headerlink" title="updateLFU 实现"></a>updateLFU 实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.conf</span></span><br><span class="line"><span class="comment">// # lfu-log-factor 10</span></span><br><span class="line"><span class="comment">// # lfu-decay-time 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the object decrement time is reached decrement the LFU counter but</span></span><br><span class="line"><span class="comment"> * do not update LFU fields of the object, we update the access time</span></span><br><span class="line"><span class="comment"> * and counter in an explicit way when the object is really accessed.</span></span><br><span class="line"><span class="comment"> * And we will times halve the counter according to the times of</span></span><br><span class="line"><span class="comment"> * elapsed time than server.lfu_decay_time.</span></span><br><span class="line"><span class="comment"> * Return the object frequency counter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is used in order to scan the dataset for the best object</span></span><br><span class="line"><span class="comment"> * to fit: as we check for the candidate, we incrementally decrement the</span></span><br><span class="line"><span class="comment"> * counter of the scanned objects if needed. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">LFUDecrAndReturn</span><span class="params">(robj *o)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Logarithmically increment a counter. The greater is the current counter value</span></span><br><span class="line"><span class="comment"> * the less likely is that it gets really incremented. Saturate it at 255. */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LFULogIncr</span><span class="params">(<span class="type">uint8_t</span> counter)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="type">double</span> r = (<span class="type">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="type">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the current time in minutes, just taking the least significant</span></span><br><span class="line"><span class="comment"> * 16 bits. The returned time is suitable to be stored as LDT (last decrement</span></span><br><span class="line"><span class="comment"> * time) for the LFU implementation. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">LFUGetTimeInMinutes</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update LFU when an object is accessed.</span></span><br><span class="line"><span class="comment"> * Firstly, decrement the counter if the decrement time is reached.</span></span><br><span class="line"><span class="comment"> * Then logarithmically increment the counter, and update the access time. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateLFU</span><span class="params">(robj *val)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateLFU</code> 做了三件事：</p><ol><li>根据最近一次访问时间及旧 <code>counter</code> 计算当前 <code>counter</code>。</li><li>根据当前 <code>counter</code> 计算其自增的概率，<code>((counter - 5) * lfu_log_factor + 1)</code><sup>-1</sup>，得到新 <code>counter</code>。</li><li>将当前时间（最新访问时间）和 <code>counter</code> 写入 <code>redisObject.lru</code>。</li></ol><p>LFU 的访问时间以分钟为单位，最大可记录 <code>2^16-1</code> 分钟 ~&#x3D; 45 天。每 <code>lfu_decay_time</code> 分钟 <code>counter</code> 减 1，随着访问频率增加，<code>counter</code> 自增概率下降，不同 <code>lfu_log_factor</code> 下不同 <code>counter</code> 值所需要的访问次数（连续访问间隔小于一分钟）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure><h3 id="Eviction-流程"><a href="#Eviction-流程" class="headerlink" title="Eviction 流程"></a>Eviction 流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">performEvictions</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MAXMEMORY_FLAG_LRU || MAXMEMORY_FLAG_LFU || MAXMEMORY_VOLATILE_TTL)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> =</span> EvictionPoolLRU;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                evictionPoolPopulate(i, db-&gt;dict <span class="comment">/*or db-&gt;expires */</span>, db-&gt;dict, pool);</span><br><span class="line">            &#125;</span><br><span class="line">            bestkey = <span class="comment">/*last one in pool*/</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAXMEMORY_ALLKEYS_RANDOM || MAXMEMORY_VOLATILE_RANDOM) &#123;</span><br><span class="line">            bestkey = dictGetRandomKey(dict)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">            dbAsyncDelete(db,keyobj);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dbSyncDelete(db,keyobj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>maxmemory_policy</code> 使用不同策略从目标键空间找到需要淘汰的键，再根据 <code>lazyfree_lazy_eviction</code> 决定立即释放还是异步释放缓存。重点关注 <code>evictionPoolPopulate</code>，通过扫描所有 db 填满 <code>pool</code>，为了降低对正常请求的影响，对<code>pool</code> 中键的回收也是点到即止（<code>mem_freed &lt; mem_tofree</code>）。</p><h4 id="evictionPoolPopulate"><a href="#evictionPoolPopulate" class="headerlink" title="evictionPoolPopulate"></a>evictionPoolPopulate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">evictionPoolPopulate</span><span class="params">(<span class="type">int</span> dbid, dict *sampledict, dict *keydict, <span class="keyword">struct</span> evictionPoolEntry *pool)</span> &#123;</span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            idle = ULLONG_MAX - expire_at;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// idle &lt; min(pool[N].idle)</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dictGetSomeKeys</code> 会随机挑选最多 <code>maxmemory_samples(5)</code> 个键，但是不保证重复。然后根据不同的 <code>maxmemory_policy</code> 计算出 <code>idle</code>，从小到大填入 <code>pool</code>。当 <code>pool</code> 已经填充满时，只有比 <code>pool[0].idle</code> 大的键才能进入 <code>pool</code>，这种策略进一步提高了内存淘汰的效果。</p><h4 id="释放缓存"><a href="#释放缓存" class="headerlink" title="释放缓存"></a>释放缓存</h4><p>同步释放和异步释放最终都会调用 <code>dbGenericDelete</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dbGenericDelete</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> async)</span> &#123;</span><br><span class="line">    dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        freeObjAsync(key, val, db-&gt;id);</span><br><span class="line">        <span class="comment">// dictFreeUnlinkedEntry 不会一起释放 val</span></span><br><span class="line">        dictSetVal(db-&gt;dict, de, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>freeObjAsync</code> 会直接释放小对象，效果和同步释放一样；如果是大对象则提交异步任务。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://redis.io/docs/reference/eviction/" title="Eviction">Eviction</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Based on Redis 7.0.11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;maxmemory-配置&quot;&gt;&lt;a href=&quot;#maxmemory-配置&quot; class=&quot;headerlink&quot; title=&quot;maxmemory 配</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
    <category term="Eviction" scheme="https://clsrfish.github.io/tags/Eviction/"/>
    
  </entry>
  
  <entry>
    <title>Redis Persistence</title>
    <link href="https://clsrfish.github.io/2023/05/15/f986813d0d94.html"/>
    <id>https://clsrfish.github.io/2023/05/15/f986813d0d94.html</id>
    <published>2023-05-15T15:20:25.000Z</published>
    <updated>2023-05-15T15:20:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><p>Redis 提供了四种持久化的方式：</p><ul><li>No persistence：不做持久化处理，用得较少。</li><li>RDB：对缓存做全量 point-in-time 快照，生成的 *.rdb 文件非常紧凑，加载性能高，非 human readable。</li><li>AOF：对每个 write operation 进行记录，通过 replay 重新生成当前缓存状态，记录按照 RESP 格式存储，human readable。</li><li>RDB + AOF：结合 RDB 与 AOF。</li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="命令-amp-配置"><a href="#命令-amp-配置" class="headerlink" title="命令&amp;配置"></a>命令&amp;配置</h3><p><code>SAVE</code> 在当前进程生成快照，会阻塞服务；<code>BGSAVE</code> 在子进程中生成快照，不会阻塞服务。</p><p>除手动执行 <code>SAVE</code> 和 <code>BGSAVE</code>，Redis 允许配置 <code>BGSAVE</code> 自动执行的条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save M N # At lease N changes in the last M seconds</span><br><span class="line">save ...</span><br></pre></td></tr></table></figure><p>满足多个条件中任意一条即可自动执行 <code>BGSAVE</code>。</p><h3 id="BGSAVE-执行过程"><a href="#BGSAVE-执行过程" class="headerlink" title="BGSAVE 执行过程"></a>BGSAVE 执行过程</h3><ol><li>Fork 子进程</li><li>子进程将数据写入临时 RDB 文件</li><li>子进程将临时 RDB 文件重命名替换当前 RDB 文件</li><li>子进程退出</li><li>父进程处理子进程 exitcode</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> server.child_type == CHILD_TYPE_RDB:</span><br><span class="line">  <span class="comment"># err: RDB already in progress </span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> server.has_active_transaction:</span><br><span class="line">  <span class="comment"># schedule RDB</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasActiveChildProcess:</span><br><span class="line">  <span class="keyword">if</span> [SCHEDULE] :</span><br><span class="line">    <span class="comment"># schedule RDB</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># err: refuse, maybe AOF</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fork() == <span class="number">0</span>:</span><br><span class="line">  rdbSave()</span><br></pre></td></tr></table></figure><h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ul><li>RDB 文件紧凑</li><li>RDB 文件可以传输到其它机器上恢复</li><li>高性能，子进程 fork 出来后父进程照常处理请求，不会 disk I&#x2F;O</li></ul><h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><ul><li>RDB 是整个数据库的快照，这决定了其无法做到非常高频地备份出快照。在 Redis 意外退出时，至少丢失数分钟的数据。</li><li>当数据库很大时，fork 子进程也将会比较耗时</li><li>执行快照过程中，如果父进程接收大量写请求，将导致大量的内存页拷贝。</li></ul><h2 id="AOF-Append-only-file"><a href="#AOF-Append-only-file" class="headerlink" title="AOF(Append-only file)"></a>AOF(Append-only file)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfsync always # 每次 AOF 写就同步</span><br><span class="line">appendfsync everysec # 每秒同步一次</span><br><span class="line">appendfsync no # 由 OS 决定同步时机</span><br></pre></td></tr></table></figure><p>开启 AOF 后，Redis 每收到一条写命令就会将该命令写入 AOF，Redis 重启时就可以重放 AOF 文件恢复数据。当 AOF 增长到一定大小时就需要进行重写，减小文件大小。</p><h3 id="rewrite-过程"><a href="#rewrite-过程" class="headerlink" title="rewrite 过程"></a>rewrite 过程</h3><p><code>BGREWRITEAOF</code>。</p><ol><li>flush <code>aof_buf</code>，调用 <code>fsync</code></li><li>创建新的 incremental AOF 文件记录后续写命令</li><li>Fork 子进程</li><li>子进程将当前数据库以 AOF 格式写入 temp BASE file</li><li>父进程 rename(temp BASE file, BASE file) 并与 incremental AOF 构建一个新的 manifest 文件</li></ol><h3 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros"></a>Pros</h3><ul><li>相比 RDB 有更优 durability，可做到秒级的数据备份</li><li>AOF 使用 RESP 协议记录，易于直接阅读</li></ul><h3 id="Cons-1"><a href="#Cons-1" class="headerlink" title="Cons"></a>Cons</h3><ul><li>AOF 文件通常比 RDB 文件大</li><li><code>appendfsync everysec</code> 对性能有轻微影响，实际并不明显</li></ul><h2 id="RDB-AOF"><a href="#RDB-AOF" class="headerlink" title="RDB + AOF"></a>RDB + AOF</h2><blockquote><p>Redis 5 中默认开启</p></blockquote><p>RDB + AOF 结合了 RDB 和 AOF 的优点，此时整体格式变为：[RDB] + [AOF]，在 AOF 重写子进程中，不再是以 RESP 协议导出数据库到 BASE file，而是 RDB，即 BASE AOF file 中保存了 RDB 格式的数据。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://redis.io/docs/management/persistence/">Redis persistence</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Based on Redis 7.0.11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redis 提供了四种持久化的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No persistence：不做持久化处理，用得较少。&lt;/li&gt;
&lt;li&gt;RDB：对缓存做全量</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
    <category term="RDB" scheme="https://clsrfish.github.io/tags/RDB/"/>
    
    <category term="AOF" scheme="https://clsrfish.github.io/tags/AOF/"/>
    
  </entry>
  
  <entry>
    <title>Redis 键的生存时间</title>
    <link href="https://clsrfish.github.io/2023/05/14/00996dc0546d.html"/>
    <id>https://clsrfish.github.io/2023/05/14/00996dc0546d.html</id>
    <published>2023-05-14T09:48:54.000Z</published>
    <updated>2023-05-14T11:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>EXPIRE seconds</td><td>设置剩余生存时间</td></tr><tr><td>PEXPIRE milliseconds</td><td>同上，单位毫秒</td></tr><tr><td>EXPIREAT seconds-timestamp</td><td>设置过期时间戳</td></tr><tr><td>PEXPIREAT milliseconds-timestamp</td><td>同上，单位毫秒</td></tr><tr><td>SETEX &#x2F; SET EX</td><td>专用于 String</td></tr><tr><td>PERSIST</td><td>去除过期时间</td></tr></tbody></table><p>设置过期时间命令最终都会调用 <code>PEXPIREAT</code>，当键发生更新时，过期时间失效。</p><h2 id="剩余生存时间"><a href="#剩余生存时间" class="headerlink" title="剩余生存时间"></a>剩余生存时间</h2><p><code>TTL key</code> or <code>PTTL key</code>。</p><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>三种策略：</p><ul><li>定时删除：对键设置过期时间的同时，设置一个 timer，timer 到期后立即删除键。</li><li>惰性删除：在访问时做过期检查，过期则先删除，再执行原来的操作。</li><li>定期删除：周期性地删除一批过期键。</li></ul><p>定期删除，内存友好，CPU 不友好。过期键较多时会大量占用 CPU，同时需要注册时间事件。<br>惰性删除对内存不友好，如果键过期后一直没被访问，则此键将一直驻留在内存中。<br>定期删除是前两种地折衷，Redis 中是遍历数据库，然后从 <code>expires</code> 中随机挑选 <code>key</code> 并删除已过期键，执行超过指定时间则停止。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设置过期时间&quot;&gt;&lt;a href=&quot;#设置过期时间&quot; class=&quot;headerlink&quot; title=&quot;设置过期时间&quot;&gt;&lt;/a&gt;设置过期时间&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thea</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Object</title>
    <link href="https://clsrfish.github.io/2023/05/05/bc852159c7f6.html"/>
    <id>https://clsrfish.github.io/2023/05/05/bc852159c7f6.html</id>
    <published>2023-05-04T17:10:11.000Z</published>
    <updated>2023-05-14T00:47:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><p>Redis 对外支持的数据类型（String、List、Hash、Set、ZSet）并不是直接使用其定义的数据结构，而是基于另外的一套对象系统。对象系统除了可以根据不同场景选择不同底层数据结构外，还实现了基于引用计数的<em>对象共享</em>和<em>垃圾回收</em>以及<em>缓存淘汰</em>机制。</p><h2 id="Redis-Object-定义"><a href="#Redis-Object-定义" class="headerlink" title="Redis Object 定义"></a>Redis Object 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;    <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                         * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                         * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li><code>type</code>：记录对象类型<table><thead><tr><th>类型</th><th>取值</th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>0</td></tr><tr><td>OBJ_LIST</td><td>1</td></tr><tr><td>OBJ_SET</td><td>2</td></tr><tr><td>OBJ_ZSET</td><td>3</td></tr><tr><td>OBJ_HASH</td><td>4</td></tr></tbody></table></li><li><code>encoding</code>：记录对象的编码及底层实现<table><thead><tr><th>编码</th><th>取值</th><th>对应数据结构</th></tr></thead><tbody><tr><td>OBJ_ENCODING_RAW</td><td>0</td><td>SDS</td></tr><tr><td>OBJ_ENCODING_INT</td><td>1</td><td>long</td></tr><tr><td>OBJ_ENCODING_HT</td><td>2</td><td>字典</td></tr><tr><td>OBJ_ENCODING_INTSET</td><td>6</td><td>整数集合</td></tr><tr><td>OBJ_ENCODING_SKIPLIST</td><td>7</td><td>跳表和字典</td></tr><tr><td>OBJ_ENCODING_EMBSTR</td><td>8</td><td>embedded 编码的 SDS</td></tr><tr><td>OBJ_ENCODING_QUICKLIST</td><td>9</td><td></td></tr><tr><td>OBJ_ENCODING_STREAM</td><td>10</td><td></td></tr><tr><td>OBJ_ENCODING_LISTPACK</td><td>11</td><td></td></tr></tbody></table></li><li><code>lru</code>：缓存淘汰策略相关</li><li><code>refcount</code>：引用计数</li><li><code>ptr</code>：底层数据指针</li></ul><p>该结构采用了 <code>Bit Field</code> 来降低内存的占用。Redis 会根据实际情况（数据类型，数据大小）选择相对合适的 <code>encoding</code> 来提高性能与效率。</p><table><thead><tr><th>type</th><th>encoding</th><th>对象</th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>OBJ_ENCODING_RAW</td><td><code>ptr</code> 指向 SDS</td></tr><tr><td>OBJ_STRING</td><td>OBJ_ENCODING_INT</td><td><code>ptr</code> 值就是整数值，而非地址</td></tr><tr><td>OBJ_STRING</td><td>OBJ_ENCODING_EMBSTR</td><td>字符串较短时，一次分配一块内存连续存放 <code>redisObject</code> 和 <code>sdshdr</code> 对象</td></tr><tr><td>OBJ_LIST</td><td>OBJ_ENCODING_QUICKLIST</td><td><code>ptr</code> 指向 <code>quicklist</code></td></tr><tr><td>OBJ_SET</td><td>OBJ_ENCODING_HT</td><td><code>ptr</code> 指向 <code>dict</code>，只使用 key，值设为 NULL</td></tr><tr><td>OBJ_SET</td><td>OBJ_ENCODING_INTSET</td><td><code>ptr</code> 指向 <code>intset</code>，所有元素都是整数，且数量不超过 512</td></tr><tr><td>OBJ_ZSET</td><td>OBJ_ENCODING_LISTPACK</td><td><code>ptr</code> 指向 <code>listpack</code>，元素数量 &lt; <code>server.zset_max_listpack_entries</code> 且元素大小 &lt; <code>server.zset_max_listpack_value</code></td></tr><tr><td>OBJ_ZSET</td><td>OBJ_ENCODING_SKIPLIST</td><td><code>ptr</code> 指向 <code>zset&#123;dict, skiplist&#125;</code>,</td></tr><tr><td>OBJ_HASH</td><td>OBJ_ENCODING_LISTPACK</td><td><code>ptr</code> 指向 <code>listpack</code>，元素数量 &lt; <code>server.zset_max_listpack_entries</code> 且元素大小 &lt; <code>server.zset_max_listpack_value</code>。暂时不支持 HT 转成 LISTPACK</td></tr><tr><td>OBJ_HASH</td><td>OBJ_ENCODING_HT</td><td><code>ptr</code> 指向 <code>dict</code></td></tr></tbody></table><h2 id="对象引用计数"><a href="#对象引用计数" class="headerlink" title="对象引用计数"></a>对象引用计数</h2><p>Redis 通过追踪 <code>redisObject#refcount</code>，在适当的时候自动释放 <code>refcount == 0</code> 的对象。</p><p>引用计数除了用作垃圾回收外，还可用作对象共享。不过对象共享需要查找到一个具有相同值的对象，O(N<sup>2</sup>) 复杂度，CPU 开销大。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/server.h">server.h&#x2F;redisObject</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_string.h">t_string.h</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_list.h">t_list.h</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_hash.h">t_hash.h</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_set.h">t_set.h</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_zset.h">t_zset.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Based on Redis 7.0.11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redis 对外支持的数据类型（String、List、Hash、Set、ZSet）并不是直接使用其定义的数据结构，而是基于另外的一套对象系统。对象系统除了可以</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
    <category term="Object" scheme="https://clsrfish.github.io/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>Redis Ziplist</title>
    <link href="https://clsrfish.github.io/2023/05/04/1f8b284123ca.html"/>
    <id>https://clsrfish.github.io/2023/05/04/1f8b284123ca.html</id>
    <published>2023-05-03T17:37:12.000Z</published>
    <updated>2023-05-03T17:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Ziplist-定义"><a href="#Ziplist-定义" class="headerlink" title="Ziplist 定义"></a>Ziplist 定义</h2><p>Ziplist 没有像其它数据结构一样提供明确的 <code>struct</code> 定义，因为部分成员的大小不是固定的，以达到节省内存的目的。提供的 struct 也只是为了方便读取信息。所以就贴一下注释内容吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZIPLIST OVERALL LAYOUT</span></span><br><span class="line"><span class="comment"> * ======================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The general layout of the ziplist is as follows:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> all fields are stored in little endian, if not specified otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;uint32_t zlbytes&gt; is an unsigned integer to hold the number of bytes that</span></span><br><span class="line"><span class="comment"> * the ziplist occupies, including the four bytes of the zlbytes field itself.</span></span><br><span class="line"><span class="comment"> * This value needs to be stored to be able to resize the entire structure</span></span><br><span class="line"><span class="comment"> * without the need to traverse it first.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;uint32_t zltail&gt; is the offset to the last entry in the list. This allows</span></span><br><span class="line"><span class="comment"> * a pop operation on the far side of the list without the need for full</span></span><br><span class="line"><span class="comment"> * traversal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;uint16_t zllen&gt; is the number of entries. When there are more than</span></span><br><span class="line"><span class="comment"> * 2^16-2 entries, this value is set to 2^16-1 and we need to traverse the</span></span><br><span class="line"><span class="comment"> * entire list to know how many items it holds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;uint8_t zlend&gt; is a special entry representing the end of the ziplist.</span></span><br><span class="line"><span class="comment"> * Is encoded as a single byte equal to 255. No other normal entry starts</span></span><br><span class="line"><span class="comment"> * with a byte set to the value of 255.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZIPLIST ENTRIES</span></span><br><span class="line"><span class="comment"> * ===============</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Every entry in the ziplist is prefixed by metadata that contains two pieces</span></span><br><span class="line"><span class="comment"> * of information. First, the length of the previous entry is stored to be</span></span><br><span class="line"><span class="comment"> * able to traverse the list from back to front. Second, the entry encoding is</span></span><br><span class="line"><span class="comment"> * provided. It represents the entry type, integer or string, and in the case</span></span><br><span class="line"><span class="comment"> * of strings it also represents the length of the string payload.</span></span><br><span class="line"><span class="comment"> * So a complete entry is stored like this:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Sometimes the encoding represents the entry itself, like for small integers</span></span><br><span class="line"><span class="comment"> * as we&#x27;ll see later. In such a case the &lt;entry-data&gt; part is missing, and we</span></span><br><span class="line"><span class="comment"> * could have just:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;prevlen&gt; &lt;encoding&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The length of the previous entry, &lt;prevlen&gt;, is encoded in the following way:</span></span><br><span class="line"><span class="comment"> * If this length is smaller than 254 bytes, it will only consume a single</span></span><br><span class="line"><span class="comment"> * byte representing the length as an unsigned 8 bit integer. When the length</span></span><br><span class="line"><span class="comment"> * is greater than or equal to 254, it will consume 5 bytes. The first byte is</span></span><br><span class="line"><span class="comment"> * set to 254 (FE) to indicate a larger value is following. The remaining 4</span></span><br><span class="line"><span class="comment"> * bytes take the length of the previous entry as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So practically an entry is encoded in the following way:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Or alternatively if the previous entry length is greater than 253 bytes</span></span><br><span class="line"><span class="comment"> * the following encoding is used:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The encoding field of the entry depends on the content of the</span></span><br><span class="line"><span class="comment"> * entry. When the entry is a string, the first 2 bits of the encoding first</span></span><br><span class="line"><span class="comment"> * byte will hold the type of encoding used to store the length of the string,</span></span><br><span class="line"><span class="comment"> * followed by the actual length of the string. When the entry is an integer</span></span><br><span class="line"><span class="comment"> * the first 2 bits are both set to 1. The following 2 bits are used to specify</span></span><br><span class="line"><span class="comment"> * what kind of integer will be stored after this header. An overview of the</span></span><br><span class="line"><span class="comment"> * different types and encodings is as follows. The first byte is always enough</span></span><br><span class="line"><span class="comment"> * to determine the kind of entry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * |00pppppp| - 1 byte</span></span><br><span class="line"><span class="comment"> *      String value with length less than or equal to 63 bytes (6 bits).</span></span><br><span class="line"><span class="comment"> *      &quot;pppppp&quot; represents the unsigned 6 bit length.</span></span><br><span class="line"><span class="comment"> * |01pppppp|qqqqqqqq| - 2 bytes</span></span><br><span class="line"><span class="comment"> *      String value with length less than or equal to 16383 bytes (14 bits).</span></span><br><span class="line"><span class="comment"> *      IMPORTANT: The 14 bit number is stored in big endian.</span></span><br><span class="line"><span class="comment"> * |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes</span></span><br><span class="line"><span class="comment"> *      String value with length greater than or equal to 16384 bytes.</span></span><br><span class="line"><span class="comment"> *      Only the 4 bytes following the first byte represents the length</span></span><br><span class="line"><span class="comment"> *      up to 2^32-1. The 6 lower bits of the first byte are not used and</span></span><br><span class="line"><span class="comment"> *      are set to zero.</span></span><br><span class="line"><span class="comment"> *      IMPORTANT: The 32 bit number is stored in big endian.</span></span><br><span class="line"><span class="comment"> * |11000000| - 3 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int16_t (2 bytes).</span></span><br><span class="line"><span class="comment"> * |11010000| - 5 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int32_t (4 bytes).</span></span><br><span class="line"><span class="comment"> * |11100000| - 9 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int64_t (8 bytes).</span></span><br><span class="line"><span class="comment"> * |11110000| - 4 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as 24 bit signed (3 bytes).</span></span><br><span class="line"><span class="comment"> * |11111110| - 2 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as 8 bit signed (1 byte).</span></span><br><span class="line"><span class="comment"> * |1111xxxx| - (with xxxx between 0001 and 1101) immediate 4 bit integer.</span></span><br><span class="line"><span class="comment"> *      Unsigned integer from 0 to 12. The encoded value is actually from</span></span><br><span class="line"><span class="comment"> *      1 to 13 because 0000 and 1111(&lt;zlend&gt;) can not be used, so 1 should be</span></span><br><span class="line"><span class="comment"> *      subtracted from the encoded 4 bit value to obtain the right value.</span></span><br><span class="line"><span class="comment"> * |11111111| - End of ziplist special entry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Like for the ziplist header, all the integers are represented in little</span></span><br><span class="line"><span class="comment"> * endian byte order, even when this code is compiled in big endian systems.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * EXAMPLES OF ACTUAL ZIPLISTS</span></span><br><span class="line"><span class="comment"> * ===========================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following is a ziplist containing the two elements representing</span></span><br><span class="line"><span class="comment"> * the strings &quot;2&quot; and &quot;5&quot;. It is composed of 15 bytes, that we visually</span></span><br><span class="line"><span class="comment"> * split into sections:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  [0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]</span></span><br><span class="line"><span class="comment"> *        |             |          |       |       |     |</span></span><br><span class="line"><span class="comment"> *     zlbytes        zltail     zllen    &quot;2&quot;     &quot;5&quot;   end</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The first 4 bytes represent the number 15, that is the number of bytes</span></span><br><span class="line"><span class="comment"> * the whole ziplist is composed of. </span></span><br><span class="line"><span class="comment"> * The second 4 bytes are the offset at which the last ziplist entry is </span></span><br><span class="line"><span class="comment"> * found, that is 12, in fact the last entry, that is &quot;5&quot;, is at offset </span></span><br><span class="line"><span class="comment"> * 12 inside the ziplist.</span></span><br><span class="line"><span class="comment"> * The next 16 bit integer represents the number of elements inside the</span></span><br><span class="line"><span class="comment"> * ziplist, its value is 2 since there are just two elements inside.</span></span><br><span class="line"><span class="comment"> * Finally &quot;00 f3&quot; is the first entry representing the number 2. It is</span></span><br><span class="line"><span class="comment"> * composed of the previous entry length, which is zero because this is</span></span><br><span class="line"><span class="comment"> * our first entry, and the byte F3 which corresponds to the encoding</span></span><br><span class="line"><span class="comment"> * |1111xxxx| with xxxx between 0001 and 1101. We need to remove the &quot;F&quot;</span></span><br><span class="line"><span class="comment"> * higher order bits 1111, and subtract 1 from the &quot;3&quot;, so the entry value</span></span><br><span class="line"><span class="comment"> * is &quot;2&quot;. The next entry has a prevlen of 02, since the first entry is</span></span><br><span class="line"><span class="comment"> * composed of exactly two bytes. The entry itself, F6, is encoded exactly</span></span><br><span class="line"><span class="comment"> * like the first entry, and 6-1 = 5, so the value of the entry is 5.</span></span><br><span class="line"><span class="comment"> * Finally the special entry FF signals the end of the ziplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Adding another element to the above string with the value &quot;Hello World&quot;</span></span><br><span class="line"><span class="comment"> * allows us to show how the ziplist encodes small strings. We&#x27;ll just show</span></span><br><span class="line"><span class="comment"> * the hex dump of the entry itself. Imagine the bytes as following the</span></span><br><span class="line"><span class="comment"> * entry that stores &quot;5&quot; in the ziplist above:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [02] [0b] [48 65 6c 6c 6f 20 57 6f 72 6c 64]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The first byte, 02, is the length of the previous entry. The next</span></span><br><span class="line"><span class="comment"> * byte represents the encoding in the pattern |00pppppp| that means</span></span><br><span class="line"><span class="comment"> * that the entry is a string of length &lt;pppppp&gt;, so 0B means that</span></span><br><span class="line"><span class="comment"> * an 11 bytes string follows. From the third byte (48) to the last (64)</span></span><br><span class="line"><span class="comment"> * there are just the ASCII characters for &quot;Hello World&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>每一个 entry 由 <code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code> 构成，其中 <code>&lt;prelen&gt;</code> 占用字节数由前一节点长度决定，所以某一位置节点的更新或插入，会导致后继节点的重新分配。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/ziplist.h">ziplist.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Based on Redis 7.0.11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Ziplist-定义&quot;&gt;&lt;a href=&quot;#Ziplist-定义&quot; class=&quot;headerlink&quot; title=&quot;Ziplist 定义&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
    <category term="Ziplist" scheme="https://clsrfish.github.io/tags/Ziplist/"/>
    
  </entry>
  
  <entry>
    <title>Redis Intset</title>
    <link href="https://clsrfish.github.io/2023/05/04/b29e26902a89.html"/>
    <id>https://clsrfish.github.io/2023/05/04/b29e26902a89.html</id>
    <published>2023-05-03T16:41:15.000Z</published>
    <updated>2023-05-03T16:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Intset-定义"><a href="#Intset-定义" class="headerlink" title="Intset 定义"></a>Intset 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><ul><li><code>encoding</code>：整数的编码方式，实际上表示整数的取值范围（占用字节）。可选值有 <code>INSET_ENC_INT16</code>、<code>INSET_ENC_INT32</code> 和 <code>INSET_ENC_INT64</code>。</li><li><code>length</code>：整数个数，通过 <code>length</code> 和 <code>encoding</code> 可以计算出 <code>contents</code> 大小。</li><li><code>contents</code>：字节数组，每次 Add 或 Remove 都会引起 <code>contents</code> 长度变化（<code>realloc</code>）。</li></ul><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>升级指 <code>enocding</code> 由较少字节占用扩展到更多字节占用。升级由超过当前 <code>encoding</code> 所能表示的上下限的新元素引起，这个时候新元素要么在 <code>contents</code> 头部，要么在尾部插入。</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>不支持降级。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/intset.h">intset.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Based on Redis 7.0.11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Intset-定义&quot;&gt;&lt;a href=&quot;#Intset-定义&quot; class=&quot;headerlink&quot; title=&quot;Intset 定义&quot;&gt;&lt;/a&gt;In</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
    <category term="Intset" scheme="https://clsrfish.github.io/tags/Intset/"/>
    
  </entry>
  
  <entry>
    <title>Redis Skiplist</title>
    <link href="https://clsrfish.github.io/2023/05/02/9712a7092d6a.html"/>
    <id>https://clsrfish.github.io/2023/05/02/9712a7092d6a.html</id>
    <published>2023-05-02T05:32:07.000Z</published>
    <updated>2023-05-02T05:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Skiplist-定义"><a href="#Skiplist-定义" class="headerlink" title="Skiplist 定义"></a>Skiplist 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><ul><li><code>zskiplistNode.score</code>：节点的权重，它决定了节点在列表中的位置（从小到大）；分值相同的节点则按照 <code>ele</code> 的字典顺序排序。</li><li><code>zskiplistNode.level</code>：level 数组包含指向后续节点的指针，<code>nodes[a].level[N]</code> 指向 <code>nodes[b].level[N]</code> 或 NULL， 其中 <code>a &lt; b</code>。<strong>新节点会随机创建一个介于 <code>[1, 32]</code> 大小的 level 数组</strong>。</li><li><code>zskiplistNode.zskiplistLevel.span</code>：步长或跨度，<code>nodes[a].level[N]</code> 指向 <code>nodes[b].level[N]</code> 跨越的节点数（包含结尾）。</li></ul><p>示意图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--+</span><br><span class="line">|L32 --0-&gt; NULL</span><br><span class="line">+--+</span><br><span class="line">....</span><br><span class="line">+--+                             +--+</span><br><span class="line">|L5| -------------3------------&gt; |L5| --0-&gt; NULL</span><br><span class="line">+--+       +--+                  +--+</span><br><span class="line">|L4| --1-&gt; |L4| -------2-------&gt; |L4| --0-&gt; NULL</span><br><span class="line">+--+       +--+                  +--+</span><br><span class="line">|L3| --1-&gt; |L3| -------2-------&gt; |L3| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+</span><br><span class="line">|L2| --1-&gt; |L2| --1-&gt; |L2| --1-&gt; |L2| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+</span><br><span class="line">|L1| --1-&gt; |L1| --1-&gt; |L1| --1-&gt; |L1| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+</span><br><span class="line">      +--- |BW| &lt;---- |BW| &lt;---- |BW|</span><br><span class="line">      |    +--+       +--+       +--+</span><br><span class="line">    NULL   |1.|       |2.|       |3.|</span><br><span class="line">           +--+       +--+       +--+</span><br><span class="line">           |o1|       |o2|       |o3|</span><br><span class="line">           +--+       +--+       +--+</span><br><span class="line">head                             tail</span><br></pre></td></tr></table></figure><blockquote><p>换个角度，跳表非常像某一链接及其子序列链表的加总。</p></blockquote><h2 id="搜索节点"><a href="#搜索节点" class="headerlink" title="搜索节点"></a>搜索节点</h2><p>从 <code>head</code> 最高层开始，往下逐层缩小查找范围，有点类似二分查找。</p><h2 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h2><ol><li>找到新节点将要插入的位置。</li><li>找到新节点在每层链表中的前驱节点，即往前距新节点最近的 <code>level[N]</code>。例如 <code>o2.L1</code>、<code>o2.L2</code> 和 <code>o1.L4</code>。</li><li>修改前驱节点的 <code>level[L].forward</code> 及 <code>span</code>。</li><li>对于位于新节点之前且 <code>nodes[N].level[L] &amp;&amp; L &gt; new.level.length</code> 的节点，<code>span++</code>。例如 <code>o1.L4</code> 和 <code>head.L5</code>。</li><li>更新 <code>backward</code> 指针。例如 <code>o3.BW</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--+</span><br><span class="line">|L32 --0-&gt; NULL</span><br><span class="line">+--+</span><br><span class="line">....</span><br><span class="line">+--+                                        +--+</span><br><span class="line">&#123;L5&#125; ------------------4------------------&gt; |L5| --0-&gt; NULL</span><br><span class="line">+--+       +--+                             +--+</span><br><span class="line">|L4| --1-&gt; &#123;L4&#125; -------------3------------&gt; |L4| --0-&gt; NULL</span><br><span class="line">+--+       +--+                  +--+       +--+</span><br><span class="line">|L3| --1-&gt; &#123;L3&#125; -------2-------&gt; |L3| --1-&gt; |L3| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+       +--+</span><br><span class="line">|L2| --1-&gt; |L2| --1-&gt; &#123;L2&#125; --1-&gt; |L2| --1-&gt; |L2| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+       +--+</span><br><span class="line">|L1| --1-&gt; |L1| --1-&gt; &#123;L1&#125; --1-&gt; |L1| --1-&gt; |L1| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+       +--+</span><br><span class="line">      +--- |BW| &lt;---- |BW| &lt;---- |BW| &lt;---- &#123;BW&#125;</span><br><span class="line">      |    +--+       +--+       +--+       +--+</span><br><span class="line">    NULL   |1.|       |2.|       |2.|       |3.|</span><br><span class="line">           +--+       +--+       +--+       +--+</span><br><span class="line">           |o1|       |o2|       |on|       |o3|</span><br><span class="line">           +--+       +--+       +--+       +--+</span><br><span class="line">head                             new        tail</span><br></pre></td></tr></table></figure><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/server.h">server.h&#x2F;zskiplist</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Based on Redis 7.0.11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Skiplist-定义&quot;&gt;&lt;a href=&quot;#Skiplist-定义&quot; class=&quot;headerlink&quot; title=&quot;Skiplist 定义&quot;&gt;</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
    <category term="Skiplist" scheme="https://clsrfish.github.io/tags/Skiplist/"/>
    
  </entry>
  
  <entry>
    <title>Redis Hash Tables</title>
    <link href="https://clsrfish.github.io/2023/05/02/38e97e9bbdf0.html"/>
    <id>https://clsrfish.github.io/2023/05/02/38e97e9bbdf0.html</id>
    <published>2023-05-01T23:37:15.000Z</published>
    <updated>2023-05-01T23:37:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Hash-table-定义"><a href="#Hash-table-定义" class="headerlink" title="Hash table 定义"></a>Hash table 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>     <span class="comment">/* Next entry in the same hash bucket. */</span></span><br><span class="line">    <span class="type">void</span> *metadata[];           <span class="comment">/* An arbitrary number of bytes (starting at a</span></span><br><span class="line"><span class="comment">                                 * pointer-aligned address) of size as returned</span></span><br><span class="line"><span class="comment">                                 * by dictType&#x27;s dictEntryMetadataBytes(). */</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(dict *d, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(dict *d, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(dict *d, <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*expandAllowed)(<span class="type">size_t</span> moreMem, <span class="type">double</span> usedRatio);</span><br><span class="line">    <span class="comment">/* Allow a dictEntry to carry extra caller-defined metadata.  The</span></span><br><span class="line"><span class="comment">     * extra memory is initialized to 0 when a dictEntry is allocated. */</span></span><br><span class="line">    <span class="type">size_t</span> (*dictEntryMetadataBytes)(dict *d);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    dictEntry **ht_table[<span class="number">2</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ht_used[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep small vars at end for optimal (minimal) struct padding */</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash; <span class="comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> ht_size_exp[<span class="number">2</span>]; <span class="comment">/* exponent of size. (size = 1&lt;&lt;exp) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>dictEntry.v</code>：使用 union 以支持更多具体类型，又共享 8 bytes空间。</li><li><code>dictEntry.metadata</code>：供使用方存放一些自定义数据，柔性数组，不使用时不额外占用空间。</li><li><code>dictType</code>：dict 多态能力，其中 <code>expandAllowed</code> 将是否扩容的控制权交给了使用方。</li><li><code>dict.ht_table</code>：一般只有 <code>ht_table[0]</code> 在使用，<code>ht_table[1]</code> 只在扩容时被启用。</li><li><code>dict.ht_used</code>：对应 <code>dict.ht_table</code> 存放的节点数。</li><li><code>dict.rehashidx</code>：渐进式 rehash 使用。</li><li><code>dict.pauserehash</code>：暂停 rehash，一般在开始遍历前设置，整数值表示有多少个暂停请求。</li><li><code>dict.ht_size_exp</code>：<code>dict.ht_table[N]</code> 的大小用 <code>2^dict.ht_size_exp[N]</code> 表示。</li></ul><h2 id="扩容与收缩"><a href="#扩容与收缩" class="headerlink" title="扩容与收缩"></a>扩容与收缩</h2><p><code>load factor = ht_used[N] / 2^dict.ht_size_exp[N]</code>。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>扩容条件：<code>load factor &gt;= 1</code></p><p>扩容大小：<code>dict.ht_size_exp[N] = X</code>, 其中 X 满足: <code>min(2^X) &gt;= 2 * dict.ht_used[N]</code>。</p><p><strong>Note</strong>: 在有子进程执行 <code>BGSAVE</code> 或者 <code>BGREWRITEAOF</code> 时，因为父子进程通过 <strong>COW</strong> 共享内存，为了避免内存写操作带来内存拷贝，扩容条件变为 <code>load factor &gt;= 5</code>。</p><h2 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h2><p>收缩条件：<code>load factor &lt; 0.1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收缩大小：<code>dict.ht_size_exp[N] = X</code>, 其中 X 满足: <code>min(2^X) &gt; dict.ht_used[N]</code>。</p><p><strong>Note</strong>：与扩容类似，只有在没有子进程时，收缩操作才能进行。</p><hr><p>不管是扩容还是收缩，<code>dict</code> 都会进入 rehash 状态，rehash 结束后 <code>ht_table[0]</code> 被替换成 <code>ht_table[1]</code>。</p><h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><p>为了降低扩容或收缩对性能带来的影响，<code>ht_table[0]</code> 中节点会分多次 rehash 到 <code>ht_table[1]</code> 中。</p><p>在 rehash CURD：</p><table><thead><tr><th>操作</th><th>步骤</th></tr></thead><tbody><tr><td>Add</td><td>直接写入 <code>ht_table[1]</code>。</td></tr><tr><td>Find</td><td>依次查找 <code>ht_table[0]</code> 和 <code>ht_table[1]</code>。</td></tr><tr><td>Delete</td><td>依次从 <code>ht_table[0]</code> 和 <code>ht_table[1]</code> 中删除。</td></tr><tr><td>Update</td><td>依次查找 <code>ht_table[0]</code> 和 <code>ht_table[1]</code>，然后更新 <code>v</code>。</td></tr></tbody></table><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/dict.h">dict.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Based on Redis 7.0.11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Hash-table-定义&quot;&gt;&lt;a href=&quot;#Hash-table-定义&quot; class=&quot;headerlink&quot; title=&quot;Hash tabl</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
    <category term="Hash Tables" scheme="https://clsrfish.github.io/tags/Hash-Tables/"/>
    
  </entry>
  
  <entry>
    <title>Redis Doubly Linked List</title>
    <link href="https://clsrfish.github.io/2023/05/01/22493bffd51e.html"/>
    <id>https://clsrfish.github.io/2023/05/01/22493bffd51e.html</id>
    <published>2023-05-01T05:24:43.000Z</published>
    <updated>2023-05-01T05:24:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Doubly-linked-list-定义"><a href="#Doubly-linked-list-定义" class="headerlink" title="Doubly linked list 定义"></a>Doubly linked list 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><ul><li><code>value</code>: 链表节点使用 <code>void *</code> 保存值，结合 <code>dup</code>、<code>free</code> 和 <code>match</code> 实现了对多态支持。</li><li><code>dup</code>: 拷贝 <code>value</code> 用，如果没有设置则默认浅拷贝。</li><li><code>free</code>: 回收 <code>value</code> 用，如果没有设置就不对 <code>value</code> 进行额外回收处理。</li><li><code>match</code>: 比较 <code>value</code> 和 <code>key</code> 是否相等，未设置则直接比较指针。</li></ul><p><code>list</code> 只提供双端链表的功能，具体节点值及对应的行为完全由使用方负责。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/adlist.h">sds.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Based on Redis 7.0.11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Doubly-linked-list-定义&quot;&gt;&lt;a href=&quot;#Doubly-linked-list-定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
    <category term="doubly linked list" scheme="https://clsrfish.github.io/tags/doubly-linked-list/"/>
    
  </entry>
  
  <entry>
    <title>Redis SDS</title>
    <link href="https://clsrfish.github.io/2023/05/01/7287d65b6bc0.html"/>
    <id>https://clsrfish.github.io/2023/05/01/7287d65b6bc0.html</id>
    <published>2023-05-01T01:57:08.000Z</published>
    <updated>2023-05-01T01:57:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="SDS-定义"><a href="#SDS-定义" class="headerlink" title="SDS 定义"></a>SDS 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5  0   <span class="comment">// 0b0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8  1   <span class="comment">// 0b0001</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2   <span class="comment">// 0b0010</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3   <span class="comment">// 0b0011</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4   <span class="comment">// 0b0100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_MASK 7 <span class="comment">// 0b0111</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_BITS 3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>len</code>: 字节数组内容长度，不含结尾空字符 <code>\0</code>。</li><li><code>alloc</code>: 字节数组长度，不含结尾空字符 <code>\0</code>。</li><li><code>flags</code>: SDS 类型，由字节数组长度在创建 SDS 时决定，目的是节省 <code>len</code> 和 <code>alloc</code> 空间。<code>flags</code> 的 3 lsb（最低有效位）存储 <code>SDS_TYPE_N</code>，除 <code>sdshdr5</code> 将 5 msb（最高有效位）存储字节数组长度外，其余的都没具体用途。</li><li><code>buf</code>: 字节数组。柔性数组，<code>sizeof(sdshdrxx)</code> 得到的 <code>hdrlen</code> 不包含柔性数组大小。</li></ul><p><code>typedef char *sds;</code> 定义了 SDS 方法接收对象，实际上指向的是 <code>buf</code>，这样可以方便执行 <code>print(&quot;%s&quot;, sds);</code>。访问其它结构体成员时，先通过 <code>#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</code> 拿到结构体指针，再访问。</p><h2 id="相比-C-字符串优点"><a href="#相比-C-字符串优点" class="headerlink" title="相比 C 字符串优点"></a>相比 C 字符串优点</h2><ol><li><p>O(1) 复杂度计算内容长度</p></li><li><p>避免缓冲区溢出<br>比如 <code>strcat(s1, s2)</code>，如果 <code>s1</code> 和 <code>s2</code> 在内存中相邻排布：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> s1               s2</span><br><span class="line">+-+-+-+-+-+-+-+--+-+-+-+-+-+-+--+</span><br><span class="line">|A|B|C|D|E|F|G|\0|0|1|2|3|4|5|\0|</span><br><span class="line">+-+-+-+-+-+-+-+--+-+-+-+-+-+-+--+</span><br></pre></td></tr></table></figure><p><code>strcat</code> 假定 <code>s1</code> 已被分配足够内存，如果这个假定不成立，就会发生缓冲区溢出，<code>s2</code> 的内容被意外修改。</p></li><li><p>减少内存分配释放次数</p><ol><li>空间预分配。对 SDS 修改并需要拓展字节数组时，出了分配必要空间外，还会额外分配一块预留空间，预留空间大小一般与 <code>len</code> 大小一样，最大 1M（<code>#define SDS_MAX_PREALLOC (1024*1024)</code>）。</li><li>空间懒回收。当缩短 SDS 时，只会即时更新 <code>len</code>，不会立即释放多出来的空间。</li></ol></li><li><p>二进制安全。C 字符串通过 <code>\0</code> 确定字符串长度，不适用于字符串外的其它数据格式，比如图片等。SDS 通过 <code>len</code> 确定长度，理论上字节数组可以存储任意二进制内容。</p></li><li><p>兼容部分 C 字符串函数。SDS 虽然不依赖 <code>\0</code> 确定内容长度，但还是会在 <code>buf</code> 尾部加上一个 <code>\0</code>，兼容部分 C 字符串函数。</p></li></ol><p>关于 SDS 内存重新分配，核心是 <code>realloc</code> 函数：</p><blockquote><p>The <code>realloc()</code> function changes the size of the memory block pointed to by <code>ptr</code> to size bytes.  The contents will be unchanged in the range from the start of  the  region up  to  the  minimum of the old and new sizes.  If the new size is larger than the old size, the added memory will not be initialized.  If <code>ptr</code> is <code>NULL</code>, then the call is equivalent to <code>malloc(size)</code>, for all values of size; if size is equal to zero, and ptr is not <code>NULL</code>, then the call is equivalent to <code>free(ptr)</code>.  Unless <code>ptr</code> is <code>NULL</code>, it must have been returned by an earlier call to <code>malloc()</code>, <code>calloc()</code>, or <code>realloc()</code>. If the area pointed to was moved, a <code>free(ptr)</code> is done.</p></blockquote><p>简单说就是 <code>realloc</code> 完成了内存分配、内存拷贝以及内存释放等动作。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/sds.h">sds.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Based on Redis 7.0.11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;SDS-定义&quot;&gt;&lt;a href=&quot;#SDS-定义&quot; class=&quot;headerlink&quot; title=&quot;SDS 定义&quot;&gt;&lt;/a&gt;SDS 定义&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://clsrfish.github.io/tags/Redis/"/>
    
    <category term="SDS" scheme="https://clsrfish.github.io/tags/SDS/"/>
    
  </entry>
  
  <entry>
    <title>《Domain Driven Design》</title>
    <link href="https://clsrfish.github.io/2023/03/02/54e349021e30.html"/>
    <id>https://clsrfish.github.io/2023/03/02/54e349021e30.html</id>
    <published>2023-03-02T15:28:30.000Z</published>
    <updated>2023-03-02T15:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年连着刷完了<a target="_blank" rel="noopener" href="https://item.jd.com/11961038.html">《领域驱动设计》</a>、<a target="_blank" rel="noopener" href="https://item.jd.com/11423256.html">《实现领域驱动设计》</a>和<a target="_blank" rel="noopener" href="https://item.jd.com/12447082.html">《领域驱动设计精粹》</a>，碰到一些案例讲解，走马观花就过了。春节前后两三个月（摸鱼太多）二刷《领域驱动设计》，虽然最后两章《大型结构》和《领域驱动设计的综合运用》还是没能体会透彻，但是相比第一遍时的那种朦胧感，对领域驱动设计的理解要清晰得多了。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote><p>A brief introduction to DDD from ChatGPT</p></blockquote><p>Domain-Driven Design (DDD) is a <strong>philosophy</strong> and software development <strong>methodology</strong> that aims to help teams build <em>complex</em> software solutions that closely match the domain of the problem they’re trying to solve. Instead of focusing on architecture, DDD emphasizes domain analysis, modeling, and design.</p><p>In DDD, <strong>the domain model is a central concept that represents the core of the system</strong>. It is a set of well-defined concepts, attributes, and relationships that accurately reflect the business or industry domain the software is meant to solve. A good domain model should provide a common language and understanding for everyone involved in the project, from developers to business stakeholders.</p><p>DDD is highly collaborative and relies heavily on the expertise of domain experts. Developers work closely with domain experts to identify, model, and refine the domain model over time. The use of ubiquitous language is critical to ensure clear communication and understanding of the domain model.</p><p>Some key concepts in DDD include bounded contexts, aggregates, and repositories. Bounded contexts help to define the scope of a domain, while aggregates define transactional boundaries within the domain model. Repositories help to manage the persistence of the domain model.</p><p>DDD is often used in <em>complex</em>, highly transactional systems like those found in finance, logistics, and healthcare. It can help teams build software that’s easier to maintain, understand, and extend over time.</p><p>同一个问题问 ChatGPT 多遍，每遍都会给你不一样的答案，有些回答语句精炼、逻辑清晰，有些则语焉不详、啰里八嗦，就跟本文一样。我还是觉得 ChatGPT 给我的第一个回答最棒，非常适合作为本文的大纲进行展开，可惜手残刷新后就再也没找到了。</p><p>回到这个 brief introduction，在跟 ChatGPT 极限拉扯 N 回之后，发现了个很打动我的词，相信你也看到了，就是”philosophy“，虽然后面的“methodology”也被粗体标识出来了，但相比之下略显生硬。二刷《领域驱动设计》的同时，也在看《毛泽东选集》，期间突然就觉得两本书都在揭示某些哲学思想：实践是检验真理的唯一标准，实事求是，辩证法等。</p><p>我对上面 ChatGPT 的回答不太满意的一点就是，它前后都强调 DDD 常用于“complex”的业务系统或行业领域，会让人觉得 DDD 是一套非常“重”的方案，轻易不敢在项目中实践。但是个人认为 DDD 最核心的是叫人如何认识领域，抽象问题，分离业务面与技术面，将领域知识运用到建模中，这些不管在哪种业务系统或行业领域都是适用。</p><p>好了，废话留着后面再说，进入正题。</p><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>在 DDD 中，领域模型是表达系统的核心概念。后面将讨论到的战术设计，战略设计，都离不开有效建模的领域模型。</p><p>那么要怎么理解“领域模型&#x2F;Domain model”这个词呢？</p><blockquote><p>在太多项目代码里见过 <code>models</code> 文件夹，但是里面存放的基本都是一些 POJO 或 DB schema，用途也是混乱不清，以至于很多人认为模型就是 POJO，就是 DB schema。</p></blockquote><p>一个大家都认可的事实是，软件的核心就是为用户解决某些问题的能力，而这些问题就构成了软件的领域&#x2F;domain，有的人也会说 scope。而模型就是对现实问题有选择的抽象，它对领域中的知识进行有组织地提炼，避免现实问题的复杂性造成信息过载。</p><p>《领域驱动设计》中提到有效建模的几个因素：</p><ol><li>模型和实现绑定。实现与模型脱钩会引入一个额外的翻译过程，开发人员需要不断地将模型翻译成实现，需要将实现翻译成模型并给专家解释。而新加入成员需要阅读大量文档代码才能建立起模型与实现间的映射。</li><li>建立基于模型的语言。开发人员与领域专家的沟通语言，它不是某一方的语言，而是包含了对象、操作、事件甚至组织规则。</li><li>开发蕴含丰富知识的模型。领域对象除了包含必要的数据&#x2F;属性外，还应具有动作，一些强制性业务规则和事件，这些是描述并解决领域问题不可或缺的部分。</li><li>提炼模型。随着项目发展，对领域模型的理解不断深入，新的概念加入，过时的概念被剔除，核心概念愈发凸显，甚至被提取到一个新的模型中进行表达。</li><li>头脑风暴和实验。团队讨论的创造性有助于发现隐藏概念，丰富模型。实验和口头表达则能够帮助检验模型是否清晰，模糊的模型会导致笨拙的表达。</li></ol><p>总的来说，领域建模是一个不断学习，消化知识的过程，而领域模型则需要将这些知识显式地体现出来，高效率的团队需要有意识地累积知识。</p><blockquote><p>关于表达模型的工具&#x2F;形式，其实没有特别的约束，只要能够充分地表达出模型中的概念就可以。</p></blockquote><h2 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h2><p>战略和战术分别表达“做什么”和“怎么做”的两个问题。具体到 DDD，战略设计指复杂的业务下，如何将业务划分成不同的子领域并进行集成；而战术则是在一个领域内，怎么划分和组织代码。</p><p><img src="/img/2023/ddd-building-blocks.png" alt="DDD building blocks"></p><h3 id="表达领域模型"><a href="#表达领域模型" class="headerlink" title="表达领域模型"></a>表达领域模型</h3><p>DDD 使用 <code>Entity</code>、<code>Value Object</code> 和 <code>Service</code> 表达领域模型，注意这里的 <code>Service</code> 不是传统 MVC 里包含领域逻辑的 <code>MVCService</code>（用 MVC 前缀以区别领域模型中的 <code>Service</code>）。</p><p>在传统的 MVC 模式中，model 往往被设计成面向 DB 的，DB schema 成为关注点而不是领域模型的表达；同时，model 被设计成贫血模型，那些本该在 model 中表达的操作，以过程式的方式堆在了 <code>MVCService</code> 里；再者是技术面与业务面的耦合，在表达领域概念的同时还要关心技术细节。从而在传统 MVC 的项目中很容易感受到：</p><ol><li>代码不易理解。一个完整的用户故事需要在 model 和 <code>MVCService</code> 中来回查看，业务代码被技术代码所掩藏，进一步加大难度，稍大一些的项目容易被称为“屎山”。</li><li>模型与实现脱钩。与领域专家的沟通开始困难，新成员在理解代码的同时还要学习一套与领域专家沟通的术语。迭代新功能时容易影响现有业务。</li><li>领域知识散乱。贫血模型对象需要暴露大量属性供 <code>MVCService</code> 完成业务操作，模型对象散布在各处。</li><li>单元测试难度提高。</li></ol><p>在 DDD 中，<code>Enitty</code> 和 <code>Value Object</code> 除了定义必要的属性外，上面提到的 <code>MVCService</code> 中的业务逻辑，都在 <code>Entity</code> 和 <code>Value Object</code> 上实现。这样 <code>Entity</code> 和 <code>Value Object</code> 就不再仅仅是数据容器，而是一个活生生的、有血有肉的对象了。而之前为了业务操作而暴露的属性，现在也可以设为私有了。所有的领域知识集中在一起，并且使用领域模型中的术语来命名类，属性和函数，对象，代码与领域模型关系紧密。这时候可能会惊奇地发现，针对这部分的单元测试居然可以起到一定程度的文档作用，断言规定了执行某个操作后对象应是什么状态。</p><p>再回到 <code>Entity</code> 和 <code>Value Object</code>，这两种对象的之间有什么区别呢？</p><p>《领域驱动设计》这么解释：“一个对象是用来表示某种具有连续性和标识的事物呢，还是用于描述某种状态的属性呢？这是 <code>Entity</code> 和 <code>Value Object</code> 的根本区别。”</p><p>一个 <code>Entity</code> 非常好的例子就是人，一个人不可能被他所具有的属性，比如相貌、身高、体重等唯一地确定出来，随着年岁增长，即使这些外在属性变化，但这个人还是他。所以 <code>Entity</code> 使用标识进行区分并跟踪，常见的手段就是为其分配一个 ID&#x2F;UUID。</p><p>相对地， <code>Value Object</code> 就是那些可以通过属性来唯一区分的对象，单一属性不行就多个属性。并且，因为没有标识，不需要跟踪其生命周期，所以在设计上也比 <code>Entity</code> 要简单。同时，因为只关心 <code>Value Object</code> 的属性，所以 <code>Value Object</code> 需要实现为 immutable。</p><p>一个事物被建模成 <code>Entity</code> 还是 <code>Value Object</code>，取决其是否需要标识，标识重要与否。还是用人举例子，但这次的场景是坐电梯，对于电梯是否超载这个业务规则，我们就不再关心人是谁，而是关心其体重，那么这时将人建模成 <code>Value Object</code> 是个比较好的选择。</p><p>那么 <code>Service</code> 呢？领域模型中有一些不适合由 <code>Entity</code> 或 <code>Value Object</code> 来承担的操作，因为这些操作可能涉及多个 <code>Entity</code> 或 <code>Value Object</code>。<code>Service</code> 就是被设计来处理这种场景的，它强调对象之间的关系。这里以银行转账为例，Account1 向 Account2 进行转账，一般在转账前会对双方账户进行校验，检查有足够资金支取，账户未否被冻结等一系列的业务规则，如果将这样的操作实现在 Account 对象上，那么在处理转账业务时，Account1 除了要处理自己的状态外，还要把手伸到 Account2 的口袋中去，现实中这样的行为是非常别扭的。所以将这类涉及多个对象，不适合放在对象上完成的操作转移到 <code>Service</code> 上，然后用这个操作（动词）给 <code>Service</code> 命名。</p><h4 id="领域对象生命周期"><a href="#领域对象生命周期" class="headerlink" title="领域对象生命周期"></a>领域对象生命周期</h4><div style="background:white"><p><img src="/img/2023/ddd-entity-lifecycle.svg" alt="Entity lifecycle"></p></div><p>领域对象在创建出来后会经历各种不同的状态，直到最终被存档，删除。在管理对象状态时，领域模型会遇到下面两个挑战：</p><ol><li>领域对象在整个生命周期中保证一致性，满足某种业务规则。</li><li>避免对象的创建和重建等生命周期管理的复杂性影响到领域模型。</li></ol><h5 id="Aggregate-x2F-聚合根"><a href="#Aggregate-x2F-聚合根" class="headerlink" title="Aggregate&#x2F;聚合根"></a>Aggregate&#x2F;聚合根</h5><p>大多数业务系统中的对象都具有非常复杂的关联关系，顺着关系链访问对象，会给业务造成混乱。一方面，对象间的这种关联关系属于领域知识，过于暴露会给业务方造成认知负载；另一方面，对象需要满足一定的一致性规则，过分暴露的关系模糊了一致性边界。</p><p>为了解决这个问题，DDD 使用 <code>Aggregate</code> 将一组<strong>关系紧密</strong>的 <code>Entity</code> 和 <code>Value Object</code> 聚集起来，并选择一个 <code>Entity</code> 作为 <code>Aggregate Root</code> 供业务方访问。业务方无法直接访问到除了 <code>Aggregate Root</code> 外的内部对象，需要委托 <code>Aggregate Root</code> 完成操作。<code>Aggregate Root</code> 此时便是充当了边界的作用，在此边界内任何的状态变更都会满足一致性规则要求。</p><p>那么怎么定义这个<strong>关系紧密</strong>呢？自然是通过理解领域。一般来讲，同一个 <code>Aggregate Root</code> 内的对象间满足的需要是强一致性，两种 <code>Aggregate Root</code> 之间可能并不需要时刻保持这种一致性，它们可以通过消息或其它机制实现最终一致性。那么自然的，<code>Aggregate Root</code> 指明了数据库的事务边界，同一个事务内不能同时操作两种 <code>Aggregate Root</code>。</p><p><code>Aggregate Root</code> 引伸出来的一条规则是，业务方通过 <code>Repository</code> 只能查询到 <code>Aggregate Root</code> 而不能直接查询到内部对象。</p><h5 id="Factory-pattern"><a href="#Factory-pattern" class="headerlink" title="Factory pattern"></a>Factory pattern</h5><p>DDD 引入 <code>Factory</code> 来解决 <code>Aggregate Root</code> 创建的问题。</p><p>为什么不用 <code>Aggregate Root</code> 的构造器而要借助 <code>Factory</code> 来完成创建呢？对象装配本身并不属于领域知识的一部分，它是支撑领域的一种技术细节（一些OO语言甚至没有构造器，比如 Golang），所以 <code>Aggregate Root</code> 已经承担复杂领域知识的情况下，再承担自身的装配会让 <code>Aggregate Root</code> 超载。</p><p>显然，<code>Aggregate Root</code> 的装配也不适合交由业务方完成，业务方本来只需要关心如何使用 <code>Aggregate Root</code> ，现在还要负责创建它，这会将复杂性引入到业务方，同时也破坏了 <code>Aggregate Root</code> 的封装性。</p><p>所以创建 <code>Aggregate Root</code> 的职责需要专门设计，即 <code>Factory</code>，它作为支撑领域模型的技术，与 <code>Aggregate Root</code> 同属一个代码层级，同时 <code>Factory</code> 创建出来的 <code>Aggregate Root</code> 必须满足一致性规则，否则需要拒绝创建。</p><h5 id="Repository-pattern"><a href="#Repository-pattern" class="headerlink" title="Repository pattern"></a>Repository pattern</h5><p>对象创建之后知道被删除前，要么处于 Active 状态，要么被存储在数据库或其它持久化工具里。<code>Repository</code> 这个 pattern 在很多领域都有这个概念，目的都是为了隔离具体的存储技术。在 DDD 中，为了避免以数据思维而不是领域思维保存和查询对象，还需要给 <code>Repository</code> 加上一些约束：</p><ul><li>避免随意查询 <code>Aggregate Root</code> 内部对象，这会破坏 <code>Aggregate Root</code> 的封装。</li><li>只为需要全局访问的 <code>Aggregate Root</code> 提供 <code>Repository</code>。</li></ul><p>使用 <code>Repository</code> 有这样一些优点：</p><ul><li>使应用程序和领域技术与持久化技术解耦。</li><li>体现对象的访问设计决策。</li><li>便于替换底层存储和测试。</li></ul><h3 id="Layered-Architecture"><a href="#Layered-Architecture" class="headerlink" title="Layered Architecture"></a>Layered Architecture</h3><p><img src="/img/2023/ddd-layers.png" alt="Layered architecture"></p><p>软件中用于解决领域问题的部分通常只占整个系统中较小的一部分，我们需要将领域部分代码与其它代码区分，避免在纷繁芜杂的系统中迷失了领域。DDD 也采用分层结构来分离关注点，与 MVC 不同的是，DDD 拥有一个饱满的 Domain 层用于表达领域模型：</p><table><thead><tr><th>Layer</th><th>Responsibility</th></tr></thead><tbody><tr><td>User Interface</td><td>负责向用户显示信息和解释用户指令，对于后端服务来说，这里定义了交互协议（比如 REST、RPC 或 Event 等）。</td></tr><tr><td>Application</td><td>负责编排任务，指挥领域层对象完成业务逻辑。这里编排包括开启事务，调用其它微服务以及发布订阅事件等。</td></tr><tr><td>Domain</td><td>负责表达业务概念，业务状态信息以及业务规则。</td></tr><tr><td>Infrastructure</td><td>为上层提供技术支持：为领域层提供持久化支持，为用接口层提供协议转换，为应用层传递消息等。</td></tr></tbody></table><p>下面是一个典型的 DDD 分层架构的项目目录划分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├──interface</span><br><span class="line">│    ├──controller</span><br><span class="line">│    ├──rpc</span><br><span class="line">│    └──function</span><br><span class="line">├──application</span><br><span class="line">│    ├──usecase</span><br><span class="line">│    └──service</span><br><span class="line">├──domain</span><br><span class="line">│    ├──entity</span><br><span class="line">│    ├──valueobject</span><br><span class="line">│    ├──service</span><br><span class="line">│    ├──repository</span><br><span class="line">│    └──event</span><br><span class="line">└──infrastructure</span><br><span class="line">     ├──persistence</span><br><span class="line">     ├──service</span><br><span class="line">     └──repository</span><br></pre></td></tr></table></figure><p><code>interface</code> 定义了以各种协议对外开放的接口，比如 REST、RPC 等，接收用户请求并解析出 <code>application</code> 层所需要的参数。借助框架的帮助，这一层也可以做到访问控制和参数校验。当请求进入 <code>application</code>，<code>application</code> 可能调用 <code>infrastructure</code> 开启事务或发布消息，调用 <code>repository</code> 拿到 <code>domain</code> 层的 <code>Aggregate Root</code> 执行领域逻辑，调用 <code>application service</code> 访问其它微服务，最后再调用 <code>repository</code> 保存 <code>Aggregate Root</code>。</p><p>上面目录结构中还隐藏了一些比较重要的知识点。</p><p>第一个是在 <code>domain</code> 和 <code>infrastructure</code> 中都有一个 <code>repository</code> 目录， 前者是定义了接口，后者则是基于 <code>persistence</code> 的实现。因为 <code>domain</code> 专注于表达领域模型，<code>repository</code> 的实现其实是一个技术问题，所以将实现放到 <code>infrastructure</code> 中是一个合理的决策。</p><p>第二个是，在 <code>application</code>、<code>domain</code>、<code>infrastructure</code> 中都存在一个 <code>service</code> 目录，那么它们之间有什么区别呢？</p><table><thead><tr><th>Layer</th><th>Responsibility</th></tr></thead><tbody><tr><td>application#service</td><td>调用 domain 或 infrastructure 完成功能。</td></tr><tr><td>domain#service</td><td>基于 <code>Entity</code> 和 <code>Value Object</code> 执行某种业务动作。</td></tr><tr><td>infrastructure#service</td><td>纯技术的 service，封装一些功能供上层使用。</td></tr></tbody></table><h3 id="深化领域模型"><a href="#深化领域模型" class="headerlink" title="深化领域模型"></a>深化领域模型</h3><p>领域模型的深化，本质上是知识的积累与沉淀，随着对领域知识的理解加深，我们可以突破模型表面形式，找到模型对象的深层关系，模型中的技术因素进一步被淡化，领域模型的核心概念进一步突出。以物流为例，表面上看是货物在时空上的转移，深层次上其实包含责任的转移。</p><p>为了深化模型，只能不断地学习领域知识，不断地与业务专家交流，建立起对领域的深刻理解。DDD 并没有提供具体的方法论来完成领域模型的深化，毕竟现实问题各不相同。</p><h4 id="Spcification-pattern"><a href="#Spcification-pattern" class="headerlink" title="Spcification pattern"></a>Spcification pattern</h4><p>在执行领域操作前，通常会校验一些业务规则以确保领域操作可以被执行，业务规则通常以各种布尔测试体现，比如判断发票是否过期等等。但是对于复杂的业务规则，除了简单的布尔测试外，还可能由多个规则组合，依赖其它类库、微服务的计算，如果将这部分业务规则实现在 <code>Entity</code> 或 <code>Value Object</code> 中，那么领域对象的基本含义很快就会被复杂规则计算淹没。即使规则不适合作为 <code>Entity</code> 或 <code>Value Object</code> 的职责，但它仍属于领域层。因此，引入一个特殊的 <code>Value Object</code> 对规则进行描述并测试对象是否满足指定的标准，这样的对象称为 <code>Specification</code>。</p><p><code>Specification</code> 的应用场景有：</p><ul><li>验证对象，检查它是否满足某些需求或者是否已经为实现某个目标做好准备。</li><li>从集合中选择一个对象。</li><li>指定创建新对象时必须满足的某种需求。</li></ul><p>这三种场景下，通过 <code>Specification</code> 做到了概念上的统一，简化了设计。</p><h4 id="柔性设计"><a href="#柔性设计" class="headerlink" title="柔性设计"></a>柔性设计</h4><p>柔性设计这个概念是在看书的时候第一次见，很多关于 DDD 的博客中都没有提及它。柔性设计的主要服务对象是开发人员，这里的开发人员包括调用这部分代码的客户开发人员以及将来会修改这部分开发人员，虽然脑海中会有类似的想法，但是书上这么明确提出来，给人的感觉是完全不一样，那一刻就会开发反思实际工作中那些不符合这种思想的做法。软性设计需要让开发人员乐于使用，并且易于做出修改，这样才能突破领域复杂性的限制，一旦领域有了新的变化或对领域有了新的理解，能够快速将这些变化以易于理解方式体现到代码中，并保持代码与领域模型的一致。</p><p>下面是一些可以帮助获得柔性设计的一些 pattern:</p><h5 id="Intention-Revealing-Interfaces"><a href="#Intention-Revealing-Interfaces" class="headerlink" title="Intention-Revealing Interfaces"></a>Intention-Revealing Interfaces</h5><p>在命名类和操作时要描述它们的效果和目的，而不是表露它们是通过何种方式达到目的的。如果开发人员为了使用一个组件而必须要去研究它的实现，那么就失去了封装的价值。避免用文档的方式说明，文档和实际行为之前没有强制绑定关系，拙略的文档或过时的文档反而会误导读者。</p><h5 id="Side-Effect-Free-Function"><a href="#Side-Effect-Free-Function" class="headerlink" title="Side-Effect Free Function"></a>Side-Effect Free Function</h5><p>尽可能将程序逻辑放到函数中，因为函数是指返回结果而不产生副作用的操作。尽量把命令隔离到不返回领域信息的简单操作中。</p><blockquote><p>操作可以宽泛的分为“命令”和“查询”，命令会引起状态变化产生副作用，而查询只是获取数据或者执行计算并拿到结果。</p></blockquote><p>这里要说一下函数和方法的区别，函数是一段执行特定计算功能的程序，可以传递参数和返回计算结果（也可以没有）。方法类似，但是方法需要由一个显式声明的上下文调用，比如面向对象中的 <code>this</code>。一个比较好的例子是 Golang，当在 VSCode 中输入 <code>func</code> 和 <code>meth</code> 时，自动生成的代码是不一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// snippet for func</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snippet for meth</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver <span class="keyword">type</span>)</span></span> method()  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Assertion"><a href="#Assertion" class="headerlink" title="Assertion"></a>Assertion</h5><p>在操作（副作用）之后通过断言描述预期的状态，帮助开发人员更准确地预测对象的行为。对于不支持断言的语言，可以在单元测试中实现。</p><h5 id="Conceptual-Contour"><a href="#Conceptual-Contour" class="headerlink" title="Conceptual Contour"></a>Conceptual Contour</h5><p>随着代码不断适应新的概念或需求，模型中的多个部分可能与领域的某一方面吻合，这时需要重构模型将这个隐藏概念显式地表达出来。当连续重构都只对模型产生小范围改动，这就是模型与领域相吻合的信号。</p><h5 id="Standalone-Class"><a href="#Standalone-Class" class="headerlink" title="Standalone Class"></a>Standalone Class</h5><p>Standalone class 是低耦合的一个极端例子，它强调将对象中所有无关概念剔除，使对象可以独立被理解，使用和测试。我理解并不是说不能有任何依赖，而是尽量减少各种有意义的概念上的依赖，降低认知负担。</p><h5 id="Closure-Of-Operation"><a href="#Closure-Of-Operation" class="headerlink" title="Closure Of Operation"></a>Closure Of Operation</h5><blockquote><p>其实没有太理解这个 pattern 的优点</p></blockquote><p>定义操作时让它的返回值与参数类型相同，如果实现者的状态在计算中被用到，这个实现者实际上也是参数。这种 pattern 可以避免引入新的依赖，始终在同一个概念子集中进行思考。</p><h4 id="通过重构得到深层理解"><a href="#通过重构得到深层理解" class="headerlink" title="通过重构得到深层理解"></a>通过重构得到深层理解</h4><p>DDD 对于重构的观点始终围绕着领域模型的表达。</p><ul><li>即使代码看上去很整洁的时候也可能需要重构，原因是语言没有与领域专家保持一致，或者新需求不能被自然地添加到模型中。</li><li>重构可能来自学习，开发人员通过学习获得了对领域更深刻的理解。</li><li>维持拙劣的设计本身就是一种风险，迁就这种设计也是需要付出代价的。</li><li>借鉴经验，比如《分析模式》。</li></ul><h2 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h2><p>2003 年提出的 DDD 在近几年重新进入人们视野，很大程度上是因为 DDD 对领域的划分与微服务架构设计在本质上都是分解大型系统，使之更易于理解、管理的手段。具体到 DDD 战略设计，其实就是关于模型拆解，子系统集成以及模型精炼的问题。</p><p><img src="/img/2023/ddd-integrality.jpeg" alt="DDD integrity"></p><p>大型系统使用单一领域模型可能遇到的问题：</p><ol><li>协调成本过大。大型系统通常由多个团队一起合作开发，随着团队数量增加，协调成本呈指数级增长。</li><li>为满足所有团队的需求，会导致模型包含负责的设计决策。</li><li>不同团队关注模型概念的不同方面，单一领域模型会导致信息过载。</li><li>团队职责边界模糊，权利和组织管理上的因素也会要求模型分开。</li></ol><p>自然地，大型系统中就会出现多个小模型以支撑整个系统的实现。</p><h3 id="Bounded-Context"><a href="#Bounded-Context" class="headerlink" title="Bounded Context"></a>Bounded Context</h3><p>大型系统中的小模型都有各自针对的，需要解决的问题场景，或者叫 Bounded Context（限界上下文）。这个上下文就是模型中术语具有特定含义而必须要应用的一组条件，脱离这个上下文，模型也就变得毫无意义了。在这个上下文边界内，模型不需要考虑其是不是适用于边界之外的情况。边界的划分，通常是由团队组织结构，软件系统的各个部分用法以及物理实现（代码和数据库 schema）决定的。</p><p>Bounded Context 与子模型是<strong>一对多</strong>的，即一个 Bounded Context 中可能有多个团队在维护多个模型，但一般建议保持一对一的关系以减少不同团队之间的摩擦。</p><h4 id="Continuous-Integration"><a href="#Continuous-Integration" class="headerlink" title="Continuous Integration"></a>Continuous Integration</h4><p>多人同时在同一个 Bounded Context 中工作时，模型可能因为不同人的理解而发生分裂，团队规模越大，分裂可能性越大。通过持续集成将同一个上下文中的变更足够频繁地合并到一起，可以避免模型发生分裂，使所有人对模型都能达成一致共识。</p><h3 id="Context-Map"><a href="#Context-Map" class="headerlink" title="Context Map"></a>Context Map</h3><p>Bounded Context 将系统划分成多个小规模的系统和上下文，最后还要将不同的 Bounded Context 集成构成完整的系统。不同 Bounded Context 集成时，它们的边界可能会各种可能的原因变得模糊，导致 Bounded Context 边界外的概念泄漏到 Context 内，由于同一个术语在不同 Context 下的含义可能大不相同，久而久之当前 Context 变得混乱。</p><p>Context Map 是 Bounded Context 边界上的概念，它描述模型之间的联系点，明确所有的通信需要的转换，并突出任何共享的内容，维护清晰的边界。</p><h4 id="Shared-Kernel"><a href="#Shared-Kernel" class="headerlink" title="Shared Kernel"></a>Shared Kernel</h4><p><img src="/img/2023/ddd-sharedkernel.png" alt="Shared Kernel"></p><p>从领域模型中挑选出两个团队都同意共享的一个子集，同时包括对应的代码实现和数据库设计。这部分内容任何一方不得擅自更改，同时要经常进行集成。Shared Kernel 通过共享减少了两个 Bounded Context 之间的部分重叠，使两个 Context 的集成变得相对容易，因为减少了部分转换工作。</p><p>因为共享部分的更改受到限制，所以只有在两个紧密合作的团队见才比较适合使用 Shared Kernel 方式合作。</p><h4 id="Customer-x2F-Supplier"><a href="#Customer-x2F-Supplier" class="headerlink" title="Customer&#x2F;Supplier"></a>Customer&#x2F;Supplier</h4><p>当两个 Bounded Context 之间存在单向依赖时，两个团队间可能采用 Customer&#x2F;Supplier 这种合作模式。Customer&#x2F;Supplier 在两个团队间建立一种明确的客户&#x2F;供应商关系，上游团队根据下游团队的需求来安排任务，下游团队与上游团队共同开发测试套件，保证上游团队在修改时不必担心破坏下游团队的工作。</p><p>由于上游团队有多个下游团队客户，有些影响力大的下游团队有可能挤压影响力小的下游团队的需求，同时下游团队的需求可能得不到上游团队的及时支持。</p><h4 id="Conformist"><a href="#Conformist" class="headerlink" title="Conformist"></a>Conformist</h4><p>当两个团队具有 Customer&#x2F;Supplier 关系时，上游团队可能没有动力来支持下游团队的需求。这时下游团队有两种选择：</p><ol><li>完全放弃对上游团队的依赖，下游团队走上 Separate Way 的道路。</li><li>如果对上游团队的依赖还具有价值或者管理决策要求，下游团队还有两种做法：<ol><li>上游团队软件设计一般，下游团队仍需开发自己的模型并完成模型映射（Anti-Corruption Layer）。</li><li>上游团队软件设计凑活能用，风格能兼容需求，下游团队则采用 Confirmist 模式。</li></ol></li></ol><p>采用 Conformist 模式可以极大地简化集成。但是由于需要追随上游团队的设计，下游团队的设计受到限制，并且没法得到理想的领域模型。</p><h4 id="Separate-Ways"><a href="#Separate-Ways" class="headerlink" title="Separate Ways"></a>Separate Ways</h4><p>当两个团队间不存在依赖关系或这种关系被消除时可以采用这种模式，这时候两个团队之间也没有集成的问题了。</p><h4 id="Anti-Corruption-Layer"><a href="#Anti-Corruption-Layer" class="headerlink" title="Anti-Corruption Layer"></a>Anti-Corruption Layer</h4><p><img src="/img/2023/ddd-anti-corruption.png" alt="Anti-Corruption Layer"></p><p>Anti-Corruption Layer 是连接两个 Bounded Context 的一种隔离层，这个隔离层内封装了两个 Bounded Context 之间的映射，下游团队根据自己的需求定义 Anti-Corruption Layer 的接口，内部将输入转换后再与上游团队对话。</p><p>Anti-Corruption Layer 的公共接口通常以一组 Service 的形式出现，这些 Service 通常被实现为 Facade、Adapter 和 Translator 的组合（如图所示），其中：</p><ul><li>Facade。对子系统访问的可替换接口，严格按照子系统的领域模型实现。</li><li>Adapter。将调用者请求转换成子系统可理解的请求和将子系统的响应转换成调用者要求的对象。</li><li>Translator。服务于 Adapter，为其完成一些对象、数据的转换工作。</li></ul><h3 id="Core-Domain"><a href="#Core-Domain" class="headerlink" title="Core Domain"></a>Core Domain</h3><p>TODO</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><blockquote><p>建议先看领域驱动设计精粹，非常精悍的一本小书</p></blockquote><p><a target="_blank" rel="noopener" href="https://item.jd.com/12447082.html">《领域驱动设计精粹》</a></p><p><a target="_blank" rel="noopener" href="https://item.jd.com/11961038.html">《领域驱动设计》</a></p><p><a target="_blank" rel="noopener" href="https://item.jd.com/11423256.html">《实现领域驱动设计》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;去年连着刷完了&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://item.jd.com/11961038.html&quot;&gt;《领域驱动设计》&lt;/a&gt;、&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;ht</summary>
      
    
    
    
    
  </entry>
  
</feed>
