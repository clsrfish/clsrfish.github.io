<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LSM-Tree</title>
      <link href="/2023/07/29/a22615e5cdae.html"/>
      <url>/2023/07/29/a22615e5cdae.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/2023/lsm-tree.png" alt="LSM tree"></p><blockquote><p>The Log-Structured Merge-tree (LSM-tree) is a disk-based data structure designed to provide low-cost indexing for a file experiencing a high rate of record inserts (and deletes) over an extended period.</p></blockquote><p>LSM tree 基于“磁盘批量顺序写性能高于随机写”这一理论基础，提供高性能写入能力，代价是牺牲一部分读性能和空间效率。为了弥补读取性能，需要进一步设计，这也是其名字——Log-Structured Merge Tree 的由来。</p><h2 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h2><p>LSM Tree 由存在于内存与磁盘上的部分组成，<code>Memtable</code> 和 <code>SSTable</code>，内存中又可以进一步划分成两个，如上图所示，顶部区域实际包含 <code>Mutable memtable</code> 和 <code>Immutable memtable</code>。</p><p><strong>Mutable memtable</strong>：</p><p>所有操作直接写入 <code>Mutable memtable</code>，数据会按照 key 有序存储。一般基于 <code>Balanced binary tree</code> 实现。</p><p><strong>Immutable memtable</strong>：</p><p>当 <code>Mutable memtable</code> 达到特定大小时，就会转换成 <code>Immutable memtable</code>，然后 flush 到磁盘上。<code>Immutable memtable</code> 只是数据写入磁盘（SSTable）前的临时状态，新数据会写入一个新的 <code>Mutable memtable</code>，避免了新数据写入被转储过程影响。</p><p>**SSTable(Sorted String Table)**：</p><p>有序键值对集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-----------+-----------+-----------+</span><br><span class="line">| key:value | key:value | key:value | key:value |</span><br><span class="line">+-----------+-----------+-----------+-----------+</span><br></pre></td></tr></table></figure><p>根据现实场景，文件内部结构可能不一样，key&#x2F;value 分开存储，建立索引等。</p><blockquote><p>对于 Delete 操作，LSM Tree 通过特殊的 <em>tombstone</em> 标记完成，这一点是比较反直觉的，因为删除操作并没有释放空间。</p></blockquote><p>可以预想，SSTable 数量会不断增长，由此带来两个问题：</p><ol><li>查询操作需要按时间由近至远查询每个 SSTable 直到找到对应 key。</li><li>空间冗余，同一 key 可能存在于多个 SSTable 中，但除了最新的那条，其余都是冗余数据。</li></ol><p>为了缓解这两个问题，就需要适当对 SSTable 做 Compaction。</p><h2 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h2><p>Compaction 的一般规则是将上一层 SSTable 合并进入下一层 SSTable，也就是说磁盘上会有多层 SSTable，越下层 SSTable 存储数据也越旧。</p><p>不同 Compaction 策略在以下三个指标间进行权衡与取舍：</p><ol><li>Read amplification。比如需要从上往下在每层 SSTable 中搜索某个 key。</li><li>Write amplification。比如写入时触发 Compaction 带来额外磁盘 IO。</li><li>Space amplification。比如某个key存在多条冗余记录，compaction 完成前新的 SSTable 和原始 SSTable 同时存在，最坏情况下 compaction 期间数据膨胀为原来的两倍。</li></ol><h3 id="size-tiered-Compaction"><a href="#size-tiered-Compaction" class="headerlink" title="size-tiered Compaction"></a>size-tiered Compaction</h3><p>size-tiered Compaction 策略比较简单，即限制一层中 SSTable 的数量，当数量达到阈值时，将该层 SSTable 合并成为一个更大的 SSTable 存入下一层。</p><p>在这种策略下，某个 key 还是有可能出现在多个 SSTable 中，也即空间放大。</p><h3 id="leveled-Compaction"><a href="#leveled-Compaction" class="headerlink" title="leveled Compaction"></a>leveled Compaction</h3><p>leveled compaction 是 sized-tiered compaction 的改进，大致思路是：对于 L1（第一层 SSTable 为 L0）SSTable 及以上 level，将 size-tiered compaction 中的大 SSTable 拆分成较小且 key range 互不相交的小 SSTable，这种情况下一个 key 不会有多个记录。当发生 L<sub>N</sub> compaction 时，从中挑选若干 SSTable（其 key range 不与其余 SSTable 相交），与 L<sub>N+1</sub> 层 key range 相交的若干 SSTable（必定连续）合并并拆分成新的小 SSTable，如果下层没有匹配 key range 的 SSTable，则 L<sub>N</sub> 层的 SSTable 直接进入 L<sub>N+1</sub> 层。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://www.cs.umb.edu/~poneil/lsmtree.pdf">The Log-Structured Merge-Tree</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=I6jB0nM9SKU">The Secret Sauce Behind NoSQL: LSM Tree</a></p><p><a target="_blank" rel="noopener" href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/">Log Structured Merge Trees</a></p><p><a target="_blank" rel="noopener" href="https://muzinuo.com/archives/lsm-tree-compact">LSM-Tree 的Compact策略</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/437151725">LSM-Tree的存储引擎的Compact机制</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Rate-limiting algorithms</title>
      <link href="/2023/07/17/49937ddf50aa.html"/>
      <url>/2023/07/17/49937ddf50aa.html</url>
      
        <content type="html"><![CDATA[<h2 id="Fixed-window"><a href="#Fixed-window" class="headerlink" title="Fixed window"></a>Fixed window</h2><p>固定窗口算法又叫计数法，在固定时间窗口里记录请求次数，当计数达到阈值时，拒绝请求。当前时间窗口结束后，重置计数器。</p><p>这种算法到优点是简单易实现。缺点是可能存流量尖刺，即请求集中在两个时间窗口交界处。</p><h2 id="Sliding-window"><a href="#Sliding-window" class="headerlink" title="Sliding window"></a>Sliding window</h2><p>滑动窗口算法是固定窗口算法的改进版，在固定窗口的基础上又划分若干子窗口，每个字窗口单独计数，每次只往前移动一个子窗口。相比固定窗口，随着子窗口数量增加，其限流计算更加准确。</p><p>不过这种方式也只是缓解了固定窗口算法的缺点，并不能彻底解决。</p><h2 id="Sliding-log"><a href="#Sliding-log" class="headerlink" title="Sliding log"></a>Sliding log</h2><p>滑动日志算法会记录每个请求的时间戳，然后计算最近一个时间窗口内的请求数量，如果达到上限，则请求拒绝。</p><p>这种算法的优点是限流精确，缺点也很明显，因为要在内存中记录每一条请求的时间戳，会占用较多内存。</p><h2 id="Leaky-bucket"><a href="#Leaky-bucket" class="headerlink" title="Leaky bucket"></a>Leaky bucket</h2><p>漏桶算法会维护一个单端队列，从请求在尾部排队，以固定速率从队列头部取出请求进行处理，队列长度达到上限时拒绝服务。因这种模型就像一个水桶，底部以固定流速漏水，所以称为漏桶算法。</p><p>这种算法能够对突发流量进行整形并以恒定速率进行处理，保证系统的稳定运行。缺点是，它不能很好处理流量波动的场景，当流量短时间少量增加时无法提供更快的处理速度。</p><h2 id="Token-bucket"><a href="#Token-bucket" class="headerlink" title="Token bucket"></a>Token bucket</h2><p>令牌桶和漏桶算法虽然都有桶，但是处理的角度确不太一样，漏桶桶里装的是请求，而令牌桶内装的是server的处理能力。当请求到来时，只有桶内有足够令牌时，才会消耗令牌并处理请求。桶内令牌以固定速率进行补充，直到达到上限。</p><p>通过调整令牌生成速率和桶大小，可以灵活应对流量波动。缺点是实现相对复杂。</p><h2 id="Distributed-limiter"><a href="#Distributed-limiter" class="headerlink" title="Distributed limiter"></a>Distributed limiter</h2><p>前面的算法都是在本地维护一个 limiter，不能跨 server instance 进行流量控制。当需要支持分布式流量控制时，可以使用 Redis 保存 limiter。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">Sentinel</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Consistent hashing</title>
      <link href="/2023/07/16/44c822c98a72.html"/>
      <url>/2023/07/16/44c822c98a72.html</url>
      
        <content type="html"><![CDATA[<p>一般大型系统中，数据通常分布在多台机器上，并且为了稳定的性能表现，数据还需要均匀分布。</p><h2 id="初步的做法"><a href="#初步的做法" class="headerlink" title="初步的做法"></a>初步的做法</h2><p><img src="/img/2023/consistent-hash-simple.png" alt="simple"></p><p>首先计算 <code>hash(object_key)</code>，然后对 <code>numbers_of_servers</code> 取模得到目标 server。</p><p>这种方式的问题核心是，<code>numbers_of_servers</code> 在 server 下线或新 server 加入时会发生变化，从而 <code>object_key</code> 的计算结果也因此发生变化。</p><h2 id="hash-环"><a href="#hash-环" class="headerlink" title="hash 环"></a>hash 环</h2><p><img src="/img/2023/consistent-hash-ring.png" alt="ring"></p><p>既然 <code>numbers_of_servers</code> 是一个不稳定因素，那么就需要将其替换成稳定的因素。</p><p>这里的做法是，对 <code>server_name</code> 或 <code>server_ip</code> 应用相同的 hash 函数，这时得到了 <code>v_object</code> 和 <code>v_server</code>。将 hash 函数的取值区间首位相连得到一个环， 然后根据 <code>v_object</code> 和 <code>v_server</code> 环上的位置，为 <code>object</code> 选择对应的 <code>server</code>。这里的规则一般是，按照顺时针方向搜索第一个 <code>server</code>。</p><p>理想情况下，现有节点下线或新节点加入都将不会导致所有 <code>object_key</code> 的重新分配。</p><p>但是现实中，数据可能不是完全均匀分布，也就是不同节点的上下线带来的影响也是不稳定的，无法预测的。比方说，两台机器，80%的数据分布在机器A，20%的数据分布在机器B，机器B下线将导致机器A负载变成原来5倍。</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p><img src="/img/2023/consistent-hash-virtual-nodes.png" alt="virtual nodes"></p><p>为了缓解数据在 server 上不均匀分布带来的影响，引入虚拟节点，使一个 server 在环上出现多次，即将 <code>hash(server_name)</code> 替换成 <code>hash(server_name#N)</code>，<code>server_name#N</code> 表示虚拟节点。</p><p>这样，某台机器下线带来的影响将由其它节点共同承担，保证了稳定的性能。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consistent_hashing">Consistent hashing wikipedia</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=UF9Iqmg94tk">Consistent Hashing</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bloom filter</title>
      <link href="/2023/07/15/f74286649fc7.html"/>
      <url>/2023/07/15/f74286649fc7.html</url>
      
        <content type="html"><![CDATA[<p>Bloom filter 是用来回答“某元素是否在集合中”这个问题的，答案可能是“Firm no”或“Probably yes”，但是 Bloom filter 相比 hash table 占用内存更少，空间效率更高。也就是说，Bloom filter 通过牺牲准确性交换空间。Bloom filter 主要用在需要减少访问速度更慢的更低一级存储（或数据源）次数的场景，比如优化内存穿透。</p><h2 id="Bloom-filter-如何工作"><a href="#Bloom-filter-如何工作" class="headerlink" title="Bloom filter 如何工作"></a>Bloom filter 如何工作</h2><p>Bloom filter 由 m 个比特的字节数组和 k 个 hash 函数组成。当一个元素被添加到 filter 中时，会先调用 k 个 hash 函数计算得到 k 个整数，将字节数组中对应 bit 置为 1。当查询时，如果对应 bit 全部为 1，则元素可能在集合中（hash 冲突）；如果任一位置 bit 为 0，则元素一定不在集合中。</p><p><img src="/img/2023/bloomfilter_bukets.png" alt="bukets"></p><p>使用多少个 hash 函数取决于期望的错误率是多少，m 大小则与 k 和集合规模成正比。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter wikipedia</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=V3pzxngeLqw">Bloom Filter</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cache problems</title>
      <link href="/2023/07/12/524fd56f9760.html"/>
      <url>/2023/07/12/524fd56f9760.html</url>
      
        <content type="html"><![CDATA[<h2 id="缓存穿透（cache-penetration）"><a href="#缓存穿透（cache-penetration）" class="headerlink" title="缓存穿透（cache penetration）"></a>缓存穿透（cache penetration）</h2><p>缓存穿透指既不存在缓存也不存在于数据库的数据被访问，所有的查询请求都直接打到数据库。这种数据可能被恶意请求，对数据库造成压力。</p><p>Solution：</p><ol><li>对请求进行初步检查，过滤掉显然非法的访问。</li><li>在缓存写入 empty 数据，并设置一个较短的过期时间。</li><li>使用 Bloom filter。</li></ol><h2 id="缓存击穿（cache-breakdown）"><a href="#缓存击穿（cache-breakdown）" class="headerlink" title="缓存击穿（cache breakdown）"></a>缓存击穿（cache breakdown）</h2><p>缓存击穿指某条热点数据不在缓存中，同时有大量的请求访问该数据，所有的请求将打到数据库。</p><p>Solution：</p><ol><li>热点数据永不过期，同时使用后台任务主动更新缓存，而不是被动写入缓存。</li><li>使用互斥锁，当缓存不存在时，只允许一个请求查询数据，其它未获取到锁的请求将挂起直到缓存ready。为避免过多挂起请求，挂起的请求到一定数量后将直接返回失败响应。</li></ol><h2 id="缓存雪崩（cache-avalanche）"><a href="#缓存雪崩（cache-avalanche）" class="headerlink" title="缓存雪崩（cache avalanche）"></a>缓存雪崩（cache avalanche）</h2><p>缓存雪崩指短时间内大批量缓存失效或者缓存服务不可用，请求压力直接来到数据库。通常同样的过期时间可能引起类似的问题。</p><p>Solution：</p><ol><li>为缓存过期时间加上一个随机的偏移量。</li><li>如果是热点数据，在服务启动时就主动将数据加载进缓存，同时不设置过期时间。</li><li>设置 backup 缓存服务提高缓存可用性。</li><li>对数据库访问限流，避免大量请求将数据库击溃。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Distributed Locks with Redis</title>
      <link href="/2023/06/12/cbeb3acfef26.html"/>
      <url>/2023/06/12/cbeb3acfef26.html</url>
      
        <content type="html"><![CDATA[<h2 id="分布式锁原则"><a href="#分布式锁原则" class="headerlink" title="分布式锁原则"></a>分布式锁原则</h2><ul><li>安全性：任意时刻，只有一个客户端能持有锁，保证临界资源的安全访问。</li><li>可用性：无死锁，锁总是能够在某一时刻被释放，即使持有锁的客户端未释放锁便意外结束。</li><li>容错性：只要集群中大多数节点存活，客户端就能正常加锁释放锁。</li></ul><h2 id="Redis-based-分布式锁"><a href="#Redis-based-分布式锁" class="headerlink" title="Redis-based 分布式锁"></a>Redis-based 分布式锁</h2><blockquote><p>到 Redlock 之前都基于单实例 redis 实现。</p></blockquote><h3 id="SETNX-EXPIRE"><a href="#SETNX-EXPIRE" class="headerlink" title="SETNX + EXPIRE"></a>SETNX + EXPIRE</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock_key = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">if</span> redis.setnx(lock_key, lock_value) == <span class="number">1</span>:</span><br><span class="line">  redis.expire(lock_key, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># process</span></span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    redis.<span class="keyword">del</span>(lock_key)</span><br></pre></td></tr></table></figure><p><code>setnx</code> 和 <code>expire</code> 不是原子操作，如果 <code>setnx</code> 后正要 <code>expire</code> 时客户端进程 crash 或者 Redis 重启，锁将无法得到释放。</p><h3 id="SETNX-value-x3D-datetime"><a href="#SETNX-value-x3D-datetime" class="headerlink" title="SETNX + value&#x3D;datetime"></a>SETNX + value&#x3D;datetime</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lock_key = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">expiration = datetime.now() + <span class="number">1000</span></span><br><span class="line"><span class="keyword">if</span> redis.setnx(lock_key, expiration) == <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  current_expiration = redis.get(lock_key)</span><br><span class="line">  <span class="keyword">if</span> current_expiration &lt; datetime.now():</span><br><span class="line">    old_expiration = redis.getset(lock_key, expiration)</span><br><span class="line">    <span class="keyword">return</span> current_expiration == old_expiration</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>现在获取锁操作成为了一个原子操作，但是这种方式存在以下问题：</p><ul><li>各个客户端时钟必须保持同步</li><li>锁过期时多个客户端同时请求锁，可能出现一个客户端获取成功，但是过期时间被其它客户端覆盖</li></ul><h3 id="SET-EX-PX-NX"><a href="#SET-EX-PX-NX" class="headerlink" title="SET EX PX NX"></a>SET EX PX NX</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock_key = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">if</span> redis.<span class="built_in">set</span>(lock_key, lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="string">&quot;100s&quot;</span>) == <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do somthing</span></span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    redis.<span class="keyword">del</span>(lock_key)</span><br></pre></td></tr></table></figure><p>这种方式问题在于，锁可能被其它客户端释放。</p><h3 id="SET-EX-PX-NX-unique-value"><a href="#SET-EX-PX-NX-unique-value" class="headerlink" title="SET EX PX NX + unique value"></a>SET EX PX NX + unique value</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock_key = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">if</span> redis.<span class="built_in">set</span>(lock_key, random_lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="string">&quot;100s&quot;</span>) == <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do somthing</span></span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> redis.get(lock_key) == random_lock_value:</span><br><span class="line">      redis.<span class="keyword">del</span>(lock_key)</span><br></pre></td></tr></table></figure><p>锁的释放不是原子操作，在并发环境下还是可能被其它客户端释放锁。</p><h3 id="Lua-script"><a href="#Lua-script" class="headerlink" title="Lua script"></a>Lua script</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>通过 Lua 脚本组合多个操作，实现原子化操作。</p><h3 id="Extending-lock"><a href="#Extending-lock" class="headerlink" title="Extending lock"></a>Extending lock</h3><p>当获取锁成功后，为锁持有线程开启一个守护线程，定时检测锁并延长锁的 TTL。</p><p>到这里基本上解决了安全性和可用性。</p><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p>以上实现方式在单实例情况下够用了，如果想实现更高的容错性，就需要引入多实例的分布式实现。</p><p>N 个独立的实例（无 replica）。</p><p>客户端按照如下步骤获取锁：</p><ol><li>获取当前时间戳（initia timestamp）。</li><li>使用相同的 key 和 random value 顺序地向 N 个 Redis 实例获取锁，获取锁的超时时间比锁的生存时间小很多，比如超时时间是 5~50ms，锁生存时间是 10s。</li><li>只有当成功获取到 <em>N&#x2F;2 + 1</em> 个锁，并且总 elapsed time 小于锁的生存时间才认为成功获取到了锁。</li><li>成功获取到锁后，锁的有效时间 &#x3D; initial validity time - elapsed time。</li><li>如果客户端未能成功获取到锁，它需要释放已经获取到的部分锁。</li></ol><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://redis.io/docs/manual/patterns/distributed-locks/">Distributed Locks with Redis</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor pattern</title>
      <link href="/2023/06/05/ff306b2184fc.html"/>
      <url>/2023/06/05/ff306b2184fc.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/2023/multithreadloggingserver.png" alt="Multi-threaded Logging Server"></p><p>早期服务端程序处理用户请求时，会为每一个新连接创建线程处理请求，随着并发量越来越高，“thread-per-connection” 这种模式的弊端开始显现。一来线程创建本身有开销，二来上下文切换也会带来额外开销。引入线程池可以一定程度上缓解，但更深层次的问题开始浮现，连接建立（<code>accept</code>）后通常不能马上读取到client的请求数据（<code>recv</code>），也就是说线程池内线程处于挂起状态。</p><p>一个直观的想法就是，连接建立后<strong>直到有数据可读时</strong>才开启线程进行处理，避免线程挂起。</p><h2 id="单线程-Reactor"><a href="#单线程-Reactor" class="headerlink" title="单线程 Reactor"></a>单线程 Reactor</h2><p><img src="/img/2023/reactor_uml.png" alt="Reactor UML"></p><ul><li><code>Synchronous Event Demultiplexer</code>: 指代各种多路复用机制。</li><li><code>Handle</code>: 文件描述符或句柄。</li><li><code>Event Handler</code>: 处理 <code>Handle</code> 的上的各种事件，比如 <code>READ</code>, <code>WRITE</code>。</li><li><code>Initiation Dispatcher</code>: 核心类，维护一个基于 <code>Synchronous Event Demultiplexer</code> 的事件循环监听 <code>Handle</code> 各种事件并分发给 <code>Event Handler</code> 进行处理。</li></ul><p><img src="/img/2023/reactor_connect.png" alt="client connect"></p><p><code>Logging Acceptor</code> 是 <code>Event Handler</code> 一个实现类，专门处理 socket 上的 READ 事件，即客户端连接建立，大致流程：</p><ol><li>将 <code>Logging Acceptor</code> 注册至 <code>Initiation Dispatcher</code>。</li><li><code>Initiation Dispatcher</code> 启动事件循环。</li><li><code>Initiation Dispatcher</code> 通过 <code>select</code> 等待客户端发起 <code>connect</code>。</li><li>客户端发起 <code>connect</code>。</li><li><code>Initiation Dispatcher</code> 从 <code>select</code> 返回并将连接建立事件交由 <code>Logging Acceptor</code> 处理。</li><li><code>Logging Acceptor</code> 调用 <code>accept</code> 获取连接。</li><li><code>Logging Acceptor</code> 为了连接创建一个 <code>Logging Handler</code> </li><li><code>Logging Acceptor</code> 将新创建的 <code>Logging Handler</code> 注册到 <code>Initiation Dispatcher</code> 的事件循环中，开始新一轮的事件等待直到客户端发送数据（<code>send</code>）。</li></ol><p><img src="/img/2023/reactor_send.png" alt="client send"></p><p>当客户端开始发送数据，大致流程：</p><ol><li>客户端发送数据。</li><li><code>Initiation Dispatcher</code> 从 <code>select</code> 返回并将发生 READ 事件的连接交给对应 <code>Logging Handler</code> 处理。</li><li><code>Logging Handler</code> 调用 <code>recv</code> 读取客户端数据。</li><li><code>Logging Handler</code> 处理数据（注意这里的 <code>write</code> 在论文里是用作把客户端数据写入存储用的）。</li><li>回到 <code>Initiation Dispatcher</code> 处理下一个事件或进入下一轮事件循环。</li></ol><p>上面这两个过程基本就是 Reactor pattern 的核心流程了，回消息给客户端的流程类似，<code>Logging Handler</code> 处理完后再注册一个 WRITE 事件的监听，然后再写入数据。整个流程都在一个线程内工作，没有上下文切换。</p><p>Reactor pattern 除了使用多路复用外，还用到了非阻塞IO。设想 <code>Logging Handler</code> 一次事件响应中没能读到一个完整请求的数据，那么就需要立即返回等待下一次事件，而不是阻塞在 <code>recv</code> 上。</p><p>下面是示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EventType</span> &#123;</span><br><span class="line">    CONNECT,</span><br><span class="line">    READ,</span><br><span class="line">    WRITE,</span><br><span class="line">    CLOSE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventHandler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventHandler</span>(<span class="type">const</span> <span class="type">int</span> fd) : <span class="built_in">fd</span>(fd) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventHandler</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(EventType event)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InitiationDispatcher</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_EVENTS = <span class="number">16</span>;</span><br><span class="line">    <span class="function">EventHandler *<span class="title">get_handler</span><span class="params">(epoll_event *ev)</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InitiationDispatcher</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">InitiationDispatcher</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_handler</span><span class="params">(<span class="type">const</span> EventHandler* handler, EventType et)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_handler</span><span class="params">(<span class="type">const</span> EventHandler* handler)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_events</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">        epoll_event events[MAX_EVENTS];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// update epfd instance</span></span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, <span class="comment">/*fd*/</span>, <span class="comment">/*ev*/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> nevents = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nevents; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> ev = events[i];</span><br><span class="line">                <span class="keyword">if</span> (<span class="comment">/*is CONNECT*/</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> logging_acceptor = <span class="built_in">get_handler</span>(&amp;ev);</span><br><span class="line">                    logging_acceptor-&gt;<span class="built_in">accept</span>(EventType::CONNECT);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/*is READ*/</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> logging_handler = <span class="built_in">get_handler</span>(&amp;ev);</span><br><span class="line">                    logging_handler-&gt;<span class="built_in">accept</span>(EventType::READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/*is WRITE*/</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> logging_handler = <span class="built_in">get_handler</span>(&amp;ev);</span><br><span class="line">                    logging_handler-&gt;<span class="built_in">accept</span>(EventType::WRITE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* else */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingHandler</span> : <span class="keyword">public</span> EventHandler &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    InitiationDispatcher* dispatcher;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LoggingHandler</span>(<span class="type">const</span> <span class="type">int</span> fd, InitiationDispatcher* dispatcher) : <span class="built_in">EventHandler</span>(fd), <span class="built_in">dispatcher</span>(dispatcher) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">LoggingHandler</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(EventType event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event == EventType::READ) &#123;</span><br><span class="line">            <span class="type">int</span> size = <span class="built_in">read</span>(<span class="keyword">this</span>-&gt;fd, <span class="comment">/*buf*/</span>, <span class="comment">/*buf_size*/</span>)</span><br><span class="line">            <span class="keyword">if</span> (size == EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* process */</span></span><br><span class="line">            <span class="type">int</span> written = <span class="built_in">write</span>(<span class="keyword">this</span>-&gt;fd,  <span class="comment">/*buf*/</span>, <span class="comment">/*data_size*/</span>);</span><br><span class="line">            <span class="keyword">if</span> (written == EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;dispatcher-&gt;<span class="built_in">register_handler</span>(<span class="keyword">this</span>, EventType::WRITE);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == EventType::WRITE) &#123;</span><br><span class="line">            <span class="comment">/*continue writing*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingAcceptor</span> : <span class="keyword">public</span> EventHandler &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    InitiationDispatcher* dispatcher;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LoggingAcceptor</span>(<span class="type">const</span> <span class="type">int</span> fd, InitiationDispatcher* dispatcher): <span class="built_in">EventHandler</span>(fd), <span class="built_in">dispatcher</span>(dispatcher) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">LoggingAcceptor</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(EventType event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> conn_fd = <span class="built_in">accept4</span>(<span class="keyword">this</span>-&gt;fd, <span class="comment">/*addr*/</span>, <span class="comment">/*addr_len*/</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> handler = <span class="keyword">new</span> <span class="built_in">LoggingHandler</span>(conn_fd, <span class="keyword">this</span>-&gt;dispatcher);</span><br><span class="line">        <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">        <span class="keyword">this</span>-&gt;dispatcher-&gt;<span class="built_in">register_handler</span>(handler, EventType::READ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> socket_fd = <span class="built_in">socket</span>(<span class="comment">/* args */</span>);</span><br><span class="line">    <span class="built_in">listen</span>(socket_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> dispatcher = <span class="keyword">new</span> <span class="built_in">InitiationDispatcher</span>();</span><br><span class="line">    <span class="keyword">auto</span> acceptor = <span class="keyword">new</span> <span class="built_in">LoggingAcceptor</span>(socket_fd, dispatcher);</span><br><span class="line">    dispatcher-&gt;<span class="built_in">register_handler</span>(acceptor, EventType::CONNECT);</span><br><span class="line">    dispatcher-&gt;<span class="built_in">handle_events</span>();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程-Reactor"><a href="#多线程-Reactor" class="headerlink" title="多线程 Reactor"></a>多线程 Reactor</h2><p>单线程 Reactor 中所有的操作在单个线程中完成，如果某个请求处理非常耗时，将导致其它请求无法处理，无法建立新连接。所以就可以将请求处理的逻辑交由线程池进行处理。</p><h2 id="多线程-Multi-Reactor"><a href="#多线程-Multi-Reactor" class="headerlink" title="多线程 Multi-Reactor"></a>多线程 Multi-Reactor</h2><p>不管单线程还是多线程 Reactor，所有的文件描述符&#x2F;句柄都在同一个事件循环里处理，也就无法同一时间处理大量新连接建立和读写事件。所以可以将两种不同的文件描述符分别在不同的事件循环里处理，交由不同线程处理，提高吞吐量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InitiationDispatcher</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;InitiationDispatcher*&gt; sub_dispathcers;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>root <code>InitiationDispatcher</code> 只负责建立新连接建立，然后已建立的连接则交给 <code>sub_dispatchers</code>（RR）处理，每个 <code>sub_dispacther</code> 都会创建线程开启事件循环。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="http://www.kegel.com/c10k.html">The C10K problem</a></p><p><a target="_blank" rel="noopener" href="https://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf">reactor</a></p><p><a target="_blank" rel="noopener" href="https://nicky-chin.cn/2020/06/11/net-nio-netty">nio netty</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> I/O </tag>
            
            <tag> Reactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O Multiplexing</title>
      <link href="/2023/06/03/b735be0f5723.html"/>
      <url>/2023/06/03/b735be0f5723.html</url>
      
        <content type="html"><![CDATA[<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><code>select</code> 允许程序同时监听多个文件描述符，直到一个或多个文件描述符变为<strong>ready</strong>状态（可读、可写、异常），最多支持同时监听 <code>FD_SETSIZE(default 1024 on Linux)</code> 个文件描述符。当 <code>select</code> 返回时，传入的三个 <code>fd_set</code> 将被（in-place）修改，用于标识那些<strong>ready</strong>的文件描述符，也就是说，每次调用 <code>select</code> 都需要重新初始化 <code>fd_set</code> 并拷贝至 Kernel space，当监听文件描述符数量多时，拷贝开销也是相当可观的。<code>FD_SETSIZE</code> 的限制是由于文件描述符在 <code>fd_set</code> 中以数组形式保存。</p><h3 id="select-使用示例"><a href="#select-使用示例" class="headerlink" title="select 使用示例"></a>select 使用示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// initialize fd_set</span></span><br><span class="line">  fd_set rfds;</span><br><span class="line">  FD_ZERO(&amp;rfds);</span><br><span class="line">  FD_SET(<span class="number">0</span>, &amp;rfds); <span class="comment">// stdin</span></span><br><span class="line">  <span class="comment">// timeout</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">  tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> nfds = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> retval = select(nfds, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">  <span class="keyword">if</span> (retval == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">    <span class="comment">// retval fds ready</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; nfds; n++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(fds[n], &amp;rfds)) &#123;</span><br><span class="line">        <span class="comment">// perform I/O operation</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// no fd ready</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h2><p><code>poll</code> 与 <code>select</code> 类似，只是针对 <code>select</code> 文件描述符数量限制和每次都需要 reinitialize <code>fd_set</code> 进行了改进，不过每次调用 <code>poll</code> 还是需要拷贝文件描述符至内核空间。在 <code>poll</code> 实现中，文件描述符在以链表形式管理，所以没有了数量限制。</p><p><code>pollfd</code> 则解决了 <code>select</code> 每次调用都需要初始化 <code>fd_set</code> 的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">  <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">  <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="poll-使用示例"><a href="#poll-使用示例" class="headerlink" title="poll 使用示例"></a>poll 使用示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* poll_input.c</span></span><br><span class="line"><span class="comment">Licensed under GNU General Public License v2 or later.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> nfds = argc - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> num_open_fds = nfds;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">pfds</span> =</span> <span class="built_in">calloc</span>(nfds, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nfds; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    pfds[j].fd = open(argv[j + <span class="number">1</span>], O_RDONLY);</span><br><span class="line">    pfds[j].events = POLLIN; <span class="comment">// set requested events to be monitored</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (num_open_fds &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> ready = poll(pfds, nfds, <span class="number">-1</span>); <span class="comment">// block until an event occurs </span></span><br><span class="line">    <span class="keyword">if</span> (ready == <span class="number">-1</span>)</span><br><span class="line">      errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nfds; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (pfds[j].revents == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pfds[j].revents &amp; POLLIN) &#123;</span><br><span class="line">        <span class="comment">// perform I/O operation</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pfds[j].fd);</span><br><span class="line">        num_open_fds--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><p>从 <code>select</code> 到 <code>poll</code>，已经解决了数量限制、参数重新初始化的问题，但是还有两个问题没有解决，一是需要每次都要拷贝完整文件描述符到内核空间，二是需要遍历所有文件描述符执行 I&#x2F;O 操作。<br><code>epoll</code> 通过在内核空间维护一个 epoll instance 解决这两个问题，可以理解为一个包含 <code>interest</code> 和 <code>ready</code> 两个集合的数据结构，前者表示需要监听的文件描述符，后者则记录了进入 <code>ready</code> 状态的文件描述符。这样用户程序就可以通过 epoll instance 修改 <code>interest</code> 动态调整需要监听的文件描述符了。</p><h3 id="epoll-使用示例"><a href="#epoll-使用示例" class="headerlink" title="epoll 使用示例"></a>epoll 使用示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> listen_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> epollfd = epoll_create(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// monitor socket fd</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">  ev.events = EPOLLIN;</span><br><span class="line">  ev.data.fd = listen_sock;</span><br><span class="line">  epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev)</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; nfds; ++n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (events[n].data.fd == listen_sock) &#123;</span><br><span class="line">        <span class="comment">// register connection to the epoll instance</span></span><br><span class="line">        <span class="type">int</span> conn_sock = accept(listen_sock, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">        ev.events = EPOLLIN;</span><br><span class="line">        ev.data.fd = conn_sock;</span><br><span class="line">        epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &amp;ev)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// connection ready</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Edge-triggered-amp-Level-triggered"><a href="#Edge-triggered-amp-Level-triggered" class="headerlink" title="Edge-triggered &amp; Level-triggered"></a>Edge-triggered &amp; Level-triggered</h3><p>这两个其实是数字电路里面的术语，可以参考<a href="#key-takeaways">Key takeaways</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1          +----------+          +----------+          +----------+</span><br><span class="line">           |          |          |          |          |          |</span><br><span class="line">           |          |          |          |          |          |</span><br><span class="line">           |          |          |          |          |          |</span><br><span class="line">0----------+          +----------+          +----------+          +----------</span><br></pre></td></tr></table></figure><p>Edge-triggered 监听的是竖线表示的状态变化，Level-triggered 监听的是水平线表示的状态。</p><p>举例来说，当一个文件描述符从 not read ready（0） 变为 read ready（1） 时，不论 Edge-triggered 还是 Level-triggered，都会通知可读事件；如果应用程序只读了一半数据，或者压根没读取，那该文件描述符的状态还是 read ready；下一次调用 <code>epoll_wait</code> 时，Edge-triggered 因为没有状态变化不会再次通知，Level-triggered 则检测到仍是可读状态，还会继续通知。</p><p>默认以 Level-triggered 方式监听文件描述符，可使用 <code>ev.events = EPOLLIN | EPOLLET</code> 调整为 Edge-triggered 模式。由于 Edge-triggered 不会再次通知可读文件描述符，所以需要用户程序自行维护好文件描述符的可读状态（EGAIN）。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw"></a></p><p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/edge-triggering-and-level-triggering">edge-triggering and level-triggering</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache pattern</title>
      <link href="/2023/05/29/8154982c759c.html"/>
      <url>/2023/05/29/8154982c759c.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Cache-aside"><a href="#1-Cache-aside" class="headerlink" title="1. Cache-aside"></a>1. Cache-aside</h2><p><img src="/img/2023/cache-aside.png" alt="cache-aside"></p><p>这是最常用的 pattern，实现简单也足够灵活，系统能够承受一定程度的 cache failure。</p><h3 id="1-1-Pros"><a href="#1-1-Pros" class="headerlink" title="1.1. Pros"></a>1.1. Pros</h3><ul><li>简单灵活。</li></ul><h3 id="1-2-Cons"><a href="#1-2-Cons" class="headerlink" title="1.2. Cons"></a>1.2. Cons</h3><ul><li>使用方（Application）需管理缓存与下一级存储。</li><li>写请求有可能造成缓存与下一级存储不一致，通过<strong>写数据库后删缓存</strong>可以降低不一致的可能性，根据系统要求可以再配合 TTL、异步任务甚至是分布式事务。</li></ul><h2 id="2-Read-through"><a href="#2-Read-through" class="headerlink" title="2. Read-through"></a>2. Read-through</h2><p><img src="/img/2023/read-through.png" alt="read-through"></p><p>相比较 <strong>Cache-aside</strong>，<strong>Read-through</strong> 为使用方管理了缓存与第一级存储，使用更加方便，表现上就像是一个自带缓存的存储接口。</p><h3 id="2-1-Pros"><a href="#2-1-Pros" class="headerlink" title="2.1. Pros"></a>2.1. Pros</h3><ul><li>接口简单，使用方便。</li></ul><h3 id="2-2-Cons"><a href="#2-2-Cons" class="headerlink" title="2.2. Cons"></a>2.2. Cons</h3><ul><li>灵活性相比 <strong>Cache-aside</strong> 低一些。</li></ul><h2 id="3-Write-through"><a href="#3-Write-through" class="headerlink" title="3. Write-through"></a>3. Write-through</h2><p><img src="/img/2023/write-through.png" alt="write-through"></p><p>结构与 <strong>Read-through</strong> 一样，提供简单的接口。写入缓存后同步写入下一级存储，整个写操作完成，适用写少的情况。</p><h3 id="3-1-Pros"><a href="#3-1-Pros" class="headerlink" title="3.1. Pros"></a>3.1. Pros</h3><ul><li>接口简单，使用方便。</li></ul><h3 id="3-2-Cons"><a href="#3-2-Cons" class="headerlink" title="3.2. Cons"></a>3.2. Cons</h3><ul><li>写操作延迟稍高，除了写库外，还有一次额外写缓存。</li></ul><h2 id="4-Write-behind"><a href="#4-Write-behind" class="headerlink" title="4. Write-behind"></a>4. Write-behind</h2><p><img src="/img/2023/write-back.png" alt="write-back"></p><p>与 <strong>Write-through</strong> 类似，不过写库操作变为异步。</p><h3 id="4-1-Pros"><a href="#4-1-Pros" class="headerlink" title="4.1. Pros"></a>4.1. Pros</h3><ul><li>写性能大大提高。</li></ul><h3 id="4-2-Cons"><a href="#4-2-Cons" class="headerlink" title="4.2. Cons"></a>4.2. Cons</h3><ul><li>数据由丢失可能。</li><li>实现复杂。</li></ul><h2 id="5-Key-takeaways"><a href="#5-Key-takeaways" class="headerlink" title="5. Key takeaways"></a>5. Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p><p><a target="_blank" rel="noopener" href="https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/">Caching Strategies and How to Choose the Right One</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Key eviction（缓存淘汰）</title>
      <link href="/2023/05/20/f997e124837a.html"/>
      <url>/2023/05/20/f997e124837a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="maxmemory-配置"><a href="#maxmemory-配置" class="headerlink" title="maxmemory 配置"></a>maxmemory 配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure><p>64 bit 系统下默认行为没有内存上限，32 bit 系统则默认是 3GB。虽然 64 bit 系统能够提供近乎无穷大的地址空间，但是物理内存是有限的，如果 Redis 占用内存超过物理内存上限，访问键时可能导致频繁的缺页异常，吞吐量降低。</p><p>设置上限后的另一个问题：满了怎么办？</p><table><thead><tr><th>maxmemory-policy</th><th>description</th></tr></thead><tbody><tr><td>noeviction</td><td>内存达到上限时，拒绝添加新键</td></tr><tr><td>allkeys-lru</td><td>在键空间中根据 LRU 算法淘汰键</td></tr><tr><td>allkeys-lfu</td><td>在键空间中根据 LFU 算法淘汰键</td></tr><tr><td>volatile-lru</td><td>在 <code>expires</code> 中根据 LRU 算法淘汰键</td></tr><tr><td>volatile-lfu</td><td>在 <code>expires</code> 中根据 LFU 算法淘汰键</td></tr><tr><td>allkeys-random</td><td>在键空间中随机选择键淘汰</td></tr><tr><td>volatile-random</td><td>在 <code>expires</code> 中随机选择键淘汰</td></tr><tr><td>volatile-ttl</td><td>淘汰 <code>expires</code> 中 ttl 最小的键</td></tr></tbody></table><p>经验法则（a rule of thumb）：</p><ul><li><code>*-lru</code> 或 <code>*-lfu</code> 适用于键的访问频次符合幂律分布（power-law）分布的情况。</li><li><code>*-random</code> 适用于键拥有相同的被访问概率。</li><li><code>volatile-ttl</code> 适用于客户端想根据实际情况灵活调整建议 Redis 淘汰键，即自行配置过期时间。</li></ul><h2 id="典型-LRU-x2F-LFU-实现"><a href="#典型-LRU-x2F-LFU-实现" class="headerlink" title="典型 LRU &#x2F; LFU 实现"></a>典型 LRU &#x2F; LFU 实现</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Latest                                              Oldest</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">|  A  | ---&gt; |  B  | ---&gt; |  C  | ---&gt; |  D  | ---&gt; |  E  |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line"></span><br><span class="line"># D accessed</span><br><span class="line">Latest                                              Oldest</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">|  D  | ---&gt; |  A  | ---&gt; |  B  | ---&gt; |  C  | ---&gt; |  E  |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br></pre></td></tr></table></figure><p>按照访问时间由近至远排序，处在队尾的即最长时间未被访问的数据，优先被淘汰。</p><p>时间开销：O(1)<br>空间开销：O(N)</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>LRU 在淘汰缓存时只考虑了最近 1 访问，不能很好区分热点与非热点数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">|  1  | ---&gt; |  2  | ---&gt; |  3  | ---&gt; |  4  | ---&gt; |  5  |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">   |            |            |            |            |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">|     |      |     |      |     |      |     |      |     |</span><br><span class="line">+-----+      +-----+      +-----+      +-----+      +-----+</span><br><span class="line">   |            |                         |            |</span><br><span class="line">+-----+      +-----+                   +-----+      +-----+</span><br><span class="line">|     |      |     |                   |     |      |     |</span><br><span class="line">+-----+      +-----+                   +-----+      +-----+</span><br><span class="line">                |                                      |</span><br><span class="line">             +-----+                                +-----+</span><br><span class="line">             |     |                                |     |</span><br><span class="line">             +-----+                                +-----+</span><br></pre></td></tr></table></figure><p>按照最近一短时间访问频次排序，频次相同的再按照访问时间由近至远排序。</p><p>时间开销：O(N)<br>空间开销：O(N)</p><blockquote><p>不同的实现方式可以带来不同的时空复杂度组合，这里只是为了说明相比比 LRU，LFU 解决的问题和实现方式都更复杂。</p></blockquote><h2 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a>Redis 实现</h2><p>不论是 LRU 还是 LFU，都需要一个额外的结构记录键的访问信息，但是 Redis 通过近似实现规避了额外的记录，同时还保证了不错的效果。</p><p>LRU 和 LFU 简化后本质都是基于某种规则排序，然后淘汰对应的数据。同时 LRU 和 LFU 也是理想化的模型，并不能完全匹配现实情况，所以有可能使用一个接近 LRU&#x2F;LFU，但是开销更小的方式做到相同的效果。事实上 Redis 变通的方式很简单————采样，默认配置 <code>maxmemory-samples 5</code> 就能达到很好的效果，具体可以参考 <a target="_blank" rel="noopener" href="https://redis.io/docs/reference/eviction/" title="Eviction">Eviction</a>。</p><h3 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                           * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                           * and most significant 16 bits access time). */</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><blockquote><p>把 <a href="./20230505-Redis-Object.md">Redis Object</a> 的坑填上。</p></blockquote><p>每次访问键前都会调用 <code>lookupKey</code>，里面会更新 <code>redisObject.lru</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">         updateLFU(val);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         val-&gt;lru = LRU_CLOCK();</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU-CLOCK-实现"><a href="#LRU-CLOCK-实现" class="headerlink" title="LRU_CLOCK 实现"></a>LRU_CLOCK 实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_CLOCK_MAX ((1&lt;&lt;LRU_BITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_CLOCK_RESOLUTION 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the LRU clock, based on the clock resolution. This is a time</span></span><br><span class="line"><span class="comment"> * in a reduced-bits format that can be used to set and check the</span></span><br><span class="line"><span class="comment"> * object-&gt;lru field of redisObject structures. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">getLRUClock</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is used to obtain the current LRU clock.</span></span><br><span class="line"><span class="comment"> * If the current resolution is lower than the frequency we refresh the</span></span><br><span class="line"><span class="comment"> * LRU clock (as it should be in production servers) we return the</span></span><br><span class="line"><span class="comment"> * precomputed value, otherwise we need to resort to a system call. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">LRU_CLOCK</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        atomicGet(server.lruclock,lruclock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了减少系统调用，<code>lruclock</code> 会使用缓存好的 <code>server.lruclock</code>，最终都是调用 <code>getLRUClock</code>。<code>lruclock</code> 的单位是秒，最大可记录 <code>2^24-1</code> 秒 ~&#x3D; 194 天。</p><h4 id="updateLFU-实现"><a href="#updateLFU-实现" class="headerlink" title="updateLFU 实现"></a>updateLFU 实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.conf</span></span><br><span class="line"><span class="comment">// # lfu-log-factor 10</span></span><br><span class="line"><span class="comment">// # lfu-decay-time 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the object decrement time is reached decrement the LFU counter but</span></span><br><span class="line"><span class="comment"> * do not update LFU fields of the object, we update the access time</span></span><br><span class="line"><span class="comment"> * and counter in an explicit way when the object is really accessed.</span></span><br><span class="line"><span class="comment"> * And we will times halve the counter according to the times of</span></span><br><span class="line"><span class="comment"> * elapsed time than server.lfu_decay_time.</span></span><br><span class="line"><span class="comment"> * Return the object frequency counter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is used in order to scan the dataset for the best object</span></span><br><span class="line"><span class="comment"> * to fit: as we check for the candidate, we incrementally decrement the</span></span><br><span class="line"><span class="comment"> * counter of the scanned objects if needed. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">LFUDecrAndReturn</span><span class="params">(robj *o)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Logarithmically increment a counter. The greater is the current counter value</span></span><br><span class="line"><span class="comment"> * the less likely is that it gets really incremented. Saturate it at 255. */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LFULogIncr</span><span class="params">(<span class="type">uint8_t</span> counter)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="type">double</span> r = (<span class="type">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="type">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the current time in minutes, just taking the least significant</span></span><br><span class="line"><span class="comment"> * 16 bits. The returned time is suitable to be stored as LDT (last decrement</span></span><br><span class="line"><span class="comment"> * time) for the LFU implementation. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">LFUGetTimeInMinutes</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update LFU when an object is accessed.</span></span><br><span class="line"><span class="comment"> * Firstly, decrement the counter if the decrement time is reached.</span></span><br><span class="line"><span class="comment"> * Then logarithmically increment the counter, and update the access time. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateLFU</span><span class="params">(robj *val)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateLFU</code> 做了三件事：</p><ol><li>根据最近一次访问时间及旧 <code>counter</code> 计算当前 <code>counter</code>。</li><li>根据当前 <code>counter</code> 计算其自增的概率，<code>((counter - 5) * lfu_log_factor + 1)</code><sup>-1</sup>，得到新 <code>counter</code>。</li><li>将当前时间（最新访问时间）和 <code>counter</code> 写入 <code>redisObject.lru</code>。</li></ol><p>LFU 的访问时间以分钟为单位，最大可记录 <code>2^16-1</code> 分钟 ~&#x3D; 45 天。每 <code>lfu_decay_time</code> 分钟 <code>counter</code> 减 1，随着访问频率增加，<code>counter</code> 自增概率下降，不同 <code>lfu_log_factor</code> 下不同 <code>counter</code> 值所需要的访问次数（连续访问间隔小于一分钟）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure><h3 id="Eviction-流程"><a href="#Eviction-流程" class="headerlink" title="Eviction 流程"></a>Eviction 流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">performEvictions</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MAXMEMORY_FLAG_LRU || MAXMEMORY_FLAG_LFU || MAXMEMORY_VOLATILE_TTL)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> =</span> EvictionPoolLRU;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                evictionPoolPopulate(i, db-&gt;dict <span class="comment">/*or db-&gt;expires */</span>, db-&gt;dict, pool);</span><br><span class="line">            &#125;</span><br><span class="line">            bestkey = <span class="comment">/*last one in pool*/</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAXMEMORY_ALLKEYS_RANDOM || MAXMEMORY_VOLATILE_RANDOM) &#123;</span><br><span class="line">            bestkey = dictGetRandomKey(dict)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">            dbAsyncDelete(db,keyobj);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dbSyncDelete(db,keyobj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>maxmemory_policy</code> 使用不同策略从目标键空间找到需要淘汰的键，再根据 <code>lazyfree_lazy_eviction</code> 决定立即释放还是异步释放缓存。重点关注 <code>evictionPoolPopulate</code>，通过扫描所有 db 填满 <code>pool</code>，为了降低对正常请求的影响，对<code>pool</code> 中键的回收也是点到即止（<code>mem_freed &lt; mem_tofree</code>）。</p><h4 id="evictionPoolPopulate"><a href="#evictionPoolPopulate" class="headerlink" title="evictionPoolPopulate"></a>evictionPoolPopulate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">evictionPoolPopulate</span><span class="params">(<span class="type">int</span> dbid, dict *sampledict, dict *keydict, <span class="keyword">struct</span> evictionPoolEntry *pool)</span> &#123;</span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            idle = ULLONG_MAX - expire_at;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// idle &lt; min(pool[N].idle)</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dictGetSomeKeys</code> 会随机挑选最多 <code>maxmemory_samples(5)</code> 个键，但是不保证重复。然后根据不同的 <code>maxmemory_policy</code> 计算出 <code>idle</code>，从小到大填入 <code>pool</code>。当 <code>pool</code> 已经填充满时，只有比 <code>pool[0].idle</code> 大的键才能进入 <code>pool</code>，这种策略进一步提高了内存淘汰的效果。</p><h4 id="释放缓存"><a href="#释放缓存" class="headerlink" title="释放缓存"></a>释放缓存</h4><p>同步释放和异步释放最终都会调用 <code>dbGenericDelete</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dbGenericDelete</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> async)</span> &#123;</span><br><span class="line">    dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        freeObjAsync(key, val, db-&gt;id);</span><br><span class="line">        <span class="comment">// dictFreeUnlinkedEntry 不会一起释放 val</span></span><br><span class="line">        dictSetVal(db-&gt;dict, de, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>freeObjAsync</code> 会直接释放小对象，效果和同步释放一样；如果是大对象则提交异步任务。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://redis.io/docs/reference/eviction/" title="Eviction">Eviction</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Eviction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Persistence</title>
      <link href="/2023/05/15/f986813d0d94.html"/>
      <url>/2023/05/15/f986813d0d94.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><p>Redis 提供了四种持久化的方式：</p><ul><li>No persistence：不做持久化处理，用得较少。</li><li>RDB：对缓存做全量 point-in-time 快照，生成的 *.rdb 文件非常紧凑，加载性能高，非 human readable。</li><li>AOF：对每个 write operation 进行记录，通过 replay 重新生成当前缓存状态，记录按照 RESP 格式存储，human readable。</li><li>RDB + AOF：结合 RDB 与 AOF。</li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="命令-amp-配置"><a href="#命令-amp-配置" class="headerlink" title="命令&amp;配置"></a>命令&amp;配置</h3><p><code>SAVE</code> 在当前进程生成快照，会阻塞服务；<code>BGSAVE</code> 在子进程中生成快照，不会阻塞服务。</p><p>除手动执行 <code>SAVE</code> 和 <code>BGSAVE</code>，Redis 允许配置 <code>BGSAVE</code> 自动执行的条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save M N # At lease N changes in the last M seconds</span><br><span class="line">save ...</span><br></pre></td></tr></table></figure><p>满足多个条件中任意一条即可自动执行 <code>BGSAVE</code>。</p><h3 id="BGSAVE-执行过程"><a href="#BGSAVE-执行过程" class="headerlink" title="BGSAVE 执行过程"></a>BGSAVE 执行过程</h3><ol><li>Fork 子进程</li><li>子进程将数据写入临时 RDB 文件</li><li>子进程将临时 RDB 文件重命名替换当前 RDB 文件</li><li>子进程退出</li><li>父进程处理子进程 exitcode</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> server.child_type == CHILD_TYPE_RDB:</span><br><span class="line">  <span class="comment"># err: RDB already in progress </span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> server.has_active_transaction:</span><br><span class="line">  <span class="comment"># schedule RDB</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasActiveChildProcess:</span><br><span class="line">  <span class="keyword">if</span> [SCHEDULE] :</span><br><span class="line">    <span class="comment"># schedule RDB</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># err: refuse, maybe AOF</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fork() == <span class="number">0</span>:</span><br><span class="line">  rdbSave()</span><br></pre></td></tr></table></figure><h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ul><li>RDB 文件紧凑</li><li>RDB 文件可以传输到其它机器上恢复</li><li>高性能，子进程 fork 出来后父进程照常处理请求，不会 disk I&#x2F;O</li></ul><h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><ul><li>RDB 是整个数据库的快照，这决定了其无法做到非常高频地备份出快照。在 Redis 意外退出时，至少丢失数分钟的数据。</li><li>当数据库很大时，fork 子进程也将会比较耗时</li><li>执行快照过程中，如果父进程接收大量写请求，将导致大量的内存页拷贝。</li></ul><h2 id="AOF-Append-only-file"><a href="#AOF-Append-only-file" class="headerlink" title="AOF(Append-only file)"></a>AOF(Append-only file)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfsync always # 每次 AOF 写就同步</span><br><span class="line">appendfsync everysec # 每秒同步一次</span><br><span class="line">appendfsync no # 由 OS 决定同步时机</span><br></pre></td></tr></table></figure><p>开启 AOF 后，Redis 每收到一条写命令就会将该命令写入 AOF，Redis 重启时就可以重放 AOF 文件恢复数据。当 AOF 增长到一定大小时就需要进行重写，减小文件大小。</p><h3 id="rewrite-过程"><a href="#rewrite-过程" class="headerlink" title="rewrite 过程"></a>rewrite 过程</h3><p><code>BGREWRITEAOF</code>。</p><ol><li>flush <code>aof_buf</code>，调用 <code>fsync</code></li><li>创建新的 incremental AOF 文件记录后续写命令</li><li>Fork 子进程</li><li>子进程将当前数据库以 AOF 格式写入 temp BASE file</li><li>父进程 rename(temp BASE file, BASE file) 并与 incremental AOF 构建一个新的 manifest 文件</li></ol><h3 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros"></a>Pros</h3><ul><li>相比 RDB 有更优 durability，可做到秒级的数据备份</li><li>AOF 使用 RESP 协议记录，易于直接阅读</li></ul><h3 id="Cons-1"><a href="#Cons-1" class="headerlink" title="Cons"></a>Cons</h3><ul><li>AOF 文件通常比 RDB 文件大</li><li><code>appendfsync everysec</code> 对性能有轻微影响，实际并不明显</li></ul><h2 id="RDB-AOF"><a href="#RDB-AOF" class="headerlink" title="RDB + AOF"></a>RDB + AOF</h2><blockquote><p>Redis 5 中默认开启</p></blockquote><p>RDB + AOF 结合了 RDB 和 AOF 的优点，此时整体格式变为：[RDB] + [AOF]，在 AOF 重写子进程中，不再是以 RESP 协议导出数据库到 BASE file，而是 RDB，即 BASE AOF file 中保存了 RDB 格式的数据。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://redis.io/docs/management/persistence/">Redis persistence</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> RDB </tag>
            
            <tag> AOF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 键的生存时间</title>
      <link href="/2023/05/14/00996dc0546d.html"/>
      <url>/2023/05/14/00996dc0546d.html</url>
      
        <content type="html"><![CDATA[<h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>EXPIRE seconds</td><td>设置剩余生存时间</td></tr><tr><td>PEXPIRE milliseconds</td><td>同上，单位毫秒</td></tr><tr><td>EXPIREAT seconds-timestamp</td><td>设置过期时间戳</td></tr><tr><td>PEXPIREAT milliseconds-timestamp</td><td>同上，单位毫秒</td></tr><tr><td>SETEX &#x2F; SET EX</td><td>专用于 String</td></tr><tr><td>PERSIST</td><td>去除过期时间</td></tr></tbody></table><p>设置过期时间命令最终都会调用 <code>PEXPIREAT</code>，当键发生更新时，过期时间失效。</p><h2 id="剩余生存时间"><a href="#剩余生存时间" class="headerlink" title="剩余生存时间"></a>剩余生存时间</h2><p><code>TTL key</code> or <code>PTTL key</code>。</p><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>三种策略：</p><ul><li>定时删除：对键设置过期时间的同时，设置一个 timer，timer 到期后立即删除键。</li><li>惰性删除：在访问时做过期检查，过期则先删除，再执行原来的操作。</li><li>定期删除：周期性地删除一批过期键。</li></ul><p>定期删除，内存友好，CPU 不友好。过期键较多时会大量占用 CPU，同时需要注册时间事件。<br>惰性删除对内存不友好，如果键过期后一直没被访问，则此键将一直驻留在内存中。<br>定期删除是前两种地折衷，Redis 中是遍历数据库，然后从 <code>expires</code> 中随机挑选 <code>key</code> 并删除已过期键，执行超过指定时间则停止。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Object</title>
      <link href="/2023/05/05/bc852159c7f6.html"/>
      <url>/2023/05/05/bc852159c7f6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><p>Redis 对外支持的数据类型（String、List、Hash、Set、ZSet）并不是直接使用其定义的数据结构，而是基于另外的一套对象系统。对象系统除了可以根据不同场景选择不同底层数据结构外，还实现了基于引用计数的<em>对象共享</em>和<em>垃圾回收</em>以及<em>缓存淘汰</em>机制。</p><h2 id="Redis-Object-定义"><a href="#Redis-Object-定义" class="headerlink" title="Redis Object 定义"></a>Redis Object 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;    <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                         * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                         * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li><code>type</code>：记录对象类型<table><thead><tr><th>类型</th><th>取值</th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>0</td></tr><tr><td>OBJ_LIST</td><td>1</td></tr><tr><td>OBJ_SET</td><td>2</td></tr><tr><td>OBJ_ZSET</td><td>3</td></tr><tr><td>OBJ_HASH</td><td>4</td></tr></tbody></table></li><li><code>encoding</code>：记录对象的编码及底层实现<table><thead><tr><th>编码</th><th>取值</th><th>对应数据结构</th></tr></thead><tbody><tr><td>OBJ_ENCODING_RAW</td><td>0</td><td>SDS</td></tr><tr><td>OBJ_ENCODING_INT</td><td>1</td><td>long</td></tr><tr><td>OBJ_ENCODING_HT</td><td>2</td><td>字典</td></tr><tr><td>OBJ_ENCODING_INTSET</td><td>6</td><td>整数集合</td></tr><tr><td>OBJ_ENCODING_SKIPLIST</td><td>7</td><td>跳表和字典</td></tr><tr><td>OBJ_ENCODING_EMBSTR</td><td>8</td><td>embedded 编码的 SDS</td></tr><tr><td>OBJ_ENCODING_QUICKLIST</td><td>9</td><td></td></tr><tr><td>OBJ_ENCODING_STREAM</td><td>10</td><td></td></tr><tr><td>OBJ_ENCODING_LISTPACK</td><td>11</td><td></td></tr></tbody></table></li><li><code>lru</code>：缓存淘汰策略相关</li><li><code>refcount</code>：引用计数</li><li><code>ptr</code>：底层数据指针</li></ul><p>该结构采用了 <code>Bit Field</code> 来降低内存的占用。Redis 会根据实际情况（数据类型，数据大小）选择相对合适的 <code>encoding</code> 来提高性能与效率。</p><table><thead><tr><th>type</th><th>encoding</th><th>对象</th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>OBJ_ENCODING_RAW</td><td><code>ptr</code> 指向 SDS</td></tr><tr><td>OBJ_STRING</td><td>OBJ_ENCODING_INT</td><td><code>ptr</code> 值就是整数值，而非地址</td></tr><tr><td>OBJ_STRING</td><td>OBJ_ENCODING_EMBSTR</td><td>字符串较短时，一次分配一块内存连续存放 <code>redisObject</code> 和 <code>sdshdr</code> 对象</td></tr><tr><td>OBJ_LIST</td><td>OBJ_ENCODING_QUICKLIST</td><td><code>ptr</code> 指向 <code>quicklist</code></td></tr><tr><td>OBJ_SET</td><td>OBJ_ENCODING_HT</td><td><code>ptr</code> 指向 <code>dict</code>，只使用 key，值设为 NULL</td></tr><tr><td>OBJ_SET</td><td>OBJ_ENCODING_INTSET</td><td><code>ptr</code> 指向 <code>intset</code>，所有元素都是整数，且数量不超过 512</td></tr><tr><td>OBJ_ZSET</td><td>OBJ_ENCODING_LISTPACK</td><td><code>ptr</code> 指向 <code>listpack</code>，元素数量 &lt; <code>server.zset_max_listpack_entries</code> 且元素大小 &lt; <code>server.zset_max_listpack_value</code></td></tr><tr><td>OBJ_ZSET</td><td>OBJ_ENCODING_SKIPLIST</td><td><code>ptr</code> 指向 <code>zset&#123;dict, skiplist&#125;</code>,</td></tr><tr><td>OBJ_HASH</td><td>OBJ_ENCODING_LISTPACK</td><td><code>ptr</code> 指向 <code>listpack</code>，元素数量 &lt; <code>server.zset_max_listpack_entries</code> 且元素大小 &lt; <code>server.zset_max_listpack_value</code>。暂时不支持 HT 转成 LISTPACK</td></tr><tr><td>OBJ_HASH</td><td>OBJ_ENCODING_HT</td><td><code>ptr</code> 指向 <code>dict</code></td></tr></tbody></table><h2 id="对象引用计数"><a href="#对象引用计数" class="headerlink" title="对象引用计数"></a>对象引用计数</h2><p>Redis 通过追踪 <code>redisObject#refcount</code>，在适当的时候自动释放 <code>refcount == 0</code> 的对象。</p><p>引用计数除了用作垃圾回收外，还可用作对象共享。不过对象共享需要查找到一个具有相同值的对象，O(N<sup>2</sup>) 复杂度，CPU 开销大。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/server.h">server.h&#x2F;redisObject</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_string.h">t_string.h</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_list.h">t_list.h</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_hash.h">t_hash.h</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_set.h">t_set.h</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/t_zset.h">t_zset.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Ziplist</title>
      <link href="/2023/05/04/1f8b284123ca.html"/>
      <url>/2023/05/04/1f8b284123ca.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Ziplist-定义"><a href="#Ziplist-定义" class="headerlink" title="Ziplist 定义"></a>Ziplist 定义</h2><p>Ziplist 没有像其它数据结构一样提供明确的 <code>struct</code> 定义，因为部分成员的大小不是固定的，以达到节省内存的目的。提供的 struct 也只是为了方便读取信息。所以就贴一下注释内容吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZIPLIST OVERALL LAYOUT</span></span><br><span class="line"><span class="comment"> * ======================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The general layout of the ziplist is as follows:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> all fields are stored in little endian, if not specified otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;uint32_t zlbytes&gt; is an unsigned integer to hold the number of bytes that</span></span><br><span class="line"><span class="comment"> * the ziplist occupies, including the four bytes of the zlbytes field itself.</span></span><br><span class="line"><span class="comment"> * This value needs to be stored to be able to resize the entire structure</span></span><br><span class="line"><span class="comment"> * without the need to traverse it first.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;uint32_t zltail&gt; is the offset to the last entry in the list. This allows</span></span><br><span class="line"><span class="comment"> * a pop operation on the far side of the list without the need for full</span></span><br><span class="line"><span class="comment"> * traversal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;uint16_t zllen&gt; is the number of entries. When there are more than</span></span><br><span class="line"><span class="comment"> * 2^16-2 entries, this value is set to 2^16-1 and we need to traverse the</span></span><br><span class="line"><span class="comment"> * entire list to know how many items it holds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;uint8_t zlend&gt; is a special entry representing the end of the ziplist.</span></span><br><span class="line"><span class="comment"> * Is encoded as a single byte equal to 255. No other normal entry starts</span></span><br><span class="line"><span class="comment"> * with a byte set to the value of 255.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZIPLIST ENTRIES</span></span><br><span class="line"><span class="comment"> * ===============</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Every entry in the ziplist is prefixed by metadata that contains two pieces</span></span><br><span class="line"><span class="comment"> * of information. First, the length of the previous entry is stored to be</span></span><br><span class="line"><span class="comment"> * able to traverse the list from back to front. Second, the entry encoding is</span></span><br><span class="line"><span class="comment"> * provided. It represents the entry type, integer or string, and in the case</span></span><br><span class="line"><span class="comment"> * of strings it also represents the length of the string payload.</span></span><br><span class="line"><span class="comment"> * So a complete entry is stored like this:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Sometimes the encoding represents the entry itself, like for small integers</span></span><br><span class="line"><span class="comment"> * as we&#x27;ll see later. In such a case the &lt;entry-data&gt; part is missing, and we</span></span><br><span class="line"><span class="comment"> * could have just:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;prevlen&gt; &lt;encoding&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The length of the previous entry, &lt;prevlen&gt;, is encoded in the following way:</span></span><br><span class="line"><span class="comment"> * If this length is smaller than 254 bytes, it will only consume a single</span></span><br><span class="line"><span class="comment"> * byte representing the length as an unsigned 8 bit integer. When the length</span></span><br><span class="line"><span class="comment"> * is greater than or equal to 254, it will consume 5 bytes. The first byte is</span></span><br><span class="line"><span class="comment"> * set to 254 (FE) to indicate a larger value is following. The remaining 4</span></span><br><span class="line"><span class="comment"> * bytes take the length of the previous entry as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So practically an entry is encoded in the following way:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Or alternatively if the previous entry length is greater than 253 bytes</span></span><br><span class="line"><span class="comment"> * the following encoding is used:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The encoding field of the entry depends on the content of the</span></span><br><span class="line"><span class="comment"> * entry. When the entry is a string, the first 2 bits of the encoding first</span></span><br><span class="line"><span class="comment"> * byte will hold the type of encoding used to store the length of the string,</span></span><br><span class="line"><span class="comment"> * followed by the actual length of the string. When the entry is an integer</span></span><br><span class="line"><span class="comment"> * the first 2 bits are both set to 1. The following 2 bits are used to specify</span></span><br><span class="line"><span class="comment"> * what kind of integer will be stored after this header. An overview of the</span></span><br><span class="line"><span class="comment"> * different types and encodings is as follows. The first byte is always enough</span></span><br><span class="line"><span class="comment"> * to determine the kind of entry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * |00pppppp| - 1 byte</span></span><br><span class="line"><span class="comment"> *      String value with length less than or equal to 63 bytes (6 bits).</span></span><br><span class="line"><span class="comment"> *      &quot;pppppp&quot; represents the unsigned 6 bit length.</span></span><br><span class="line"><span class="comment"> * |01pppppp|qqqqqqqq| - 2 bytes</span></span><br><span class="line"><span class="comment"> *      String value with length less than or equal to 16383 bytes (14 bits).</span></span><br><span class="line"><span class="comment"> *      IMPORTANT: The 14 bit number is stored in big endian.</span></span><br><span class="line"><span class="comment"> * |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes</span></span><br><span class="line"><span class="comment"> *      String value with length greater than or equal to 16384 bytes.</span></span><br><span class="line"><span class="comment"> *      Only the 4 bytes following the first byte represents the length</span></span><br><span class="line"><span class="comment"> *      up to 2^32-1. The 6 lower bits of the first byte are not used and</span></span><br><span class="line"><span class="comment"> *      are set to zero.</span></span><br><span class="line"><span class="comment"> *      IMPORTANT: The 32 bit number is stored in big endian.</span></span><br><span class="line"><span class="comment"> * |11000000| - 3 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int16_t (2 bytes).</span></span><br><span class="line"><span class="comment"> * |11010000| - 5 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int32_t (4 bytes).</span></span><br><span class="line"><span class="comment"> * |11100000| - 9 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int64_t (8 bytes).</span></span><br><span class="line"><span class="comment"> * |11110000| - 4 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as 24 bit signed (3 bytes).</span></span><br><span class="line"><span class="comment"> * |11111110| - 2 bytes</span></span><br><span class="line"><span class="comment"> *      Integer encoded as 8 bit signed (1 byte).</span></span><br><span class="line"><span class="comment"> * |1111xxxx| - (with xxxx between 0001 and 1101) immediate 4 bit integer.</span></span><br><span class="line"><span class="comment"> *      Unsigned integer from 0 to 12. The encoded value is actually from</span></span><br><span class="line"><span class="comment"> *      1 to 13 because 0000 and 1111(&lt;zlend&gt;) can not be used, so 1 should be</span></span><br><span class="line"><span class="comment"> *      subtracted from the encoded 4 bit value to obtain the right value.</span></span><br><span class="line"><span class="comment"> * |11111111| - End of ziplist special entry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Like for the ziplist header, all the integers are represented in little</span></span><br><span class="line"><span class="comment"> * endian byte order, even when this code is compiled in big endian systems.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * EXAMPLES OF ACTUAL ZIPLISTS</span></span><br><span class="line"><span class="comment"> * ===========================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following is a ziplist containing the two elements representing</span></span><br><span class="line"><span class="comment"> * the strings &quot;2&quot; and &quot;5&quot;. It is composed of 15 bytes, that we visually</span></span><br><span class="line"><span class="comment"> * split into sections:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  [0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]</span></span><br><span class="line"><span class="comment"> *        |             |          |       |       |     |</span></span><br><span class="line"><span class="comment"> *     zlbytes        zltail     zllen    &quot;2&quot;     &quot;5&quot;   end</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The first 4 bytes represent the number 15, that is the number of bytes</span></span><br><span class="line"><span class="comment"> * the whole ziplist is composed of. </span></span><br><span class="line"><span class="comment"> * The second 4 bytes are the offset at which the last ziplist entry is </span></span><br><span class="line"><span class="comment"> * found, that is 12, in fact the last entry, that is &quot;5&quot;, is at offset </span></span><br><span class="line"><span class="comment"> * 12 inside the ziplist.</span></span><br><span class="line"><span class="comment"> * The next 16 bit integer represents the number of elements inside the</span></span><br><span class="line"><span class="comment"> * ziplist, its value is 2 since there are just two elements inside.</span></span><br><span class="line"><span class="comment"> * Finally &quot;00 f3&quot; is the first entry representing the number 2. It is</span></span><br><span class="line"><span class="comment"> * composed of the previous entry length, which is zero because this is</span></span><br><span class="line"><span class="comment"> * our first entry, and the byte F3 which corresponds to the encoding</span></span><br><span class="line"><span class="comment"> * |1111xxxx| with xxxx between 0001 and 1101. We need to remove the &quot;F&quot;</span></span><br><span class="line"><span class="comment"> * higher order bits 1111, and subtract 1 from the &quot;3&quot;, so the entry value</span></span><br><span class="line"><span class="comment"> * is &quot;2&quot;. The next entry has a prevlen of 02, since the first entry is</span></span><br><span class="line"><span class="comment"> * composed of exactly two bytes. The entry itself, F6, is encoded exactly</span></span><br><span class="line"><span class="comment"> * like the first entry, and 6-1 = 5, so the value of the entry is 5.</span></span><br><span class="line"><span class="comment"> * Finally the special entry FF signals the end of the ziplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Adding another element to the above string with the value &quot;Hello World&quot;</span></span><br><span class="line"><span class="comment"> * allows us to show how the ziplist encodes small strings. We&#x27;ll just show</span></span><br><span class="line"><span class="comment"> * the hex dump of the entry itself. Imagine the bytes as following the</span></span><br><span class="line"><span class="comment"> * entry that stores &quot;5&quot; in the ziplist above:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [02] [0b] [48 65 6c 6c 6f 20 57 6f 72 6c 64]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The first byte, 02, is the length of the previous entry. The next</span></span><br><span class="line"><span class="comment"> * byte represents the encoding in the pattern |00pppppp| that means</span></span><br><span class="line"><span class="comment"> * that the entry is a string of length &lt;pppppp&gt;, so 0B means that</span></span><br><span class="line"><span class="comment"> * an 11 bytes string follows. From the third byte (48) to the last (64)</span></span><br><span class="line"><span class="comment"> * there are just the ASCII characters for &quot;Hello World&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>每一个 entry 由 <code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code> 构成，其中 <code>&lt;prelen&gt;</code> 占用字节数由前一节点长度决定，所以某一位置节点的更新或插入，会导致后继节点的重新分配。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/ziplist.h">ziplist.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Ziplist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Intset</title>
      <link href="/2023/05/04/b29e26902a89.html"/>
      <url>/2023/05/04/b29e26902a89.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Intset-定义"><a href="#Intset-定义" class="headerlink" title="Intset 定义"></a>Intset 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><ul><li><code>encoding</code>：整数的编码方式，实际上表示整数的取值范围（占用字节）。可选值有 <code>INSET_ENC_INT16</code>、<code>INSET_ENC_INT32</code> 和 <code>INSET_ENC_INT64</code>。</li><li><code>length</code>：整数个数，通过 <code>length</code> 和 <code>encoding</code> 可以计算出 <code>contents</code> 大小。</li><li><code>contents</code>：字节数组，每次 Add 或 Remove 都会引起 <code>contents</code> 长度变化（<code>realloc</code>）。</li></ul><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>升级指 <code>enocding</code> 由较少字节占用扩展到更多字节占用。升级由超过当前 <code>encoding</code> 所能表示的上下限的新元素引起，这个时候新元素要么在 <code>contents</code> 头部，要么在尾部插入。</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>不支持降级。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/intset.h">intset.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Intset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Skiplist</title>
      <link href="/2023/05/02/9712a7092d6a.html"/>
      <url>/2023/05/02/9712a7092d6a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Skiplist-定义"><a href="#Skiplist-定义" class="headerlink" title="Skiplist 定义"></a>Skiplist 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><ul><li><code>zskiplistNode.score</code>：节点的权重，它决定了节点在列表中的位置（从小到大）；分值相同的节点则按照 <code>ele</code> 的字典顺序排序。</li><li><code>zskiplistNode.level</code>：level 数组包含指向后续节点的指针，<code>nodes[a].level[N]</code> 指向 <code>nodes[b].level[N]</code> 或 NULL， 其中 <code>a &lt; b</code>。<strong>新节点会随机创建一个介于 <code>[1, 32]</code> 大小的 level 数组</strong>。</li><li><code>zskiplistNode.zskiplistLevel.span</code>：步长或跨度，<code>nodes[a].level[N]</code> 指向 <code>nodes[b].level[N]</code> 跨越的节点数（包含结尾）。</li></ul><p>示意图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--+</span><br><span class="line">|L32 --0-&gt; NULL</span><br><span class="line">+--+</span><br><span class="line">....</span><br><span class="line">+--+                             +--+</span><br><span class="line">|L5| -------------3------------&gt; |L5| --0-&gt; NULL</span><br><span class="line">+--+       +--+                  +--+</span><br><span class="line">|L4| --1-&gt; |L4| -------2-------&gt; |L4| --0-&gt; NULL</span><br><span class="line">+--+       +--+                  +--+</span><br><span class="line">|L3| --1-&gt; |L3| -------2-------&gt; |L3| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+</span><br><span class="line">|L2| --1-&gt; |L2| --1-&gt; |L2| --1-&gt; |L2| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+</span><br><span class="line">|L1| --1-&gt; |L1| --1-&gt; |L1| --1-&gt; |L1| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+</span><br><span class="line">      +--- |BW| &lt;---- |BW| &lt;---- |BW|</span><br><span class="line">      |    +--+       +--+       +--+</span><br><span class="line">    NULL   |1.|       |2.|       |3.|</span><br><span class="line">           +--+       +--+       +--+</span><br><span class="line">           |o1|       |o2|       |o3|</span><br><span class="line">           +--+       +--+       +--+</span><br><span class="line">head                             tail</span><br></pre></td></tr></table></figure><blockquote><p>换个角度，跳表非常像某一链接及其子序列链表的加总。</p></blockquote><h2 id="搜索节点"><a href="#搜索节点" class="headerlink" title="搜索节点"></a>搜索节点</h2><p>从 <code>head</code> 最高层开始，往下逐层缩小查找范围，有点类似二分查找。</p><h2 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h2><ol><li>找到新节点将要插入的位置。</li><li>找到新节点在每层链表中的前驱节点，即往前距新节点最近的 <code>level[N]</code>。例如 <code>o2.L1</code>、<code>o2.L2</code> 和 <code>o1.L4</code>。</li><li>修改前驱节点的 <code>level[L].forward</code> 及 <code>span</code>。</li><li>对于位于新节点之前且 <code>nodes[N].level[L] &amp;&amp; L &gt; new.level.length</code> 的节点，<code>span++</code>。例如 <code>o1.L4</code> 和 <code>head.L5</code>。</li><li>更新 <code>backward</code> 指针。例如 <code>o3.BW</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--+</span><br><span class="line">|L32 --0-&gt; NULL</span><br><span class="line">+--+</span><br><span class="line">....</span><br><span class="line">+--+                                        +--+</span><br><span class="line">&#123;L5&#125; ------------------4------------------&gt; |L5| --0-&gt; NULL</span><br><span class="line">+--+       +--+                             +--+</span><br><span class="line">|L4| --1-&gt; &#123;L4&#125; -------------3------------&gt; |L4| --0-&gt; NULL</span><br><span class="line">+--+       +--+                  +--+       +--+</span><br><span class="line">|L3| --1-&gt; &#123;L3&#125; -------2-------&gt; |L3| --1-&gt; |L3| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+       +--+</span><br><span class="line">|L2| --1-&gt; |L2| --1-&gt; &#123;L2&#125; --1-&gt; |L2| --1-&gt; |L2| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+       +--+</span><br><span class="line">|L1| --1-&gt; |L1| --1-&gt; &#123;L1&#125; --1-&gt; |L1| --1-&gt; |L1| --0-&gt; NULL</span><br><span class="line">+--+       +--+       +--+       +--+       +--+</span><br><span class="line">      +--- |BW| &lt;---- |BW| &lt;---- |BW| &lt;---- &#123;BW&#125;</span><br><span class="line">      |    +--+       +--+       +--+       +--+</span><br><span class="line">    NULL   |1.|       |2.|       |2.|       |3.|</span><br><span class="line">           +--+       +--+       +--+       +--+</span><br><span class="line">           |o1|       |o2|       |on|       |o3|</span><br><span class="line">           +--+       +--+       +--+       +--+</span><br><span class="line">head                             new        tail</span><br></pre></td></tr></table></figure><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/server.h">server.h&#x2F;zskiplist</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Skiplist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Hash Tables</title>
      <link href="/2023/05/02/38e97e9bbdf0.html"/>
      <url>/2023/05/02/38e97e9bbdf0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Hash-table-定义"><a href="#Hash-table-定义" class="headerlink" title="Hash table 定义"></a>Hash table 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>     <span class="comment">/* Next entry in the same hash bucket. */</span></span><br><span class="line">    <span class="type">void</span> *metadata[];           <span class="comment">/* An arbitrary number of bytes (starting at a</span></span><br><span class="line"><span class="comment">                                 * pointer-aligned address) of size as returned</span></span><br><span class="line"><span class="comment">                                 * by dictType&#x27;s dictEntryMetadataBytes(). */</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(dict *d, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(dict *d, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(dict *d, <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*expandAllowed)(<span class="type">size_t</span> moreMem, <span class="type">double</span> usedRatio);</span><br><span class="line">    <span class="comment">/* Allow a dictEntry to carry extra caller-defined metadata.  The</span></span><br><span class="line"><span class="comment">     * extra memory is initialized to 0 when a dictEntry is allocated. */</span></span><br><span class="line">    <span class="type">size_t</span> (*dictEntryMetadataBytes)(dict *d);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    dictEntry **ht_table[<span class="number">2</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ht_used[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep small vars at end for optimal (minimal) struct padding */</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash; <span class="comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> ht_size_exp[<span class="number">2</span>]; <span class="comment">/* exponent of size. (size = 1&lt;&lt;exp) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>dictEntry.v</code>：使用 union 以支持更多具体类型，又共享 8 bytes空间。</li><li><code>dictEntry.metadata</code>：供使用方存放一些自定义数据，柔性数组，不使用时不额外占用空间。</li><li><code>dictType</code>：dict 多态能力，其中 <code>expandAllowed</code> 将是否扩容的控制权交给了使用方。</li><li><code>dict.ht_table</code>：一般只有 <code>ht_table[0]</code> 在使用，<code>ht_table[1]</code> 只在扩容时被启用。</li><li><code>dict.ht_used</code>：对应 <code>dict.ht_table</code> 存放的节点数。</li><li><code>dict.rehashidx</code>：渐进式 rehash 使用。</li><li><code>dict.pauserehash</code>：暂停 rehash，一般在开始遍历前设置，整数值表示有多少个暂停请求。</li><li><code>dict.ht_size_exp</code>：<code>dict.ht_table[N]</code> 的大小用 <code>2^dict.ht_size_exp[N]</code> 表示。</li></ul><h2 id="扩容与收缩"><a href="#扩容与收缩" class="headerlink" title="扩容与收缩"></a>扩容与收缩</h2><p><code>load factor = ht_used[N] / 2^dict.ht_size_exp[N]</code>。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>扩容条件：<code>load factor &gt;= 1</code></p><p>扩容大小：<code>dict.ht_size_exp[N] = X</code>, 其中 X 满足: <code>min(2^X) &gt;= 2 * dict.ht_used[N]</code>。</p><p><strong>Note</strong>: 在有子进程执行 <code>BGSAVE</code> 或者 <code>BGREWRITEAOF</code> 时，因为父子进程通过 <strong>COW</strong> 共享内存，为了避免内存写操作带来内存拷贝，扩容条件变为 <code>load factor &gt;= 5</code>。</p><h2 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h2><p>收缩条件：<code>load factor &lt; 0.1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收缩大小：<code>dict.ht_size_exp[N] = X</code>, 其中 X 满足: <code>min(2^X) &gt; dict.ht_used[N]</code>。</p><p><strong>Note</strong>：与扩容类似，只有在没有子进程时，收缩操作才能进行。</p><hr><p>不管是扩容还是收缩，<code>dict</code> 都会进入 rehash 状态，rehash 结束后 <code>ht_table[0]</code> 被替换成 <code>ht_table[1]</code>。</p><h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><p>为了降低扩容或收缩对性能带来的影响，<code>ht_table[0]</code> 中节点会分多次 rehash 到 <code>ht_table[1]</code> 中。</p><p>在 rehash CURD：</p><table><thead><tr><th>操作</th><th>步骤</th></tr></thead><tbody><tr><td>Add</td><td>直接写入 <code>ht_table[1]</code>。</td></tr><tr><td>Find</td><td>依次查找 <code>ht_table[0]</code> 和 <code>ht_table[1]</code>。</td></tr><tr><td>Delete</td><td>依次从 <code>ht_table[0]</code> 和 <code>ht_table[1]</code> 中删除。</td></tr><tr><td>Update</td><td>依次查找 <code>ht_table[0]</code> 和 <code>ht_table[1]</code>，然后更新 <code>v</code>。</td></tr></tbody></table><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/dict.h">dict.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Hash Tables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Doubly Linked List</title>
      <link href="/2023/05/01/22493bffd51e.html"/>
      <url>/2023/05/01/22493bffd51e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="Doubly-linked-list-定义"><a href="#Doubly-linked-list-定义" class="headerlink" title="Doubly linked list 定义"></a>Doubly linked list 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><ul><li><code>value</code>: 链表节点使用 <code>void *</code> 保存值，结合 <code>dup</code>、<code>free</code> 和 <code>match</code> 实现了对多态支持。</li><li><code>dup</code>: 拷贝 <code>value</code> 用，如果没有设置则默认浅拷贝。</li><li><code>free</code>: 回收 <code>value</code> 用，如果没有设置就不对 <code>value</code> 进行额外回收处理。</li><li><code>match</code>: 比较 <code>value</code> 和 <code>key</code> 是否相等，未设置则直接比较指针。</li></ul><p><code>list</code> 只提供双端链表的功能，具体节点值及对应的行为完全由使用方负责。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/adlist.h">sds.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> doubly linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis SDS</title>
      <link href="/2023/05/01/7287d65b6bc0.html"/>
      <url>/2023/05/01/7287d65b6bc0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Based on Redis 7.0.11.</p></blockquote><h2 id="SDS-定义"><a href="#SDS-定义" class="headerlink" title="SDS 定义"></a>SDS 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5  0   <span class="comment">// 0b0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8  1   <span class="comment">// 0b0001</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2   <span class="comment">// 0b0010</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3   <span class="comment">// 0b0011</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4   <span class="comment">// 0b0100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_MASK 7 <span class="comment">// 0b0111</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_BITS 3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>len</code>: 字节数组内容长度，不含结尾空字符 <code>\0</code>。</li><li><code>alloc</code>: 字节数组长度，不含结尾空字符 <code>\0</code>。</li><li><code>flags</code>: SDS 类型，由字节数组长度在创建 SDS 时决定，目的是节省 <code>len</code> 和 <code>alloc</code> 空间。<code>flags</code> 的 3 lsb（最低有效位）存储 <code>SDS_TYPE_N</code>，除 <code>sdshdr5</code> 将 5 msb（最高有效位）存储字节数组长度外，其余的都没具体用途。</li><li><code>buf</code>: 字节数组。柔性数组，<code>sizeof(sdshdrxx)</code> 得到的 <code>hdrlen</code> 不包含柔性数组大小。</li></ul><p><code>typedef char *sds;</code> 定义了 SDS 方法接收对象，实际上指向的是 <code>buf</code>，这样可以方便执行 <code>print(&quot;%s&quot;, sds);</code>。访问其它结构体成员时，先通过 <code>#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</code> 拿到结构体指针，再访问。</p><h2 id="相比-C-字符串优点"><a href="#相比-C-字符串优点" class="headerlink" title="相比 C 字符串优点"></a>相比 C 字符串优点</h2><ol><li><p>O(1) 复杂度计算内容长度</p></li><li><p>避免缓冲区溢出<br>比如 <code>strcat(s1, s2)</code>，如果 <code>s1</code> 和 <code>s2</code> 在内存中相邻排布：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> s1               s2</span><br><span class="line">+-+-+-+-+-+-+-+--+-+-+-+-+-+-+--+</span><br><span class="line">|A|B|C|D|E|F|G|\0|0|1|2|3|4|5|\0|</span><br><span class="line">+-+-+-+-+-+-+-+--+-+-+-+-+-+-+--+</span><br></pre></td></tr></table></figure><p><code>strcat</code> 假定 <code>s1</code> 已被分配足够内存，如果这个假定不成立，就会发生缓冲区溢出，<code>s2</code> 的内容被意外修改。</p></li><li><p>减少内存分配释放次数</p><ol><li>空间预分配。对 SDS 修改并需要拓展字节数组时，出了分配必要空间外，还会额外分配一块预留空间，预留空间大小一般与 <code>len</code> 大小一样，最大 1M（<code>#define SDS_MAX_PREALLOC (1024*1024)</code>）。</li><li>空间懒回收。当缩短 SDS 时，只会即时更新 <code>len</code>，不会立即释放多出来的空间。</li></ol></li><li><p>二进制安全。C 字符串通过 <code>\0</code> 确定字符串长度，不适用于字符串外的其它数据格式，比如图片等。SDS 通过 <code>len</code> 确定长度，理论上字节数组可以存储任意二进制内容。</p></li><li><p>兼容部分 C 字符串函数。SDS 虽然不依赖 <code>\0</code> 确定内容长度，但还是会在 <code>buf</code> 尾部加上一个 <code>\0</code>，兼容部分 C 字符串函数。</p></li></ol><p>关于 SDS 内存重新分配，核心是 <code>realloc</code> 函数：</p><blockquote><p>The <code>realloc()</code> function changes the size of the memory block pointed to by <code>ptr</code> to size bytes.  The contents will be unchanged in the range from the start of  the  region up  to  the  minimum of the old and new sizes.  If the new size is larger than the old size, the added memory will not be initialized.  If <code>ptr</code> is <code>NULL</code>, then the call is equivalent to <code>malloc(size)</code>, for all values of size; if size is equal to zero, and ptr is not <code>NULL</code>, then the call is equivalent to <code>free(ptr)</code>.  Unless <code>ptr</code> is <code>NULL</code>, it must have been returned by an earlier call to <code>malloc()</code>, <code>calloc()</code>, or <code>realloc()</code>. If the area pointed to was moved, a <code>free(ptr)</code> is done.</p></blockquote><p>简单说就是 <code>realloc</code> 完成了内存分配、内存拷贝以及内存释放等动作。</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/7.0/src/sds.h">sds.h</a></p><p><a target="_blank" rel="noopener" href="http://redisbook.com/">《Redis 设计与实现》</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SDS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Domain Driven Design》</title>
      <link href="/2023/03/02/54e349021e30.html"/>
      <url>/2023/03/02/54e349021e30.html</url>
      
        <content type="html"><![CDATA[<p>去年连着刷完了<a target="_blank" rel="noopener" href="https://item.jd.com/11961038.html">《领域驱动设计》</a>、<a target="_blank" rel="noopener" href="https://item.jd.com/11423256.html">《实现领域驱动设计》</a>和<a target="_blank" rel="noopener" href="https://item.jd.com/12447082.html">《领域驱动设计精粹》</a>，碰到一些案例讲解，走马观花就过了。春节前后两三个月（摸鱼太多）二刷《领域驱动设计》，虽然最后两章《大型结构》和《领域驱动设计的综合运用》还是没能体会透彻，但是相比第一遍时的那种朦胧感，对领域驱动设计的理解要清晰得多了。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote><p>A brief introduction to DDD from ChatGPT</p></blockquote><p>Domain-Driven Design (DDD) is a <strong>philosophy</strong> and software development <strong>methodology</strong> that aims to help teams build <em>complex</em> software solutions that closely match the domain of the problem they’re trying to solve. Instead of focusing on architecture, DDD emphasizes domain analysis, modeling, and design.</p><p>In DDD, <strong>the domain model is a central concept that represents the core of the system</strong>. It is a set of well-defined concepts, attributes, and relationships that accurately reflect the business or industry domain the software is meant to solve. A good domain model should provide a common language and understanding for everyone involved in the project, from developers to business stakeholders.</p><p>DDD is highly collaborative and relies heavily on the expertise of domain experts. Developers work closely with domain experts to identify, model, and refine the domain model over time. The use of ubiquitous language is critical to ensure clear communication and understanding of the domain model.</p><p>Some key concepts in DDD include bounded contexts, aggregates, and repositories. Bounded contexts help to define the scope of a domain, while aggregates define transactional boundaries within the domain model. Repositories help to manage the persistence of the domain model.</p><p>DDD is often used in <em>complex</em>, highly transactional systems like those found in finance, logistics, and healthcare. It can help teams build software that’s easier to maintain, understand, and extend over time.</p><p>同一个问题问 ChatGPT 多遍，每遍都会给你不一样的答案，有些回答语句精炼、逻辑清晰，有些则语焉不详、啰里八嗦，就跟本文一样。我还是觉得 ChatGPT 给我的第一个回答最棒，非常适合作为本文的大纲进行展开，可惜手残刷新后就再也没找到了。</p><p>回到这个 brief introduction，在跟 ChatGPT 极限拉扯 N 回之后，发现了个很打动我的词，相信你也看到了，就是”philosophy“，虽然后面的“methodology”也被粗体标识出来了，但相比之下略显生硬。二刷《领域驱动设计》的同时，也在看《毛泽东选集》，期间突然就觉得两本书都在揭示某些哲学思想：实践是检验真理的唯一标准，实事求是，辩证法等。</p><p>我对上面 ChatGPT 的回答不太满意的一点就是，它前后都强调 DDD 常用于“complex”的业务系统或行业领域，会让人觉得 DDD 是一套非常“重”的方案，轻易不敢在项目中实践。但是个人认为 DDD 最核心的是叫人如何认识领域，抽象问题，分离业务面与技术面，将领域知识运用到建模中，这些不管在哪种业务系统或行业领域都是适用。</p><p>好了，废话留着后面再说，进入正题。</p><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>在 DDD 中，领域模型是表达系统的核心概念。后面将讨论到的战术设计，战略设计，都离不开有效建模的领域模型。</p><p>那么要怎么理解“领域模型&#x2F;Domain model”这个词呢？</p><blockquote><p>在太多项目代码里见过 <code>models</code> 文件夹，但是里面存放的基本都是一些 POJO 或 DB schema，用途也是混乱不清，以至于很多人认为模型就是 POJO，就是 DB schema。</p></blockquote><p>一个大家都认可的事实是，软件的核心就是为用户解决某些问题的能力，而这些问题就构成了软件的领域&#x2F;domain，有的人也会说 scope。而模型就是对现实问题有选择的抽象，它对领域中的知识进行有组织地提炼，避免现实问题的复杂性造成信息过载。</p><p>《领域驱动设计》中提到有效建模的几个因素：</p><ol><li>模型和实现绑定。实现与模型脱钩会引入一个额外的翻译过程，开发人员需要不断地将模型翻译成实现，需要将实现翻译成模型并给专家解释。而新加入成员需要阅读大量文档代码才能建立起模型与实现间的映射。</li><li>建立基于模型的语言。开发人员与领域专家的沟通语言，它不是某一方的语言，而是包含了对象、操作、事件甚至组织规则。</li><li>开发蕴含丰富知识的模型。领域对象除了包含必要的数据&#x2F;属性外，还应具有动作，一些强制性业务规则和事件，这些是描述并解决领域问题不可或缺的部分。</li><li>提炼模型。随着项目发展，对领域模型的理解不断深入，新的概念加入，过时的概念被剔除，核心概念愈发凸显，甚至被提取到一个新的模型中进行表达。</li><li>头脑风暴和实验。团队讨论的创造性有助于发现隐藏概念，丰富模型。实验和口头表达则能够帮助检验模型是否清晰，模糊的模型会导致笨拙的表达。</li></ol><p>总的来说，领域建模是一个不断学习，消化知识的过程，而领域模型则需要将这些知识显式地体现出来，高效率的团队需要有意识地累积知识。</p><blockquote><p>关于表达模型的工具&#x2F;形式，其实没有特别的约束，只要能够充分地表达出模型中的概念就可以。</p></blockquote><h2 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h2><p>战略和战术分别表达“做什么”和“怎么做”的两个问题。具体到 DDD，战略设计指复杂的业务下，如何将业务划分成不同的子领域并进行集成；而战术则是在一个领域内，怎么划分和组织代码。</p><p><img src="/img/2023/ddd-building-blocks.png" alt="DDD building blocks"></p><h3 id="表达领域模型"><a href="#表达领域模型" class="headerlink" title="表达领域模型"></a>表达领域模型</h3><p>DDD 使用 <code>Entity</code>、<code>Value Object</code> 和 <code>Service</code> 表达领域模型，注意这里的 <code>Service</code> 不是传统 MVC 里包含领域逻辑的 <code>MVCService</code>（用 MVC 前缀以区别领域模型中的 <code>Service</code>）。</p><p>在传统的 MVC 模式中，model 往往被设计成面向 DB 的，DB schema 成为关注点而不是领域模型的表达；同时，model 被设计成贫血模型，那些本该在 model 中表达的操作，以过程式的方式堆在了 <code>MVCService</code> 里；再者是技术面与业务面的耦合，在表达领域概念的同时还要关心技术细节。从而在传统 MVC 的项目中很容易感受到：</p><ol><li>代码不易理解。一个完整的用户故事需要在 model 和 <code>MVCService</code> 中来回查看，业务代码被技术代码所掩藏，进一步加大难度，稍大一些的项目容易被称为“屎山”。</li><li>模型与实现脱钩。与领域专家的沟通开始困难，新成员在理解代码的同时还要学习一套与领域专家沟通的术语。迭代新功能时容易影响现有业务。</li><li>领域知识散乱。贫血模型对象需要暴露大量属性供 <code>MVCService</code> 完成业务操作，模型对象散布在各处。</li><li>单元测试难度提高。</li></ol><p>在 DDD 中，<code>Enitty</code> 和 <code>Value Object</code> 除了定义必要的属性外，上面提到的 <code>MVCService</code> 中的业务逻辑，都在 <code>Entity</code> 和 <code>Value Object</code> 上实现。这样 <code>Entity</code> 和 <code>Value Object</code> 就不再仅仅是数据容器，而是一个活生生的、有血有肉的对象了。而之前为了业务操作而暴露的属性，现在也可以设为私有了。所有的领域知识集中在一起，并且使用领域模型中的术语来命名类，属性和函数，对象，代码与领域模型关系紧密。这时候可能会惊奇地发现，针对这部分的单元测试居然可以起到一定程度的文档作用，断言规定了执行某个操作后对象应是什么状态。</p><p>再回到 <code>Entity</code> 和 <code>Value Object</code>，这两种对象的之间有什么区别呢？</p><p>《领域驱动设计》这么解释：“一个对象是用来表示某种具有连续性和标识的事物呢，还是用于描述某种状态的属性呢？这是 <code>Entity</code> 和 <code>Value Object</code> 的根本区别。”</p><p>一个 <code>Entity</code> 非常好的例子就是人，一个人不可能被他所具有的属性，比如相貌、身高、体重等唯一地确定出来，随着年岁增长，即使这些外在属性变化，但这个人还是他。所以 <code>Entity</code> 使用标识进行区分并跟踪，常见的手段就是为其分配一个 ID&#x2F;UUID。</p><p>相对地， <code>Value Object</code> 就是那些可以通过属性来唯一区分的对象，单一属性不行就多个属性。并且，因为没有标识，不需要跟踪其生命周期，所以在设计上也比 <code>Entity</code> 要简单。同时，因为只关心 <code>Value Object</code> 的属性，所以 <code>Value Object</code> 需要实现为 immutable。</p><p>一个事物被建模成 <code>Entity</code> 还是 <code>Value Object</code>，取决其是否需要标识，标识重要与否。还是用人举例子，但这次的场景是坐电梯，对于电梯是否超载这个业务规则，我们就不再关心人是谁，而是关心其体重，那么这时将人建模成 <code>Value Object</code> 是个比较好的选择。</p><p>那么 <code>Service</code> 呢？领域模型中有一些不适合由 <code>Entity</code> 或 <code>Value Object</code> 来承担的操作，因为这些操作可能涉及多个 <code>Entity</code> 或 <code>Value Object</code>。<code>Service</code> 就是被设计来处理这种场景的，它强调对象之间的关系。这里以银行转账为例，Account1 向 Account2 进行转账，一般在转账前会对双方账户进行校验，检查有足够资金支取，账户未否被冻结等一系列的业务规则，如果将这样的操作实现在 Account 对象上，那么在处理转账业务时，Account1 除了要处理自己的状态外，还要把手伸到 Account2 的口袋中去，现实中这样的行为是非常别扭的。所以将这类涉及多个对象，不适合放在对象上完成的操作转移到 <code>Service</code> 上，然后用这个操作（动词）给 <code>Service</code> 命名。</p><h4 id="领域对象生命周期"><a href="#领域对象生命周期" class="headerlink" title="领域对象生命周期"></a>领域对象生命周期</h4><div style="background:white"><p><img src="/img/2023/ddd-entity-lifecycle.svg" alt="Entity lifecycle"></p></div><p>领域对象在创建出来后会经历各种不同的状态，直到最终被存档，删除。在管理对象状态时，领域模型会遇到下面两个挑战：</p><ol><li>领域对象在整个生命周期中保证一致性，满足某种业务规则。</li><li>避免对象的创建和重建等生命周期管理的复杂性影响到领域模型。</li></ol><h5 id="Aggregate-x2F-聚合根"><a href="#Aggregate-x2F-聚合根" class="headerlink" title="Aggregate&#x2F;聚合根"></a>Aggregate&#x2F;聚合根</h5><p>大多数业务系统中的对象都具有非常复杂的关联关系，顺着关系链访问对象，会给业务造成混乱。一方面，对象间的这种关联关系属于领域知识，过于暴露会给业务方造成认知负载；另一方面，对象需要满足一定的一致性规则，过分暴露的关系模糊了一致性边界。</p><p>为了解决这个问题，DDD 使用 <code>Aggregate</code> 将一组<strong>关系紧密</strong>的 <code>Entity</code> 和 <code>Value Object</code> 聚集起来，并选择一个 <code>Entity</code> 作为 <code>Aggregate Root</code> 供业务方访问。业务方无法直接访问到除了 <code>Aggregate Root</code> 外的内部对象，需要委托 <code>Aggregate Root</code> 完成操作。<code>Aggregate Root</code> 此时便是充当了边界的作用，在此边界内任何的状态变更都会满足一致性规则要求。</p><p>那么怎么定义这个<strong>关系紧密</strong>呢？自然是通过理解领域。一般来讲，同一个 <code>Aggregate Root</code> 内的对象间满足的需要是强一致性，两种 <code>Aggregate Root</code> 之间可能并不需要时刻保持这种一致性，它们可以通过消息或其它机制实现最终一致性。那么自然的，<code>Aggregate Root</code> 指明了数据库的事务边界，同一个事务内不能同时操作两种 <code>Aggregate Root</code>。</p><p><code>Aggregate Root</code> 引伸出来的一条规则是，业务方通过 <code>Repository</code> 只能查询到 <code>Aggregate Root</code> 而不能直接查询到内部对象。</p><h5 id="Factory-pattern"><a href="#Factory-pattern" class="headerlink" title="Factory pattern"></a>Factory pattern</h5><p>DDD 引入 <code>Factory</code> 来解决 <code>Aggregate Root</code> 创建的问题。</p><p>为什么不用 <code>Aggregate Root</code> 的构造器而要借助 <code>Factory</code> 来完成创建呢？对象装配本身并不属于领域知识的一部分，它是支撑领域的一种技术细节（一些OO语言甚至没有构造器，比如 Golang），所以 <code>Aggregate Root</code> 已经承担复杂领域知识的情况下，再承担自身的装配会让 <code>Aggregate Root</code> 超载。</p><p>显然，<code>Aggregate Root</code> 的装配也不适合交由业务方完成，业务方本来只需要关心如何使用 <code>Aggregate Root</code> ，现在还要负责创建它，这会将复杂性引入到业务方，同时也破坏了 <code>Aggregate Root</code> 的封装性。</p><p>所以创建 <code>Aggregate Root</code> 的职责需要专门设计，即 <code>Factory</code>，它作为支撑领域模型的技术，与 <code>Aggregate Root</code> 同属一个代码层级，同时 <code>Factory</code> 创建出来的 <code>Aggregate Root</code> 必须满足一致性规则，否则需要拒绝创建。</p><h5 id="Repository-pattern"><a href="#Repository-pattern" class="headerlink" title="Repository pattern"></a>Repository pattern</h5><p>对象创建之后知道被删除前，要么处于 Active 状态，要么被存储在数据库或其它持久化工具里。<code>Repository</code> 这个 pattern 在很多领域都有这个概念，目的都是为了隔离具体的存储技术。在 DDD 中，为了避免以数据思维而不是领域思维保存和查询对象，还需要给 <code>Repository</code> 加上一些约束：</p><ul><li>避免随意查询 <code>Aggregate Root</code> 内部对象，这会破坏 <code>Aggregate Root</code> 的封装。</li><li>只为需要全局访问的 <code>Aggregate Root</code> 提供 <code>Repository</code>。</li></ul><p>使用 <code>Repository</code> 有这样一些优点：</p><ul><li>使应用程序和领域技术与持久化技术解耦。</li><li>体现对象的访问设计决策。</li><li>便于替换底层存储和测试。</li></ul><h3 id="Layered-Architecture"><a href="#Layered-Architecture" class="headerlink" title="Layered Architecture"></a>Layered Architecture</h3><p><img src="/img/2023/ddd-layers.png" alt="Layered architecture"></p><p>软件中用于解决领域问题的部分通常只占整个系统中较小的一部分，我们需要将领域部分代码与其它代码区分，避免在纷繁芜杂的系统中迷失了领域。DDD 也采用分层结构来分离关注点，与 MVC 不同的是，DDD 拥有一个饱满的 Domain 层用于表达领域模型：</p><table><thead><tr><th>Layer</th><th>Responsibility</th></tr></thead><tbody><tr><td>User Interface</td><td>负责向用户显示信息和解释用户指令，对于后端服务来说，这里定义了交互协议（比如 REST、RPC 或 Event 等）。</td></tr><tr><td>Application</td><td>负责编排任务，指挥领域层对象完成业务逻辑。这里编排包括开启事务，调用其它微服务以及发布订阅事件等。</td></tr><tr><td>Domain</td><td>负责表达业务概念，业务状态信息以及业务规则。</td></tr><tr><td>Infrastructure</td><td>为上层提供技术支持：为领域层提供持久化支持，为用接口层提供协议转换，为应用层传递消息等。</td></tr></tbody></table><p>下面是一个典型的 DDD 分层架构的项目目录划分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├──interface</span><br><span class="line">│    ├──controller</span><br><span class="line">│    ├──rpc</span><br><span class="line">│    └──function</span><br><span class="line">├──application</span><br><span class="line">│    ├──usecase</span><br><span class="line">│    └──service</span><br><span class="line">├──domain</span><br><span class="line">│    ├──entity</span><br><span class="line">│    ├──valueobject</span><br><span class="line">│    ├──service</span><br><span class="line">│    ├──repository</span><br><span class="line">│    └──event</span><br><span class="line">└──infrastructure</span><br><span class="line">     ├──persistence</span><br><span class="line">     ├──service</span><br><span class="line">     └──repository</span><br></pre></td></tr></table></figure><p><code>interface</code> 定义了以各种协议对外开放的接口，比如 REST、RPC 等，接收用户请求并解析出 <code>application</code> 层所需要的参数。借助框架的帮助，这一层也可以做到访问控制和参数校验。当请求进入 <code>application</code>，<code>application</code> 可能调用 <code>infrastructure</code> 开启事务或发布消息，调用 <code>repository</code> 拿到 <code>domain</code> 层的 <code>Aggregate Root</code> 执行领域逻辑，调用 <code>application service</code> 访问其它微服务，最后再调用 <code>repository</code> 保存 <code>Aggregate Root</code>。</p><p>上面目录结构中还隐藏了一些比较重要的知识点。</p><p>第一个是在 <code>domain</code> 和 <code>infrastructure</code> 中都有一个 <code>repository</code> 目录， 前者是定义了接口，后者则是基于 <code>persistence</code> 的实现。因为 <code>domain</code> 专注于表达领域模型，<code>repository</code> 的实现其实是一个技术问题，所以将实现放到 <code>infrastructure</code> 中是一个合理的决策。</p><p>第二个是，在 <code>application</code>、<code>domain</code>、<code>infrastructure</code> 中都存在一个 <code>service</code> 目录，那么它们之间有什么区别呢？</p><table><thead><tr><th>Layer</th><th>Responsibility</th></tr></thead><tbody><tr><td>application#service</td><td>调用 domain 或 infrastructure 完成功能。</td></tr><tr><td>domain#service</td><td>基于 <code>Entity</code> 和 <code>Value Object</code> 执行某种业务动作。</td></tr><tr><td>infrastructure#service</td><td>纯技术的 service，封装一些功能供上层使用。</td></tr></tbody></table><h3 id="深化领域模型"><a href="#深化领域模型" class="headerlink" title="深化领域模型"></a>深化领域模型</h3><p>领域模型的深化，本质上是知识的积累与沉淀，随着对领域知识的理解加深，我们可以突破模型表面形式，找到模型对象的深层关系，模型中的技术因素进一步被淡化，领域模型的核心概念进一步突出。以物流为例，表面上看是货物在时空上的转移，深层次上其实包含责任的转移。</p><p>为了深化模型，只能不断地学习领域知识，不断地与业务专家交流，建立起对领域的深刻理解。DDD 并没有提供具体的方法论来完成领域模型的深化，毕竟现实问题各不相同。</p><h4 id="Spcification-pattern"><a href="#Spcification-pattern" class="headerlink" title="Spcification pattern"></a>Spcification pattern</h4><p>在执行领域操作前，通常会校验一些业务规则以确保领域操作可以被执行，业务规则通常以各种布尔测试体现，比如判断发票是否过期等等。但是对于复杂的业务规则，除了简单的布尔测试外，还可能由多个规则组合，依赖其它类库、微服务的计算，如果将这部分业务规则实现在 <code>Entity</code> 或 <code>Value Object</code> 中，那么领域对象的基本含义很快就会被复杂规则计算淹没。即使规则不适合作为 <code>Entity</code> 或 <code>Value Object</code> 的职责，但它仍属于领域层。因此，引入一个特殊的 <code>Value Object</code> 对规则进行描述并测试对象是否满足指定的标准，这样的对象称为 <code>Specification</code>。</p><p><code>Specification</code> 的应用场景有：</p><ul><li>验证对象，检查它是否满足某些需求或者是否已经为实现某个目标做好准备。</li><li>从集合中选择一个对象。</li><li>指定创建新对象时必须满足的某种需求。</li></ul><p>这三种场景下，通过 <code>Specification</code> 做到了概念上的统一，简化了设计。</p><h4 id="柔性设计"><a href="#柔性设计" class="headerlink" title="柔性设计"></a>柔性设计</h4><p>柔性设计这个概念是在看书的时候第一次见，很多关于 DDD 的博客中都没有提及它。柔性设计的主要服务对象是开发人员，这里的开发人员包括调用这部分代码的客户开发人员以及将来会修改这部分开发人员，虽然脑海中会有类似的想法，但是书上这么明确提出来，给人的感觉是完全不一样，那一刻就会开发反思实际工作中那些不符合这种思想的做法。软性设计需要让开发人员乐于使用，并且易于做出修改，这样才能突破领域复杂性的限制，一旦领域有了新的变化或对领域有了新的理解，能够快速将这些变化以易于理解方式体现到代码中，并保持代码与领域模型的一致。</p><p>下面是一些可以帮助获得柔性设计的一些 pattern:</p><h5 id="Intention-Revealing-Interfaces"><a href="#Intention-Revealing-Interfaces" class="headerlink" title="Intention-Revealing Interfaces"></a>Intention-Revealing Interfaces</h5><p>在命名类和操作时要描述它们的效果和目的，而不是表露它们是通过何种方式达到目的的。如果开发人员为了使用一个组件而必须要去研究它的实现，那么就失去了封装的价值。避免用文档的方式说明，文档和实际行为之前没有强制绑定关系，拙略的文档或过时的文档反而会误导读者。</p><h5 id="Side-Effect-Free-Function"><a href="#Side-Effect-Free-Function" class="headerlink" title="Side-Effect Free Function"></a>Side-Effect Free Function</h5><p>尽可能将程序逻辑放到函数中，因为函数是指返回结果而不产生副作用的操作。尽量把命令隔离到不返回领域信息的简单操作中。</p><blockquote><p>操作可以宽泛的分为“命令”和“查询”，命令会引起状态变化产生副作用，而查询只是获取数据或者执行计算并拿到结果。</p></blockquote><p>这里要说一下函数和方法的区别，函数是一段执行特定计算功能的程序，可以传递参数和返回计算结果（也可以没有）。方法类似，但是方法需要由一个显式声明的上下文调用，比如面向对象中的 <code>this</code>。一个比较好的例子是 Golang，当在 VSCode 中输入 <code>func</code> 和 <code>meth</code> 时，自动生成的代码是不一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// snippet for func</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snippet for meth</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver <span class="keyword">type</span>)</span></span> method()  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Assertion"><a href="#Assertion" class="headerlink" title="Assertion"></a>Assertion</h5><p>在操作（副作用）之后通过断言描述预期的状态，帮助开发人员更准确地预测对象的行为。对于不支持断言的语言，可以在单元测试中实现。</p><h5 id="Conceptual-Contour"><a href="#Conceptual-Contour" class="headerlink" title="Conceptual Contour"></a>Conceptual Contour</h5><p>随着代码不断适应新的概念或需求，模型中的多个部分可能与领域的某一方面吻合，这时需要重构模型将这个隐藏概念显式地表达出来。当连续重构都只对模型产生小范围改动，这就是模型与领域相吻合的信号。</p><h5 id="Standalone-Class"><a href="#Standalone-Class" class="headerlink" title="Standalone Class"></a>Standalone Class</h5><p>Standalone class 是低耦合的一个极端例子，它强调将对象中所有无关概念剔除，使对象可以独立被理解，使用和测试。我理解并不是说不能有任何依赖，而是尽量减少各种有意义的概念上的依赖，降低认知负担。</p><h5 id="Closure-Of-Operation"><a href="#Closure-Of-Operation" class="headerlink" title="Closure Of Operation"></a>Closure Of Operation</h5><blockquote><p>其实没有太理解这个 pattern 的优点</p></blockquote><p>定义操作时让它的返回值与参数类型相同，如果实现者的状态在计算中被用到，这个实现者实际上也是参数。这种 pattern 可以避免引入新的依赖，始终在同一个概念子集中进行思考。</p><h4 id="通过重构得到深层理解"><a href="#通过重构得到深层理解" class="headerlink" title="通过重构得到深层理解"></a>通过重构得到深层理解</h4><p>DDD 对于重构的观点始终围绕着领域模型的表达。</p><ul><li>即使代码看上去很整洁的时候也可能需要重构，原因是语言没有与领域专家保持一致，或者新需求不能被自然地添加到模型中。</li><li>重构可能来自学习，开发人员通过学习获得了对领域更深刻的理解。</li><li>维持拙劣的设计本身就是一种风险，迁就这种设计也是需要付出代价的。</li><li>借鉴经验，比如《分析模式》。</li></ul><h2 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h2><p>2003 年提出的 DDD 在近几年重新进入人们视野，很大程度上是因为 DDD 对领域的划分与微服务架构设计在本质上都是分解大型系统，使之更易于理解、管理的手段。具体到 DDD 战略设计，其实就是关于模型拆解，子系统集成以及模型精炼的问题。</p><p><img src="/img/2023/ddd-integrality.jpeg" alt="DDD integrity"></p><p>大型系统使用单一领域模型可能遇到的问题：</p><ol><li>协调成本过大。大型系统通常由多个团队一起合作开发，随着团队数量增加，协调成本呈指数级增长。</li><li>为满足所有团队的需求，会导致模型包含负责的设计决策。</li><li>不同团队关注模型概念的不同方面，单一领域模型会导致信息过载。</li><li>团队职责边界模糊，权利和组织管理上的因素也会要求模型分开。</li></ol><p>自然地，大型系统中就会出现多个小模型以支撑整个系统的实现。</p><h3 id="Bounded-Context"><a href="#Bounded-Context" class="headerlink" title="Bounded Context"></a>Bounded Context</h3><p>大型系统中的小模型都有各自针对的，需要解决的问题场景，或者叫 Bounded Context（限界上下文）。这个上下文就是模型中术语具有特定含义而必须要应用的一组条件，脱离这个上下文，模型也就变得毫无意义了。在这个上下文边界内，模型不需要考虑其是不是适用于边界之外的情况。边界的划分，通常是由团队组织结构，软件系统的各个部分用法以及物理实现（代码和数据库 schema）决定的。</p><p>Bounded Context 与子模型是<strong>一对多</strong>的，即一个 Bounded Context 中可能有多个团队在维护多个模型，但一般建议保持一对一的关系以减少不同团队之间的摩擦。</p><h4 id="Continuous-Integration"><a href="#Continuous-Integration" class="headerlink" title="Continuous Integration"></a>Continuous Integration</h4><p>多人同时在同一个 Bounded Context 中工作时，模型可能因为不同人的理解而发生分裂，团队规模越大，分裂可能性越大。通过持续集成将同一个上下文中的变更足够频繁地合并到一起，可以避免模型发生分裂，使所有人对模型都能达成一致共识。</p><h3 id="Context-Map"><a href="#Context-Map" class="headerlink" title="Context Map"></a>Context Map</h3><p>Bounded Context 将系统划分成多个小规模的系统和上下文，最后还要将不同的 Bounded Context 集成构成完整的系统。不同 Bounded Context 集成时，它们的边界可能会各种可能的原因变得模糊，导致 Bounded Context 边界外的概念泄漏到 Context 内，由于同一个术语在不同 Context 下的含义可能大不相同，久而久之当前 Context 变得混乱。</p><p>Context Map 是 Bounded Context 边界上的概念，它描述模型之间的联系点，明确所有的通信需要的转换，并突出任何共享的内容，维护清晰的边界。</p><h4 id="Shared-Kernel"><a href="#Shared-Kernel" class="headerlink" title="Shared Kernel"></a>Shared Kernel</h4><p><img src="/img/2023/ddd-sharedkernel.png" alt="Shared Kernel"></p><p>从领域模型中挑选出两个团队都同意共享的一个子集，同时包括对应的代码实现和数据库设计。这部分内容任何一方不得擅自更改，同时要经常进行集成。Shared Kernel 通过共享减少了两个 Bounded Context 之间的部分重叠，使两个 Context 的集成变得相对容易，因为减少了部分转换工作。</p><p>因为共享部分的更改受到限制，所以只有在两个紧密合作的团队见才比较适合使用 Shared Kernel 方式合作。</p><h4 id="Customer-x2F-Supplier"><a href="#Customer-x2F-Supplier" class="headerlink" title="Customer&#x2F;Supplier"></a>Customer&#x2F;Supplier</h4><p>当两个 Bounded Context 之间存在单向依赖时，两个团队间可能采用 Customer&#x2F;Supplier 这种合作模式。Customer&#x2F;Supplier 在两个团队间建立一种明确的客户&#x2F;供应商关系，上游团队根据下游团队的需求来安排任务，下游团队与上游团队共同开发测试套件，保证上游团队在修改时不必担心破坏下游团队的工作。</p><p>由于上游团队有多个下游团队客户，有些影响力大的下游团队有可能挤压影响力小的下游团队的需求，同时下游团队的需求可能得不到上游团队的及时支持。</p><h4 id="Conformist"><a href="#Conformist" class="headerlink" title="Conformist"></a>Conformist</h4><p>当两个团队具有 Customer&#x2F;Supplier 关系时，上游团队可能没有动力来支持下游团队的需求。这时下游团队有两种选择：</p><ol><li>完全放弃对上游团队的依赖，下游团队走上 Separate Way 的道路。</li><li>如果对上游团队的依赖还具有价值或者管理决策要求，下游团队还有两种做法：<ol><li>上游团队软件设计一般，下游团队仍需开发自己的模型并完成模型映射（Anti-Corruption Layer）。</li><li>上游团队软件设计凑活能用，风格能兼容需求，下游团队则采用 Confirmist 模式。</li></ol></li></ol><p>采用 Conformist 模式可以极大地简化集成。但是由于需要追随上游团队的设计，下游团队的设计受到限制，并且没法得到理想的领域模型。</p><h4 id="Separate-Ways"><a href="#Separate-Ways" class="headerlink" title="Separate Ways"></a>Separate Ways</h4><p>当两个团队间不存在依赖关系或这种关系被消除时可以采用这种模式，这时候两个团队之间也没有集成的问题了。</p><h4 id="Anti-Corruption-Layer"><a href="#Anti-Corruption-Layer" class="headerlink" title="Anti-Corruption Layer"></a>Anti-Corruption Layer</h4><p><img src="/img/2023/ddd-anti-corruption.png" alt="Anti-Corruption Layer"></p><p>Anti-Corruption Layer 是连接两个 Bounded Context 的一种隔离层，这个隔离层内封装了两个 Bounded Context 之间的映射，下游团队根据自己的需求定义 Anti-Corruption Layer 的接口，内部将输入转换后再与上游团队对话。</p><p>Anti-Corruption Layer 的公共接口通常以一组 Service 的形式出现，这些 Service 通常被实现为 Facade、Adapter 和 Translator 的组合（如图所示），其中：</p><ul><li>Facade。对子系统访问的可替换接口，严格按照子系统的领域模型实现。</li><li>Adapter。将调用者请求转换成子系统可理解的请求和将子系统的响应转换成调用者要求的对象。</li><li>Translator。服务于 Adapter，为其完成一些对象、数据的转换工作。</li></ul><h3 id="Core-Domain"><a href="#Core-Domain" class="headerlink" title="Core Domain"></a>Core Domain</h3><p>TODO</p><h2 id="Key-takeaways"><a href="#Key-takeaways" class="headerlink" title="Key takeaways"></a>Key takeaways</h2><blockquote><p>建议先看领域驱动设计精粹，非常精悍的一本小书</p></blockquote><p><a target="_blank" rel="noopener" href="https://item.jd.com/12447082.html">《领域驱动设计精粹》</a></p><p><a target="_blank" rel="noopener" href="https://item.jd.com/11961038.html">《领域驱动设计》</a></p><p><a target="_blank" rel="noopener" href="https://item.jd.com/11423256.html">《实现领域驱动设计》</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《小狗钱钱》by Bodo Schafer</title>
      <link href="/2022/05/04/8b4e76905052.html"/>
      <url>/2022/05/04/8b4e76905052.html</url>
      
        <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在《无人知晓》第三期播客《孟岩对话张奔斗》中，奔斗老师提到在投资相关的书籍挑选上，他取了多个书单中都推荐的那部分。所以我就写了<a target="_blank" rel="noopener" href="https://github.com/clsrfish/invest">这个</a>小程序去统计推荐率比较高的书籍。在16篇推荐投资书籍的文章中，排名前几的有这些：</p><table><thead><tr><th>书名</th><th>推荐分&#x2F;16</th></tr></thead><tbody><tr><td>小狗钱钱</td><td>11</td></tr><tr><td>聪明的投资者</td><td>9</td></tr><tr><td>富爸爸，穷爸爸</td><td>9</td></tr><tr><td>漫步华尔街</td><td>8</td></tr><tr><td>证券分析</td><td>6</td></tr><tr><td>股票作手回忆录</td><td>6</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>正如你所见，我们在网上搜到的大部分投资理财书籍相关文章都会推荐《小狗钱钱》。</p><blockquote><p>《小狗钱钱》还有第二册，与第一册培养财商不一样，第二册着重于待人接物上。</p></blockquote><h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2><p>《小狗钱钱》讲述了一个小女孩吉娅和她的小狗钱钱的故事。一次偶然的情况下，吉娅救下了受伤的小狗钱钱，可是，正是这只小狗，改变了吉娅和她家人们的生活。吉娅家刚刚换完房子，爸爸的生意却突然遇冷，全家经济变得紧张了，吉娅的一些愿望也变得更加遥远了。在钱钱的帮助下，吉娅订立自己的梦想相册和梦想储蓄罐，利用空余时间工作增加零花钱收入。同时在金先生、陶穆太太等人的帮助下学习了越来越多的理财知识。最终呢，吉娅达成了自己的愿望，家里的财务问题也得倒了解决。</p><p>《小狗钱钱》本来是为小朋友培养财商的童话书，但却在成人中的反响更好，有意思。虽然书中故事与我们现实生活有一定距离，但正是这种距离感，我们能免于被吉娅所面临的忧虑困扰，这种情况下我们也能更加轻松地审视自己的过往。</p><p>这本书不是专业的投资理财书籍，但是我们从</p><h2 id="精句摘抄"><a href="#精句摘抄" class="headerlink" title="精句摘抄"></a>精句摘抄</h2><p>如果你想富有，请把自己变成一个小孩。因为小孩子的框框最少，他们城市、快乐、乐于学习。</p><p>认为我们必须忍受拮据的生活，甚至认为这样才是高尚的 —— 这种想法是人类犯下的最重大的错误之一。</p><p>过于复杂的叙述有偏离本质的危险，描述基本的事实时同样也存在一种危险。我们常常会过于迅速地得出结论：“这我已经知道了。”似乎认识几个关键词就足够了。这种想法很可能是一个陷阱，因为当我们发现对要学的东西早已熟悉时，可能就不会继续学习下去。</p><p>广为流传的错误观点 —— 人们只能通过多年艰苦的工作才能实现富裕。</p><p>我也不认为钱是人一生中最重要的东西。可是假如我们缺钱的话，钱就会变得格外重要。</p><p>真正付诸实践要比纯粹的思考有用多了。</p><p>支出永远是随着我们的收入而增长的。</p><p>大多数人生来并没有“鹅”。这就是说，他们的钱不足以让他们依靠利息来生活。</p><p>应该给孩子们提供机会，让他们能够多接触一下成年人的工作领域。</p><p>对“儿童”这个概念的解读 可能明显低估了孩子们的学习技能和从事商业活动的潜力。</p><h2 id="财富法则"><a href="#财富法则" class="headerlink" title="财富法则"></a>财富法则</h2><ol><li>一开始，必须明确金钱对你的意义。</li><li>确立最重要的目标。为什么我们必须特别强调在我们“长长的愿望清单中”的某几个目标？</li><li>为什么梦想储蓄罐和梦想相册很重要?我们的潜意识如何支持着我们？我们为此需满足哪些前提条件？</li><li>为什么仅有较高的收入绝不可能解决我们的财务难题？</li><li>如何使我们不放弃已经作出的决定——想象的艺术。</li><li>总会有一些人想要阻止我们实现自己的目标，阻力甚至经常来自我们的亲戚朋友，但还是有一些不让自己迷失的方法。</li><li>为什么一本成功日记能促使我们的收入不断地增加？为什么自信是最关键的因素？</li><li>人们如何将自己最大的爱好作为职业，并由此再次大幅度提高自己的收入？</li><li>重要性和紧迫性之间有什么区别？如何保证在任何情况下都不偏离制订的目标？</li><li>付诸实施的关键：72小时规定。</li><li>如何以轻松的方式挣到许多钱？</li><li>关于如何处理债务的4个忠告。<ol><li>毁掉所有信用卡。</li><li>尽可能少地偿还贷款，拉长还贷周期。</li><li>不用于生活的钱一半存起来，一半用于偿还贷款。</li><li>这真的有必要吗？</li></ol></li><li>一只下金蛋的鹅的故事 ——人们如何量入为出。</li><li>如何正确使用银行并使之成为一种乐趣？</li><li>幸福的本质以及我们如何才能获得更多的幸福。</li><li>爱钱有什么不对吗?保险箱里留多少现金比较合适？</li><li>“金钱是‘中性’的”指的是什么意思?钱与幸福之间有什么联系？</li><li>归还我们的一部分所得是十分重要的（做慈善和公益事业）。</li><li>对待恐惧的最佳方式。成功日记所起的作用。</li><li>增加金钱的最有效途径之一：投资俱乐部。保证成功的5条规定。</li><li>白手起家的魔法。</li><li>适用于所有投资的3条最重要的规定。</li><li>什么是股票？股票是如何运作的？收益是如何产生的？你是否适合股票投资？</li><li>为什么偶尔放弃熟悉的环境、从事我们畏惧的事情很重要？</li><li>怎样确保每年获得12%以上的利息？近乎完美的投资形式和投资战略是什么？</li><li>为什么股票基金是保险的，而且可以为你带来丰厚的利润？挑选保险的基金的3个注意事项。<ol><li>基金至少有10年历史。经历牛熊周期。</li><li>选择大型的跨国股票基金。</li><li>比较基金走势图，择优。</li></ol></li><li>投资基金为什么很简单？</li><li>在投资基金的情况下，你的钱变成了什么——利滚利的力量。</li><li>浮动利率：如何平衡风险和赢利。</li><li>如何轻松地计算利息与复利？</li><li>72公式：用72除以你们投资的年利润百分比，得出的数字就是这 笔钱翻一倍所要的年数。</li><li>当汇率下跌时应当做什么？如何在这种情况下获得高额利润？</li><li>用基金获得可靠的高利润的前提。</li><li>通货膨胀的真正含义以及如何轻松计算出它对财产的影响。如何使通货膨胀成为你最好的朋友——当你正确选择投资对象时。</li><li>金钱对我们生活中的其他领域会产生什么影响？当我们更多地研究金钱这个题目时，将会发生怎样的变化？</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1095634/">https://book.douban.com/subject/1095634/</a></p><p><a target="_blank" rel="noopener" href="https://github.com/clsrfish/invest">https://github.com/clsrfish/invest</a></p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Financial&amp;Investment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 资源路径优化</title>
      <link href="/2022/03/26/4e992231543c.html"/>
      <url>/2022/03/26/4e992231543c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>What’s <a target="_blank" rel="noopener" href="https://hexo.io/">hexo</a></strong>? <br/><br>Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other markup languages) and Hexo generates static files with a beautiful theme in seconds.</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在开始用 Hexo 写博客之后，就一直被它引用图片的方式所困扰。就是必须以 <code>source</code> 为根目录的方式引用，比方说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── source</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   │   └── helloworld.md</span><br><span class="line">│   └── img</span><br><span class="line">│       └── cover.jpg</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>在 <code>helloworld.md</code> 里需要通过 <code>![alt txt](/img/cover.jpg)</code> 来引用 <code>cover.jpg</code>，否则编译出的 html 就无法显示图片。而在编辑器内我更习惯 <code>../img/cover.jpg</code> 的方式饮用图片。</p><p>Hexo 的引用方式会导致编辑器内预览时无法显示图片，而且这种引用方式也不符合直觉，不直观。Hexo 引用图片方式还有一个问题就是，以后切换到其它写作平台时可能需要逐一修改图片路径。</p><p>Hexo 大概想让用户直接通过 <code>hexo server</code> 预览，其他人不知道，反正我不喜欢预览还要切换到浏览器。</p><h2 id="自己动手"><a href="#自己动手" class="headerlink" title="自己动手"></a>自己动手</h2><p>现在的问题就是把写作时更加习惯的相对路径，在编译前替换成 Hexo 所支持的绝对路径。在 Github 上找了一圈没有找到支，所以就自己撸一个吧。</p><p>Hexo 提供的 <a target="_blank" rel="noopener" href="https://hexo.io/api/filter">Filter</a> 让我们有机会在 Hexo 处理数据前对数据进行修改，这里的数据可能是 md 文件，也可能是其它文件。</p><p>不通类型的 Filter 在不同阶段执行，这里可以选择 <code>before_post_render</code> 在 md 文件编译成 html 之前进行处理。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>下面直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> imageReg = <span class="regexp">/!\[(?&lt;alt&gt;[^\]]*)\]\((?&lt;url&gt;.*?)(?=\&quot;|\))(?&lt;title&gt;\&quot;.*\&quot;)?\)/g</span>;</span><br><span class="line"><span class="keyword">let</span> cwd = process.<span class="title function_">cwd</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hexo_img_locator = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> postPath = data.<span class="property">full_source</span>;</span><br><span class="line">    <span class="keyword">if</span> (!postPath.<span class="title function_">endsWith</span>(<span class="string">&#x27;.md&#x27;</span>)) &#123;</span><br><span class="line">        <span class="title function_">printInfo</span>(<span class="string">`skip <span class="subst">$&#123;postPath&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mapping = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> cannotAccess = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> match = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((match = imageReg.<span class="title function_">exec</span>(data.<span class="property">content</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> imageUrl = match.<span class="property">groups</span>.<span class="property">url</span>;</span><br><span class="line">        <span class="comment">// skip online image and local file with absolute path</span></span><br><span class="line">        <span class="keyword">if</span> (imageUrl.<span class="title function_">startsWith</span>(<span class="string">&#x27;http://&#x27;</span>)</span><br><span class="line">            || imageUrl.<span class="title function_">startsWith</span>(<span class="string">&#x27;https://&#x27;</span>)</span><br><span class="line">            || imageUrl.<span class="title function_">startsWith</span>(<span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> imageAbsPath = path.<span class="title function_">resolve</span>(path.<span class="title function_">dirname</span>(postPath), imageUrl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(imageAbsPath)) &#123;</span><br><span class="line">            cannotAccess.<span class="title function_">push</span>(imageUrl);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cannotAccess.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// no need process any more</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> imageAbsPathFromSource = path.<span class="property">sep</span> + path.<span class="title function_">relative</span>(<span class="string">`<span class="subst">$&#123;cwd&#125;</span><span class="subst">$&#123;path.sep&#125;</span>source`</span>, imageAbsPath);</span><br><span class="line">        <span class="keyword">let</span> imageDirective = match[<span class="number">0</span>];</span><br><span class="line">        mapping.<span class="title function_">set</span>(imageDirective,</span><br><span class="line">            imageDirective.<span class="title function_">replace</span>(imageUrl, imageAbsPathFromSource));</span><br><span class="line">        <span class="title function_">printInfo</span>(<span class="string">`[hexo-img-locator] <span class="subst">$&#123;imageUrl&#125;</span> -&gt; <span class="subst">$&#123;imageAbsPathFromSource&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cannotAccess.<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">printError</span>(<span class="string">`[hexo-img-locator] cannot access <span class="subst">$&#123;cannotAccess[<span class="number">0</span>]&#125;</span> and other <span class="subst">$&#123;cannotAccess.length - <span class="number">1</span>&#125;</span> from <span class="subst">$&#123;path.relative(cwd, data.full_source)&#125;</span>, file not found.`</span>)</span><br><span class="line">        process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mapping.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, k, map</span>) =&gt;</span> &#123;</span><br><span class="line">        data.<span class="property">content</span> = data.<span class="property">content</span>.<span class="title function_">replace</span>(k, v);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, hexo_img_locator);</span><br></pre></td></tr></table></figure><p>这段代码做了两件事：</p><ul><li>使用正则匹配所有图片指令</li><li>将图片指令中的路径替换成 Hexo 支持的路径</li></ul><p>然后将 Filter 发布到 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/hexo-img-locator">npm</a>。</p><h2 id="待改进"><a href="#待改进" class="headerlink" title="待改进"></a>待改进</h2><p>正则匹配会无脑匹配，也就是说代码块中的 <code>![alt](/xxx)</code> 也会被匹配，产生不符合预期的行为。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://hexo.io/api/filter">https://hexo.io/api/filter</a></p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《MapReduce: Simplified Data Processing on Large Clusters》</title>
      <link href="/2022/03/20/fbaf110dc90c.html"/>
      <url>/2022/03/20/fbaf110dc90c.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-MapReduce"><a href="#什么是-MapReduce" class="headerlink" title="什么是 MapReduce"></a>什么是 MapReduce</h2><p>MapReduce 是一种<strong>通用的编程模型</strong>，应用并行在计算机集群上完成大数据处理&#x2F;计算任务。Google 在 2003 年发表了 《MapReduce: Simplified Data Processing on Large Clusters》，向业界介绍了 MapReduce 编程模型，MapReduce 与 GFS（MIT 6.824 Lec 3）、BigTable 并称为 Google 的“三驾马车”，支撑了 Google 众多计算任务，比如分词、倒排索引等。</p><p>MapReduce 出现之前，这些计算任务都需要处理大量输入、计算节点管理以及容错，处理这些问题的代码反而比实际计算任务的更多，即使这些计算操作通常并不复杂。受 Lisp 等函数式编程语言的 <em>map</em> 和 <em>reduce</em> 原语启发，Google 想到了将计算任务整体划分成 <em>map</em> 和<em>reduce</em> 两个阶段，简化计算模型，同时对计算逻辑隐藏并行、容错、复杂均衡等的复杂性。</p><p>不过 Google 并没有开源他们的 MapReduce 实现，幸运的是 Hadoop 项目提供了 MapReduce 的开源实现。</p><h2 id="编程模型-x2F-范式"><a href="#编程模型-x2F-范式" class="headerlink" title="编程模型&#x2F;范式"></a>编程模型&#x2F;范式</h2><p>MapReduce 模型下计算任务的输入输出都是 key&#x2F;value，用户将计算逻辑用 <em>map</em> 和 <em>reduce</em> 表达。其中 map 输出的中间结果（也是 key&#x2F;value）将写入磁盘，作为后续 reduce 的输入，reduce 再将中间结果进行合并处理，并将最终结果写入磁盘。</p><p>下面看看以 word-count 为例的伪代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">map</span>(<span class="built_in">string</span> key, <span class="built_in">string</span> value):</span><br><span class="line">    <span class="comment">// key: document name</span></span><br><span class="line">    <span class="comment">// value: document contents</span></span><br><span class="line">    <span class="keyword">for</span> each w <span class="keyword">in</span> <span class="attr">value</span>:</span><br><span class="line">        <span class="title function_">emitIntermediate</span>(w, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">reduce</span>(<span class="built_in">string</span> key, <span class="title class_">List</span>&lt;<span class="built_in">string</span>&gt; values):</span><br><span class="line">    <span class="comment">// key: a word</span></span><br><span class="line">    <span class="comment">// values: a list of counts</span></span><br><span class="line">    int result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each v <span class="keyword">in</span> <span class="attr">values</span>:</span><br><span class="line">        result += v</span><br><span class="line">    <span class="title function_">emit</span>(result.<span class="title function_">toString</span>())</span><br></pre></td></tr></table></figure><p>没有特殊要求，用户就只需要实现类似上面两个函数。计算过程中的数据类型转换如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map     (k1, v1)            -&gt; list(k2, v2)</span><br><span class="line">reduce  (k2, list(v2))      -&gt; list(v2)</span><br></pre></td></tr></table></figure><blockquote><p>理论上 kx 和 vx 可以是任意类型。</p></blockquote><p>通过这种简单的计算模型，用户能够像在单机上的计算一样，关注计算逻辑。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/img/2022/execution_overview.jpg" alt="Execution overview"></p><p>MapReduce 架构设计了一个 Master 对任务进行管理，多个 Worker 执行相应的 Map 或 Reduce 函数（统称为任务），Master 与 Worker 中间通过 Http&#x2F;RPC 交互。</p><p>一个完整任务执行过程如下：</p><ol><li>MapReduce（与用户代码编译好的可执行文件） 首先会将输入文件划分成 M 份（大小通常是 16~64M），然后在集群中启动 MapReduce 程序。</li><li>集群中某一台机器将被指定为 Master，其余的是 Worker，并切等待 Master 分配任务。刚开始有 M 个 Map 任务和 R 个 Reduce 任务需要进行分配，Master 会挑选空闲的 Worker 分配一个任务（Map 或者 Reduce）。</li><li>被分配到 Map 的 Worker 读入对应的输入，解析出 key&#x2F;value 并传递给用户实现的 Map 函数，Map 函数产生的中间结果暂时存在内存里。</li><li>Map 函数计算结果会周期性地写入 R 个本地文件，其中分区规则由分区函数决定（可定制）。然后这些本地文件的位置在 Map 任务执行完时发送给 Master，Master 然后把这些文件传递给执行 Reduce 任务的 Worker。注意，Reduce 的输入来自每一个 Map 的输出，同时 key 相同的中间结果不会同时被多个 Reduce 接收到。</li><li>当 Master 通知 Reduce Worker 中间结果的位置后，Worker 通过 RPC 读取对应的 Map Worker 的本地文件。等所有中间结果读取完毕后，Reduce Worker 会对中间结果按照 key 进行排序，以便相同 key 的中间结果会聚集在一起。</li><li>Reduce Worker 然后遍历中间结果，将相同 key 的数据集传递给用户编写的 Reduce 函数。Reduce 函数的输出结果会 append 到输出文件。</li><li>所有 Map Task 和 Reduce Task 完成后，Master 会回到用户代码（这里没太懂，大概就是通知用户执行结果吧）。</li></ol><h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>MapReduce 被设计运行在廉价的机器上，机器的 failure 被当作 norm 而不是 exception，比如 Worker 宕机。</p><h4 id="Worker-异常"><a href="#Worker-异常" class="headerlink" title="Worker 异常"></a>Worker 异常</h4><p>启动后 Master 会定时 ping Worker，如果 Worker 没有在规定时间响应，该 Worker 会被判定为 ‘failed’。同时，针对 Worker 执行的任务，有如下两种处理：</p><ul><li>如果 Map 任务完成，该任务被重新标记成 ‘idle’，以便分配给其它 Worker。至于为什么完成了还要重置，这是因为计算的中间结果是直接存在 Worker 的本地磁盘的，既然 Worker ping 不通，那么接下来的 Reduce 任务自然也无法从 Map Worker 上读取输入。同时，对应从该 Worker 获取输入的 Reduce Workers 也被通知重新执行任务。</li><li>如果 Map 或 Reduce 任务正在执行，该任务被重新标记成 ‘idle’，以便分配给其它 Worker。</li></ul><p>Worker 在整个任务结束之前，都必须与 Master 保持通信，不然就会被判定成 failed，导致任务重试&#x2F;重分配。</p><h4 id="Master-异常"><a href="#Master-异常" class="headerlink" title="Master 异常"></a>Master 异常</h4><p>Master 异常处理相比就简单直接一点了，周期性地将状态生成 checkpoint&#x2F;序列化，Master 挂掉了就在管理台上通知用户，用户重试就可以了。重试的任务会尝试从磁盘取回之前的状态，避免重复计算。</p><h4 id="失败时的语义"><a href="#失败时的语义" class="headerlink" title="失败时的语义"></a>失败时的语义</h4><p>原文的描述没怎么看懂，我理解就是如果 Reduce 函数是纯函数，那么语义是确定，同样的输入，多次执行结果总是和串行计算的结果相同。</p><p>下面是原文:</p><blockquote><p>In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program. However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.</p></blockquote><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>虽然<a href="#%E6%9E%B6%E6%9E%84">上面</a>描述了一个任务执行过程的理论模型，但如果完全按照理论模型落地，还存在一定性能瓶颈，比如网络IO等。</p><h4 id="输入文件IO"><a href="#输入文件IO" class="headerlink" title="输入文件IO"></a>输入文件IO</h4><p>Map Worker 会从 GFS 读取输入文件，这里就引入了一次网络 IO，特别是在 03 年的网络设施性能相对较差的情况下，光是读取输入文件就要费老鼻子劲。GFS 将文件存储在 chunkserver 上，Master 分配任务时，会根据输入文件的位置，尽量将任务分配到输入文件所在的 chunkserver 对应的 Worker 上，从而避免一次网络 IO。</p><h4 id="后备任务"><a href="#后备任务" class="headerlink" title="后备任务"></a>后备任务</h4><p>导致 MapReduce 任务总耗时增加的最普遍的原因是 “straggler”，也就是最后一些未完成的任务因为某些原因执行了非常久，比如 CPU 负载、网络 IO 拥挤等。Google 采用了一个非常简单的机制，减缓这种任务对耗时的影响 —— 在只剩少量任务未完成时，启动一些后备任务同时执行计算，这些后备任务和原任务最先完成的就能将对应标记为完成。</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>Reduce Task 中的排序保证不用把所有不同的 key 数据读入内存处理，更重要的一点是如何在不全部读入内存的情况下对中间结果进行排序。</p><p>Map Task 在输入中间结果时，并不是直接写入磁盘，而是写入一个 RingBuffer，写满时就会将 Buffer 写入磁盘，在此之前会对中间结果进行<strong>快速排序</strong>；等 Map Task 结束时，多次写入磁盘的结果最终会进行<strong>归并排序</strong>，得到 Map Task 的最终结果。</p><p>Reduce Task 从多个 Map Worker 读取到中间结果后，也会进行一个<strong>归并排序</strong>，得到 Reduce 函数的输入。</p><p>所以<strong>整个计算过程有三个排序操作</strong>。</p><h4 id="Combiner-Function"><a href="#Combiner-Function" class="headerlink" title="Combiner Function"></a>Combiner Function</h4><p>Paper 里对 Combiner Functin 的描述是 “in some cases”，也就是这个东西不是一个普适的优化。以 Word-Count 为例，在 Map Task 结束前进行一次计算，即对当前 Map Task 的输出进行一次 Reduce 操作，减少后面网络 IO 耗时。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf">https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf</a></p><p><a target="_blank" rel="noopener" href="https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html">https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html</a></p><p><a target="_blank" rel="noopener" href="https://www.talend.com/resources/what-is-mapreduce/">https://www.talend.com/resources/what-is-mapreduce/</a></p><p><a target="_blank" rel="noopener" href="https://www.guru99.com/introduction-to-mapreduce.html">https://www.guru99.com/introduction-to-mapreduce.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper </tag>
            
            <tag> Distributed System </tag>
            
            <tag> MIT 6.824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Plugin 学习</title>
      <link href="/2022/03/12/3f3f9f27edb1.html"/>
      <url>/2022/03/12/3f3f9f27edb1.html</url>
      
        <content type="html"><![CDATA[<p>最近在做 MIT 6.824 Lab 1 的时候发现提供的代码中用到了 Go 的插件系统，所以就趁着这个机会简单学习了一下 Go plugin package。</p><h2 id="静态链接库与动态链接库"><a href="#静态链接库与动态链接库" class="headerlink" title="静态链接库与动态链接库"></a>静态链接库与动态链接库</h2><p>写过 C&#x2F;C++ 的应该对这个非常熟悉，不是编译时遇到 <strong>ld fail</strong>，就是运行时遇到 <strong>dyld fail</strong>，ld 和 dyld 就分别对应了静态链接和动态链接过程。那静态链接与动态链接有什么差异，各自又有什么优缺点呢？</p><p>首先不管是静态链接库还是动态链接库，它们都是由程序依赖的外部函数、变量（统称 symbol）组成。静态链接时，链接器（ld）将程序和静态库打包到一个可执行文件，同时将 symbol 解析成对应的地址（address），这个可执行文件可以单独运行；相反地，动态链接就是不把动态库和程序打包成一个可执行文件，将 symbol 的解析延迟到运行时，再由 dyld 完成 symbol 到 address 的解析，不过需要提供动态库才可以运行程序。</p><p>对应的优缺点也非常明显了，首先静态链接会把静态库和程序打包成一个可执行文件，产物体积相对较大，且相同的静态库代码不同进程之间无法共享，内存占用较高；好处是可执行文件可以单独运行，部署方便。动态链接的 symbol 解析过程在运行时发生，所以可以实现一些<strong>热插拔</strong>功能，同时多个进程之间共享可以同一动态库，降低了内存占用；但是维护麻烦，symbol 解析失败排查也会麻烦一点。</p><p>在如今的硬件条件下，静态链接的易于部署比动态链接的低内存占用更加重要，采用动态链接更多还是看重其灵活性。</p><h2 id="Go-plugin-package"><a href="#Go-plugin-package" class="headerlink" title="Go plugin package"></a>Go plugin package</h2><p>Go 插件相关能力由 <code>plugin</code> 包提供，同时这个包实际上是对 dyld 调用的封装，使其更符合 go 的风格，相关的函数有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># dlfcn.h</span><br><span class="line">dlopen - load and link a dynamic library or bundle</span><br><span class="line">dlsym - get address of a symbol</span><br><span class="line">dlerror - get diagnostic information</span><br><span class="line">dlclose - close a dynamic library or bundle</span><br></pre></td></tr></table></figure><p>看下 <code>plugin</code> 的文档：</p><blockquote><p>A plugin is a Go <strong>main package</strong> with <strong>exported functions and variables</strong> that has been built with:<br><code>go build -buildmode=plugin</code><br>When a plugin is first opened, the init functions of all packages not already part of the program are called. The main function is not run. A plugin is only initialized once, and <strong>cannot be closed</strong>.</p></blockquote><p>简单来说就是，plugin 项目和一般的 Go 项目类似，必须定义一个 main package，同时 main pacakge 中可导出的 Function 和 Variable 可以被动态链接器查找到，注意是只有 main package 中的才可以，后面我们通过实例验证一下。<code>init</code> 函数调用规则就和普通项目一样了。</p><p><code>plugin</code> 包中只提供了 <code>Open(path stirng)(*Plugin,error)</code> 和 <code>Lookup(symName string)(Symbol,error)</code> 两个方法，很好理解，加载并解析动态链接库和查找 symbol。先看下 <code>Plugin</code> 结构体的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">pluginpath <span class="type">string</span></span><br><span class="line">err        <span class="type">string</span>        <span class="comment">// set if plugin failed to load</span></span><br><span class="line">loaded     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed when loaded</span></span><br><span class="line">syms       <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Symbol is a pointer to a variable or function.</span></span><br><span class="line"><span class="keyword">type</span> Symbol <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里关注 <code>syms</code> 就可以了，它保存了这个动态链接库对外提供的 symbol，<code>Lookup</code> 函数实际上就是执行 map get 操作。拿到 <code>Symbol</code> 后执行强制类型转换就可以正常使用了。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>这里我们建立两个工程，<code>ptest</code> 和 <code>plugin</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ptest</span><br><span class="line">├── main.go</span><br><span class="line">└── go.mod</span><br><span class="line"></span><br><span class="line"># plugin</span><br><span class="line">├── add.go</span><br><span class="line">├── add2.go</span><br><span class="line">├── subpkg</span><br><span class="line">│   └── sub.go</span><br><span class="line">└── go.mod</span><br></pre></td></tr></table></figure><p>重点关注一下 plugin 工程，我们在不同的 package 里定义可导出和不可导出的函数或变量，然后在主工程中断点看是不是与前面的学习一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main - add.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;add init called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ExportedVar = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> unexportedVar = <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExportedFunc</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> subpkg.NonMainPkgFunc(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unexportedFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">ID <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main - add2.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;add2 init called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AnotherFuncInMain</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subpkg</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;sub pkg init called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NonMainPkgFunc</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>add.go</code> 中分别定义了可导出&#x2F;不可导出的变量和函数以及一个可导出的类，在 <code>add2.go</code> 中定义了一个可导出函数；在 subpkg 中定义了一个可导出函数。按照文档描述，我们在主工程中可以 <code>Lookup</code> 到 <code>ExportedVar</code>、<code>ExportedFunc</code>、<code>AnotherFuncInMain</code>，其它的都将不可见，也即不存在于 <code>Plugin.syms</code> 中。</p><p>下面是 <code>main.go</code> 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">pluginPath := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p, err := plugin.Open(pluginPath); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="keyword">if</span> _, err := p.Lookup(<span class="string">&quot;Model&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;symbol Model not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := p.Lookup(<span class="string">&quot;unexportedVar&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v, err := p.Lookup(<span class="string">&quot;ExportedVar&quot;</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ExportedVar = %d\n&quot;</span>, *(v.(*<span class="type">int</span>)))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := p.Lookup(<span class="string">&quot;unexportedFunc&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sym, err := p.Lookup(<span class="string">&quot;ExportedFunc&quot;</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">res := sym.(<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>)(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;ExportedFunc returns %d\n&quot;</span>, res)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sym, err := p.Lookup(<span class="string">&quot;AnotherFuncInMain&quot;</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">res := sym.(<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>)(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;AnotherFuncInMain returns %d\n&quot;</span>, res)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subpkg</span></span><br><span class="line"><span class="keyword">if</span> _, err := p.Lookup(<span class="string">&quot;NonMainPkgFunc&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始测试我们的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd plugin</span><br><span class="line">go build -buildmode=plugin -o plugin.so add.go add2.go</span><br><span class="line"></span><br><span class="line">cd ptest</span><br><span class="line">go run main.go ../plugin/plugin.so</span><br></pre></td></tr></table></figure><p>得到的输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sub pkg init called</span><br><span class="line">add init called</span><br><span class="line">add2 init called</span><br><span class="line">symbol Model not found</span><br><span class="line">plugin: symbol unexportedVar not found in plugin plugin/unnamed-e927c94786173b9825475be45640cf8f5788c833</span><br><span class="line">ExportedVar = 123</span><br><span class="line">plugin: symbol unexportedFunc not found in plugin plugin/unnamed-e927c94786173b9825475be45640cf8f5788c833</span><br><span class="line">ExportedFunc returns 3</span><br><span class="line">AnotherFuncInMain returns 7</span><br><span class="line">plugin: symbol NonMainPkgFunc not found in plugin plugin/unnamed-e927c94786173b9825475be45640cf8f5788c833</span><br></pre></td></tr></table></figure><p>和我们猜想的一致，再进一步，这些查找失败的会不会是因为它们有特殊的名称呢？我们结合断点探个究竟。</p><p><img src="/img/2022/plugin_breakpoint.jpg" alt="Debug in VSCode"></p><p>可以看到确实只有那些被导出函数和变量，Type 和未导出函数、变量都无法被 Lookup 查找到。</p><blockquote><p>那 <code>init</code> 函数又是怎么回事呢？<br>VSCode 在调试时会自动添加一个 <code>-gcflags=&quot;all=-N -l&quot;</code> 的编译选项，所以我们在断点前也需要加上这个编译选项重新构建插件，否则你可能会看到一个 “plugin was built with a different version of package xxx” 的报错。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go 插件系统还是非常好上手，除了不支持 Windows 外，唯一的缺憾就是无法卸载了。最后推荐一个好玩的项目 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/go-plugin%E3%80%82">https://github.com/hashicorp/go-plugin。</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://pkg.go.dev/plugin">https://pkg.go.dev/plugin</a></p><p><a target="_blank" rel="noopener" href="https://youtrack.jetbrains.com/issue/GO-7474">https://youtrack.jetbrains.com/issue/GO-7474</a></p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《你尽力了吗？》by scz</title>
      <link href="/2022/03/09/9e7d221feb02.html"/>
      <url>/2022/03/09/9e7d221feb02.html</url>
      
        <content type="html"><![CDATA[<p>前段时间刷即刻刷到即友分享这篇文章（即刻现在依然是我发现新鲜有趣信息的主要来源），”你尽力了吗？“在 20 年后的今天依然能够直击人心。</p><p>下面是帖子内容</p><hr><p>发信人: cloudsky (小四), 信区: Security<br>标 题: 你尽力了吗<br>发信站: 武汉白云黄鹤站 (Mon Apr 17 19:52:54 2000), 站内信件</p><p>很多人问如何入门如何入门，我却不知道要问的是入什么门。很少把某些好文章耐心从头看完，我这次就深有体会。比如袁哥的 sniffer 原理，一直以为自己对 sniffer 原理很清楚的，所以也就不曾仔细看过袁哥的这篇。后来有天晚上和袁哥讨论，如何通过端口读写直接获取 mac 地址，为什么 antisniff 可以获得真正的 mac 地址，而不受更改mac地址技术的影响，如何在 linux 下获得真正的 mac 地址。我一直对 linux 下的端口读写心存疑虑，总觉得在保护模式下的端口都做了内存映象等等。结果袁哥问了我一句，你仔细看我写的文章没有，我楞，最近因为要印刷月刊，我整理以前的很多文档，被迫认真过滤它们，才发现袁哥的文章让我又有新认识。</p><p>再后来整理到 tt 的几篇缓冲区溢出的，尤其是上面的关于 Solaris 可装载内核模块，那就更觉得惭愧了。以前说书非借不能读，现在是文章留在硬盘上却不读。其实本版已经很多经典文章了，也推荐了不少经典书籍了，有几个好好看过呢。W.Richard.Stevens 的 UNP 我算是认真看过加了不少旁注，APUE就没有那么认真了，而卷 II 的一半认真看过，写过读书笔记，卷 III 就没有看一页。道格拉斯的卷I、卷III是认真看过几遍，卷II就只断续看过。而很多技术文章，如果搞到手了就懒得再看，却不知道这浪费了多少资源，忽略了多少资源。<strong>BBS 是真正能学到东西的地方吗？rain 说不是的，我说也不是的。不过这里能开阔人的视野，能得到对大方向的指引，足够了</strong>。</p><p><strong>我一直都希望大家从这里学到的不是技术本身，而是学习方法和一种不再狂热的淡然。很多技术，明天就会过时，如果你掌握的是学习方法，那你还有下一个机会，如果你掌握的仅仅是这个技术本身，你就没有机会了</strong>。其实我对系统安全是真不懂，因为我一直都喜欢看程序写程序却不喜欢也没有能力攻击谁谁的主机&#x2F;站点。我所能在这里做的是，为大家提供一个方向，一种让你的狂热归于淡然的说教。如果你连《Windows NT 设备驱动程序编写》、《win9x 系统编程》都没有看过，却要写个什么隐藏自己的木马，搞笑。如果你看都不看汇编语言，偏要问 exploit code 的原理，那我无法回答也不想回答你。总有人责问，要讨个说法纭纭，说什么提问却没有回答。不回答已经是正确的处理方式了，至少没有回你一句，看书去，对不对，至少没有扰乱版面让你生闷气。Unix 的 man 手册你要都看完了，想不会Unix都不行了。微软的 MSDN、Platform SDK DOC 你要看完了，你想把 Win 编程想象得稍微困难点都找不到理由。还是那句话，一个程序员做到 W.Richard.Stevens那个份上，做到逝世后还能叫全世界的顶级 hacker 们专门著文怀念，但生前却不曾著文攻击，想想看，那是一种什么样的境界，那是一份什么样的淡然。我们可以大肆讨论技术问题，可以就技术问题进行激烈的卓有成效的讨论，却无意进行基础知识、资源信息的版面重复。我刚在前面贴了一堆 isbase 的文章，开头就是主页标识，却在后面立刻问什么主页在哪里？前面刚刚讨论过如何修改 mac 地址，后面马上又来一个，前后相差不过 3 篇文章。</p><p>选择沉默已经是很多朋友忍耐力的优异表现了。很多东西都是可以举一反三的。vertex 的 lids，被 packetstorm 天天追踪更新，你要是看了 THC 的那三篇，觉得理解一个就理解了一堆，都是内核模块上的手脚。你不看你怎么知道。我不想在这里陷入具体技术问题的讨论中去，你要是觉得该做点什么了，就自己去看自己去找。没有什么人摆什么架子，也没有什么人生来就是干这个的。你自己问自己，尽力了吗？</p><hr><p>帖子中提到的一些人：</p><blockquote><p>scz(沈沉舟)    本帖作者<br>yuange(袁仁广) 当时在绿盟科技，此刻在腾讯<br>rain(刘春华)   此刻是杰思安全创始人<br>sztcww(王伟)   当时在川大，此刻在阿里，他后来更有名的ID是 alert7<br>tt(左磊)       仍在绿盟科技，他另有一个广为人知的ID是warning3(w3)<br>vertex(谢华刚) 当时在中科院，此刻在湾区PaloAlto，就是你们常说的平底锅</p></blockquote><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>BBS 是真正能学到东西的地方吗？rain 说不是的，我说也不是的。不过这里能开阔人的视野，能得到对大方向的指引，足够了。</li><li>我一直都希望大家从这里学到的不是技术本身，而是学习方法和一种不再狂热的淡然。很多技术，明天就会过时，如果你掌握的是学习方法，那你还有下一个机会，如果你掌握的仅仅是这个技术本身，你就没有机会了。</li></ul><p>之前和同事聊天时聊到了很多技术公众号和论坛，上面内容都比较入门，随着经验的积累，从中得到的帮助越来越少。但是不可否认，这些入门贴确实也为初学者打开了视野，指引了方向。真正能学到东西的还是“把手弄脏”的这个过程。尽管近几十年来各种编程语言层出不穷，但它们始终逃离不开 if else、for、while 这些基本元素。编程语言、技术本身没有价值，它们实现的解决问题的方案才有价值。学习能力、解决问题的能力，才是我们应对复杂多变环境的本质手段。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mmap 学习</title>
      <link href="/2021/08/21/adcbe1567140.html"/>
      <url>/2021/08/21/adcbe1567140.html</url>
      
        <content type="html"><![CDATA[<h2 id="mmap-是什么"><a href="#mmap-是什么" class="headerlink" title="mmap 是什么"></a>mmap 是什么</h2><p><code>mmap</code> 是 Unix&#x2F;Linux 提供的系统调用，所以 <em>RTFM（read the fucking manpage）</em>：</p><blockquote><p>allocate memory, or map files or devices into memory.</p></blockquote><p>介绍非常简单，就是分配一块内存或将文件或设备映射到一块内存中。不管是分配内存还是进行文件映射，执行完 <code>mmap</code> 后都会得到一个指向一块内存（虚拟地址空间）的指针，通过这个指针，能够以直接访问内存的方式读写文件或设备。</p><h2 id="mmap-怎么用"><a href="#mmap-怎么用" class="headerlink" title="mmap 怎么用"></a>mmap 怎么用</h2><p><code>mmap</code> 的函数声明是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span><br></pre></td></tr></table></figure><p>函数执行成功返回指向内存的指针，失败则返回 <code>MAP_FAILED (((void *)-1))</code>。</p><ul><li><strong>addr</strong>：用于确定映射内存区域的起始地址，需要是页大小的整数倍，不过实际返回的指针指向并不一定等于该值，具体的行为还和是否在 flags 中指定 MAP_FIXED 相关：</li></ul><table><thead><tr><th align="left">addr</th><th align="left">flags</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">flags &amp; MAP_FIXED &#x3D; 0</td><td align="left">系统自动选取一段空闲地址空间完成映射</td></tr><tr><td align="left">0</td><td align="left">flags &amp; MAP_FIXED !&#x3D; 0</td><td align="left">系统自动选取一段空闲地址空间完成映射</td></tr><tr><td align="left">xxx</td><td align="left">flags &amp; MAP_FIXED &#x3D; 0</td><td align="left">系统从 xxx 开始的地址空间中选取一块空闲地址</td></tr><tr><td align="left">xxx</td><td align="left">flags &amp; MAP_FIXED !&#x3D; 0</td><td align="left">如果 xxx 未被占用（mmap、alloc），则以 xxx 开始的区域执行映射；如果 xxx 被占用，则移除占用，执行映射。</td></tr></tbody></table><ul><li><strong>len</strong>：指定需要映射区域的大小，单位是 byte。</li><li><strong>prot</strong>：指定映射区域的读写执行权限，<code>PROT_NONE</code>、<code>PROT_READ</code>、<code>PROT_WRITE</code> 和 <code>PROT_EXEC</code>。</li><li><strong>flags</strong>：指定映射区域的类型或行为控制，这里选几个重要的说明下：</li></ul><table><thead><tr><th align="left">flags</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">MAP_ANON[YMOUS]</td><td align="left">使用匿名内存进行映射，不关联特定文件，指定这个标识位时 <code>fd</code> 传 0</td></tr><tr><td align="left">MAP_FILE</td><td align="left">默认对文件进行映射，与 MAP_ANON 相对</td></tr><tr><td align="left">MAP_FIXED</td><td align="left">上面说明过</td></tr><tr><td align="left">MAP_PRIVATE</td><td align="left">分配的内存是进程私有，多进程发生修改时需要执行 COW 操作</td></tr><tr><td align="left">MAP_SHARED</td><td align="left">分配的内存是进城间（父子关系）共享的，父子进程的修改不会引起 COW</td></tr></tbody></table><ul><li><strong>fd</strong>：文件描述符。</li><li><strong>offset</strong>：文件偏移，即从 <code>offset</code> 开始的 <code>len</code> byte 文件区域将会被映射到内存中。</li></ul><h3 id="mmap-写文件示例"><a href="#mmap-写文件示例" class="headerlink" title="mmap 写文件示例"></a>mmap 写文件示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 指定权限 0777，不指定也没关系</span></span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">  <span class="comment">// 获取页缓存的大小</span></span><br><span class="line">  <span class="type">int</span> pageSize = <span class="built_in">getpagesize</span>();</span><br><span class="line">  <span class="type">int</span> fSize = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">  <span class="keyword">if</span> (fSize &lt; pageSize) &#123;</span><br><span class="line">    <span class="comment">// 保证文件大小有 pageSize</span></span><br><span class="line">    <span class="built_in">lseek</span>(fd, pageSize - <span class="number">1</span>, SEEK_END);</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">&quot;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// MAP_FILE 需要和 MAP_SHARED 一起使用，否则失败</span></span><br><span class="line">  <span class="type">char</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">mmap</span>(<span class="number">0</span>, pageSize, PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, fd, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 不管成功或失败，fd 已经不需要了。实际映射是从内存到磁盘地址，读写已经不涉及文件概念了</span></span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写入 &quot;hello world&quot;</span></span><br><span class="line">  <span class="built_in">memcpy</span>(ptr, <span class="string">&quot;hello world&quot;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解除映射</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">munmap</span>(ptr, pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mmap-原理"><a href="#mmap-原理" class="headerlink" title="mmap 原理"></a>mmap 原理</h2><p><code>mmap</code> 将文件映射入内存，这里内存指的是进程的虚拟地址空间，实现虚拟地址空间与文件偏移地址的一一对应关系，这种一一对应关系由内核负责维护。成功建立映射关系后，进程可以通过计算内存地址偏移访问文件，同时内核会负责将变更回写磁盘，这就避免了进程意外退出时可能的数据丢失。</p><p><img src="/img/2021/va_mapping.png" alt="映射关系"></p><p>那么除了脱离 read&#x2F;write 访问文件外，mmap 与常规的文件读写操作有哪些本质上的区别呢？</p><h3 id="常规文件访问"><a href="#常规文件访问" class="headerlink" title="常规文件访问"></a>常规文件访问</h3><p>我们知道在计算机系统中，内存读写速度要比磁盘高出几个数量级，为了提高文件读写效率和保护磁盘（减少直接操作磁盘的次数，特别是具有机械结构的磁盘），采用了页缓存，在访问文件内容前，先将文件内容加载到页缓存中，后续的文件读写会优先在页缓存中进行。看起来和 mmap 也没啥区别，事实上页缓存存在于内核空间，所以用户进程想要真正访问到文件内容，还需要将页缓存从内核空间拷贝到用户空间，正是这一次拷贝，造就了 mmap 和常规文件操作的区别。下面看看用户进程初次访问某个文件的过程：</p><ol><li>进程发起读文件请求，比如 read 系统调用。</li><li>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的 inode。</li><li>inode 在 address_space 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</li><li>如果不存在，则通过 inode 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</li></ol><p>可以看到，常规文件访问首次访问文件会有<strong>磁盘到页缓存</strong>，<strong>页缓存到用户进程空间</strong>两次 IO。</p><h3 id="mmap-映射建立过程"><a href="#mmap-映射建立过程" class="headerlink" title="mmap 映射建立过程"></a>mmap 映射建立过程</h3><blockquote><p>这一块我也没有实际阅读过 Linux 源码，所以更详细的解析可以参考文末的参考文章</p></blockquote><ol><li>用户进程发起 mmap 系统调用，在虚拟地址空间中找到合适的位置为映射创建虚拟映射区域。</li><li>在内核空间中建立起虚拟地址空间和文件物理地址的映射关系。注意目前为止还没有分配物理内存。</li><li>进程对虚拟地址空间的映射区域发起访问，但是页表中并未有该段地址所对应物理内存，所以引发缺页中断，内核通过文件系统将文件内容加载到主存。</li></ol><p>对比常规文件访问和 mmap 的操作流程，可以看 mmap 是有点像将页缓存直接映射到了用户进程的虚拟地址空间，从而避免了另一块内存的分配与数据拷贝，借助这种映射关系，也能快速实现进程间的共享内存。</p><h2 id="mmap-优缺点"><a href="#mmap-优缺点" class="headerlink" title="mmap 优缺点"></a>mmap 优缺点</h2><p>Pros：</p><ul><li>访问同一文件只需要分配一块内存，减少内存压力。</li><li>文件读写避免了一次用户空间到内核空间的拷贝，用内存读写替代 I&#x2F;O 读写，提高了文件读写效率。</li><li>方便实现进程间的共享内存。两个进程映射同一个文件，从而实现两个进程感知到对方对同一块内存的改动。</li></ul><p>Cons：</p><ul><li>映射建立后无法动态改变映射长度，无法改变文件长度，建立映射时就需要确定映射区间，所有读写操作被限制在这个区间。</li><li>映射区域长度是页大小（通常是 4K）整数倍，当映射一个小于 4K 的文件是，有一部分内存空间浪费了，不过这个问题不是 mmap 独有的。</li></ul><h2 id="亿点点细节"><a href="#亿点点细节" class="headerlink" title="亿点点细节"></a>亿点点细节</h2><ol><li>建立映射区域的大小需要是页大小的整数倍，因为系统对内存最小的划分粒度就是页。当 <code>len</code> 大小不足时，系统会将其扩充至页的整数倍。</li><li>mmap 建立后得到的内存指针底层是文件的磁盘地址，当企图通过指针访问非文件大小内的数据时，就会发生异常。</li><li>通过映射区域访问文件空洞时，会造成文件系统为该空洞区域分配磁盘空间。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904058667401230">https://juejin.cn/post/6844904058667401230</a></p><p><a target="_blank" rel="noopener" href="http://blog.jcix.top/2018-10-26/mmap_tests/">http://blog.jcix.top/2018-10-26/mmap_tests/</a></p><p><a target="_blank" rel="noopener" href="https://mtancode.com/2019/11/24/mmap%E5%8E%9F%E7%90%86/">https://mtancode.com/2019/11/24/mmap%E5%8E%9F%E7%90%86/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>财务分析与决策</title>
      <link href="/2021/08/14/ef33651bdc85.html"/>
      <url>/2021/08/14/ef33651bdc85.html</url>
      
        <content type="html"><![CDATA[<p>清华大学肖星教授财务公开课笔记。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=845598883&bvid=BV1354y1L7kg&cid=346603284&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe></div><hr><h2 id="财务报表"><a href="#财务报表" class="headerlink" title="财务报表"></a>财务报表</h2><p>公司三项活动：经营、投资、融资。</p><h3 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h3><p><img src="/img/2021/assets_and_liabilities.jpg" alt="资产负债表"></p><p>资产 &#x3D; 负债 + 权益<br>权益 &#x3D; 资产 - 负债<br>负债 &#x3D; 资产 - 权益 ：在经济学概念上不成立，去除股东权益后公司变成债权人的了。</p><blockquote><p>资产与费用的异同：<br>同：都需要付出一笔资金。<br>异：如果在未来可以换来一个有用的东西，就是资产，如果什么都没留下，则是费用。</p></blockquote><p>待摊费用：随着时间流逝或经营活动，逐渐发生的费用。</p><blockquote><p>待摊费用很有意思。</p></blockquote><p>流动资产与固定资产的区别在于变现的能力。</p><p>固定资产要满足使用时间长、价值高这两项条件。</p><p>员工&#x2F;人的所有权不归公司所有，所以也无法体现在报表里，否则就是奴隶制了。</p><blockquote><p>棒球俱乐部会花巨额引入球星，这项费用就是一个待摊费用，这时人，更准确地是人的某项所有权，就变成了一项资产体现在报表里。</p></blockquote><h4 id="资产的价值"><a href="#资产的价值" class="headerlink" title="资产的价值"></a>资产的价值</h4><p><strong>购买成本&#x2F;历史成本</strong> or <strong>当前市价&#x2F;公允价值</strong>？</p><p>历史成本原则：如果资产升值了，忽略，如果减值，则扣除减值部分。</p><p>公允价值原则：当市场价格特别客观（交易活跃）时，使用当前市价记录，典型资产有股票、债券等金融产品和投资性房地产。</p><p>在使用历史成本统计时，因为资产只计减值，所以当<strong>资产升值</strong>时，可能会通过一项无意义的交易将增值部分计入资产，从而使财报更好看。</p><h4 id="债务"><a href="#债务" class="headerlink" title="债务"></a>债务</h4><p>员工工资计入其它债务，因为工资一般都是月末发放，这项费用很快就会偿清。</p><h4 id="长期应付款"><a href="#长期应付款" class="headerlink" title="长期应付款"></a>长期应付款</h4><p>租赁</p><ol><li>经营性租赁：</li><li>融资性租赁：金额大、期限长，会认定为在分期购买一项资产</li></ol><h4 id="股东权益"><a href="#股东权益" class="headerlink" title="股东权益"></a>股东权益</h4><p>P7</p><p>权益结构：</p><ol><li>股本</li><li>资本公积</li><li>盈余公积：法律规定不可分配净利润部分，中国特色项目。</li><li>未分配利润</li></ol><blockquote><p>比如增发 1亿股，每股成本 1块，发行价 20块。融资回来 20亿，其中 1亿计入股本，剩余 19亿计入资本公积。持有股本数决定股东拥有公司的份额的比例。</p></blockquote><h3 id="利润表"><a href="#利润表" class="headerlink" title="利润表"></a>利润表</h3><p><img src="/img/2021/profit_sheet.jpg" alt="利润表"></p><p>知道企业是不是赚钱了。</p><p>毛利&#x2F;gross profit &#x3D; 收入&#x2F;revenue - 成本&#x2F;cost</p><p>营业税：只要企业有经营活动，就需要交。又叫流转税。价内税。</p><p>增值税：价外税。</p><blockquote><p>100 块钱的菜，饭馆要交5块的税包含在这一百块内，这就是营业税。又比如一台电脑标价10000，但是消费者需要支付11000才能购买，多出来的1000就是增值税。增值税会由商家代收，成为其负债——应交税金，体现在资产负债表中。</p></blockquote><p>所得税：赚钱之后才交。</p><p>营业费用：跟产品销售环节有关的费用，运输、广告、销售人员工资、 门店租金等。</p><p>管理费用：管理人员的工资、办公楼的折旧等。</p><p>财务费用：存款利息、债务利息等。一般情况下是正数，负数可能是资金未及时投入使用。</p><p>投资收益：投资虽然不是营业所得，但是可以认为是设立子公司从事经营活动，所以仍然可以认为是营业利润。</p><p>资产减值损失：</p><p>公允价值变动收益：主要针对金融资产和投资性房地产，这类资产的公允价值变动会产生收益或损失。</p><p>营业外收入：存活盘点时发现存货多&#x2F;少了，就是存货盘盈&#x2F;盘亏。<br>营业外损失：比如自然灾害、火灾等造成的损失。</p><p>营业外收入或损失一般都是偶发性、不具备可持续性。</p><p>应税所得按照税法计算，而利润所得按照会计准则计算，二者之间虽然大致相同，但是有差异。比如广告费用 2KW，虽然会计准则会将这 2KW 计入营业费用，但是税法规定只有 xx% 的广告费可以计入成本，剩下的还是要计税。</p><h4 id="利润表表达信息"><a href="#利润表表达信息" class="headerlink" title="利润表表达信息"></a>利润表表达信息</h4><p>收入&#x2F;Revenue - 所有成本费用&#x2F;Expenses &#x3D; 利润&#x2F;Profit</p><p><strong>作用</strong>：</p><ul><li>现在收入</li><li>预测未来收入情况</li></ul><p>收入&#x2F;Income !&#x3D; 收到现金&#x2F;Cash inflow : 比如产生了应收款、预付款</p><p>费用&#x2F;Expenses !&#x3D; 付出现金&#x2F;Cash outflow : 比如资产折旧、待摊费用</p><p>收入现金 - 付出现金 &#x3D; 现金流 &#x3D;&gt; 利润 !&#x3D; 现金流</p><h3 id="报表产生的过程"><a href="#报表产生的过程" class="headerlink" title="报表产生的过程"></a>报表产生的过程</h3><p>P11</p><p>研发投入在研发过程中的算作费用，研发成功后在特定条件下才能作为无形资产。研发是一个高度不确定的活动，会计处于谨慎保守，所以研发投入认为是费用；研发成功不等于商业成功，仍然具有高度不确定性。外购技术可以作为无形资产，因为已经有交易对其进行定价，所以有些企业将研发部门单独成立公司，母公司就需要从子公司购买。</p><p>自创技术、自创品牌的投入一般都算在管理费用中，即使这些东西可能非常有价值。</p><h3 id="现金流量表"><a href="#现金流量表" class="headerlink" title="现金流量表"></a>现金流量表</h3><p>P18</p><p>现金流量表就是将现金的流入与流出按照公司从事的经营、融资、投资三项活动进行分类描述。描述现金的来龙去脉，描述企业的<strong>风险状况</strong>。</p><h3 id="三张报表的内在关联"><a href="#三张报表的内在关联" class="headerlink" title="三张报表的内在关联"></a>三张报表的内在关联</h3><p>P21</p><p>利润表主要描述企业的经营活动，资产负债表描述投资和融资活动，现金流量表描述风险。<br>三张表从两个维度描述了企业状况：</p><ul><li>现金流量表从风险角度描述了企业能不能活下去；</li><li>资产负债表和利润表则描述了如果企业能活下去，未来能取得什么样的收益。</li></ul><p>零成本收购：承担负债，获取资产。</p><h2 id="财务分析"><a href="#财务分析" class="headerlink" title="财务分析"></a>财务分析</h2><h3 id="常用财务分析方法"><a href="#常用财务分析方法" class="headerlink" title="常用财务分析方法"></a>常用财务分析方法</h3><p>最常用的财务分析方法——同型分析，其实就是结构分析，即分析每个部分所占资金总量的比例。</p><p>利润表使用营业收入作为整体&#x2F;分母；资产负债表使用总资产作为整体&#x2F;分母。</p><p>比率分析：对原有报表数据进行处理得到新的数据。</p><p>现金流分析：</p><p>比较分析：主要是同行业、同水平企业的对比。</p><h3 id="盈利能力"><a href="#盈利能力" class="headerlink" title="盈利能力"></a>盈利能力</h3><p>毛利润率，净利润率。</p><p>投入资源就是总资产。</p><p>收入&#x2F;总资产 * 净利润&#x2F;收入 &#x3D; 净利润&#x2F;总资产 &#x3D; 总资产报酬率（return on total assets）</p><p>利润率是效益概念；收入&#x2F;总资产叫周转率，是效率概念。</p><h3 id="营运能力"><a href="#营运能力" class="headerlink" title="营运能力"></a>营运能力</h3><p>周转率是营运能力指标。</p><p>某项资产的周转率 &#x3D; 收入&#x2F;某项资产</p><p>但是存货是例外，存货周转率 &#x3D; 成本&#x2F;存货。</p><p>周转率计算时分子来源于利润表，分母来源于资产负债表，但是利润表是时段概念，资产负债表是时刻概念，所以分母使用平均值才更合理。</p><p>以应收账款为例，假设应收账款的周转率是 3，则表示应收账款平均在 4 个月内能完成回款。</p><p>股东权益 &#x3D; 总资产 - 负债 &#x3D; 净资产</p><p>净资产回报率 &#x3D; 净利润&#x2F;股东权益</p><h3 id="偿债能力"><a href="#偿债能力" class="headerlink" title="偿债能力"></a>偿债能力</h3><p>负债划分为流动、非流动。</p><h4 id="短期偿债"><a href="#短期偿债" class="headerlink" title="短期偿债"></a>短期偿债</h4><p>短期偿债能力衡量流动债务的偿还能力。</p><p>偿债资金来源应该是流动资产，理想情况下，流动资产可以短时间内全部变成现金，保守的方式是去除变现周期较长的存货。</p><p>流动资产&#x2F;流动负债 &#x3D; 流动比率<br>(流动资产 - 存货)&#x2F;流动负债 &#x3D; 速动比率</p><p>流动资产的作用：</p><ol><li>流动偿债能力</li><li>提供日常营运的资金</li></ol><p><img src="/img/2021/current_ratio.jpg" alt="流动比率~破产年份"></p><blockquote><p>纵轴：流动比率<br>横轴：破产前年份</p></blockquote><blockquote><p>上面图表由美国学者制作。在中国，银行不太倾向给企业长期贷款，很多短期贷款是长期贷款的一种体现——借新债还旧债，从这个角度来说，需要去除一部分短期借款。</p></blockquote><h4 id="长期偿债"><a href="#长期偿债" class="headerlink" title="长期偿债"></a>长期偿债</h4><p>不能用 <code>长期负债/固定资产</code> 计算长期偿债能力，当企业变卖固定资产一般是企业要破产关门了。</p><p><strong>偿还利息的能力</strong></p><p><code>净利润/利息支出</code> 也不能用来计算偿还利息的能力，因为净利润已经扣除了债务利息。一般用支付所得税和财务费用前的利润&#x2F;利息计算偿息能力，这样的利润叫息税前利润。</p><p><strong>偿还本金的能力</strong></p><p>不太精确。</p><p>资产负债率 &#x3D; 负债&#x2F;资产 &#x3D; 财务杠杆</p><p>大多数行业平均水平在 45%，重资产行业通常比较高，因为资产多，能够抵押的也多。</p><h2 id="影响财务数据的因素"><a href="#影响财务数据的因素" class="headerlink" title="影响财务数据的因素"></a>影响财务数据的因素</h2><p><img src="/img/2021/five_force.jpg" alt="five-force"></p><p>竞争激化直接影响毛利。</p><p>产业链上下游环境，体现在毛利、预付账款和应收账款上。</p><h3 id="财务数据对战略决策影响"><a href="#财务数据对战略决策影响" class="headerlink" title="财务数据对战略决策影响"></a>财务数据对战略决策影响</h3><p><img src="/img/2021/strategy.jpg"></p><p>成本领先战略：低毛利高周转率，追求效率。</p><p>差异化战略：高毛利低周转，追求高效益。</p><p><img src="/img/2021/factors_affecting_financial_data.jpg" alt="影响财务数据的因素"></p><h2 id="如何理解赚钱？"><a href="#如何理解赚钱？" class="headerlink" title="如何理解赚钱？"></a>如何理解赚钱？</h2><p>几个与赚钱相关的指标：净利润率、总资产报酬率、净资产收益率。</p><p>总资产报酬率对投资回报的描述不够精确，总资产中除了股东权益，还包含有息债务，所以需要在净利润上加上所支付的利息。</p><p>投资资本成本，一般用行业平均水平，P36。<br>机会成本，即投到同行业别的企业能够获得收益。</p><p><img src="/img/2021/cost_of_invested_capital.jpg" alt="Cost of invested capital"></p><p>经济利润：比行业平均盈利水平多赚的钱，企业为股东真正赚到的钱。</p><p>经济利润 &gt; 0 是一个好企业的最基本要求。</p><h2 id="分析实战"><a href="#分析实战" class="headerlink" title="分析实战"></a>分析实战</h2><p>P39</p><h2 id="现金流分析"><a href="#现金流分析" class="headerlink" title="现金流分析"></a>现金流分析</h2><p>P45</p><p>净利润 - 现金流 &#x3D; 非现金资产和负债变化</p><h2 id="战略投资与投资决策"><a href="#战略投资与投资决策" class="headerlink" title="战略投资与投资决策"></a>战略投资与投资决策</h2><p>P51</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1354y1L7kg">https://www.bilibili.com/video/BV1354y1L7kg</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Mi4y1x7d5">https://www.bilibili.com/video/BV1Mi4y1x7d5</a></p>]]></content>
      
      
      <categories>
          
          <category> Investment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Financial statements </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《国富论》读书笔记</title>
      <link href="/2021/07/25/1299e01750b7.html"/>
      <url>/2021/07/25/1299e01750b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="作品信息"><a href="#作品信息" class="headerlink" title="作品信息"></a>作品信息</h2><p><strong>作者</strong>：亚当·斯密<br><strong>阅读平台</strong>：微信读书<br><strong>豆瓣链接</strong>：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/3725829">https://book.douban.com/subject/3725829</a></p><blockquote><p>微信读书搜索“国富论”，排名第一结果的电子书章节划分有些问题，可以选择排名第二的搜索结果。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>摘抄于微信读书</p></blockquote><p>《国富论》又名《国民财富的性质和原因的研究》。</p><h2 id="摘要-amp-笔记"><a href="#摘要-amp-笔记" class="headerlink" title="摘要&amp;笔记"></a>摘要&amp;笔记</h2><p>全书共分5篇，每一篇都能拿出来单独成书。</p><h3 id="第一篇：论增进劳动生产力的因素，及分配劳动生产物给各个阶层的自然顺序"><a href="#第一篇：论增进劳动生产力的因素，及分配劳动生产物给各个阶层的自然顺序" class="headerlink" title="第一篇：论增进劳动生产力的因素，及分配劳动生产物给各个阶层的自然顺序"></a>第一篇：论增进劳动生产力的因素，及分配劳动生产物给各个阶层的自然顺序</h3><blockquote><p>共12章，已读7章</p></blockquote><h4 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h4><p><strong>分工出现以后，劳动生产力得到了极大的增进</strong>。</p><blockquote><p>🌰 ：即使是扣针这种简单的商品，也需要比较复杂的工序：抽丝、拉直、切截、削尖、打磨等，大大小小18道工序。如果由一个人完成所有工序，可能一天一枚扣针生产不出来。</p></blockquote><p>富裕国家的有着较高的产业和劳动生产力的增进水平，各行各业的分工水平也相对比较高。农业因季节、天气的原因，不可能形成完全的分工，所以农业的劳动生产力增进总是跟不上制造业（农村人口不可能靠耕种过上小康生活）。</p><p>分工能增进劳动生产力的原因有三：</p><ol><li>劳动者因为专业而掌握了技巧。</li><li>免除了由一种工作转到另一种工作所带来的时间损失（时间、地点、工具可能不同）。</li><li>专业&#x2F;专注会比分散精力更容易发现更简便的方法，或者发明工具极大提升人效。比如早期蒸汽机需要有一个人根据活塞升降打开或关闭汽缸与汽锅之间的通路，有一次担任这项工作的小男孩因为贪玩把开关与机器另一部分相连，这样开关就不需要人控制了，蒸汽机大大改良方法之一竟自于一个贪玩的小男孩。</li></ol><p><strong>分工并非源于人类智慧</strong>，而是文明发展到一定程度，自然而然产生的一种社会关系，我们享受的几乎所有生活必需品都来自他人，要想脱离这种社会关系几乎不可能（当野人吗？）。</p><p>如果一个为了自己的利益，能够刺激他人的利己心而为自己办事，就可以比较容易的达到目的。比如，猎人用自己多余的弓箭🏹️交换别家的富余的猎物，竟发现比自己去打猎得到的还要多，那么他就会倾向与把弓箭制造当成主业，因此他成了专门的武器制造者。交换为双方带来了利益，利益促进交换这一行为，交换则进一步促进分工的形成。是不是可以认为社会其实就是一张共同利益交织的巨网？当利益出现分歧，社会就会出现分裂，每个人都有梦想，但是梦想不一样。</p><p><strong>人类天赋才能的差异并没有我们想象的那么大。成年人在其所从事的不同职位上所表现出得非常不同的才能，与其说是分工的原因，不如说是分工的结果</strong>。也就是说人与人之间的差异绝大部分是由他所处环境导致，从另一个方面来说，选择了什么样的环境，很大程度上决定了他的发展程度——选择大于努力。所以成长环境对人的影响，也将伴随人一生。</p><p><strong>市场大小会限制分工水平</strong>，市场大小指需求量大小和需求种类丰富程度。当市场较小时，交换种类也会比较简单，对分工要求也不高；但是面向一个更大市场时，巨大的需求量与丰富的需求种类会要求更高的社会劳动生产力，促进分工水平进步。</p><blockquote><p>改革开放激发了中国这个巨大市场的活力，刺激了居民对生活必需和非必需品的需求，从而促使社会分工水平提升，在不同生产力水平出现了家庭手工作坊、集体企业、乡镇企业以及各种专门的国企、私企。</p><p>人口净流出城市，随着人口越来越少，这个城市的需求结构也会趋于简单化，对应当地产业也会变得低端，不能满足人才的就业需求，进一步加剧人口流出，形成恶性循环。</p></blockquote><h4 id="支配商品交换价值的原则"><a href="#支配商品交换价值的原则" class="headerlink" title="支配商品交换价值的原则"></a>支配商品交换价值的原则</h4><p><strong>分工确立以后，个人所需物品大多来自他人劳动。所以衡量贫富水平的尺度，就变成了一个人能够支配的劳动的多少。因此衡量一切商品交换价值的真实尺度就是劳动</strong>。在货币还没有诞生的时代，人们使用自己富余的劳动生产物与他人进行物物交换，从而免去了自己为得到某物所需的劳动，只是因为物物交换成立的前提是找到两个有互补需求的交易方，这限制了需求被满足，所以才出现了货币。也就是说，钱，只是财富的表象而已。</p><p><strong>劳动是无差别的，劳动可以衡量一切商品的交换价值，却不能衡量一切商品的价值</strong>。要考虑一项劳动的前期投入与入门门槛，比如一项劳动需要多年的学习，那么在考虑劳动的劳动量时也需要将这部分投入计算（注意区分劳动和劳动量）。</p><p><strong>在一定时期内，决定金银所能支配的劳动量，往往是当时已经发现的著名金银矿山的出产量</strong>。货币宽松政策与通胀，货币紧缩与通缩。现金的价值是不稳定的，发展中的社会，现金是贬值的，换成资产能更保值。</p><p>无论何时何地，劳动的价值都不会变动，它是商品的真实价格。至于货币，它只是商品的名义价格。</p><p><strong>商品的价格无论在什么社会，都最终被分解成了地租、劳动工资、利润这三部分或是其中之一二</strong>。<br>在出现土地（生产资料）私有制后，地主必然会想着不劳而获，甚至还会要求收取土地上的自然产物的地租。因为等量金银&#x2F;货币所能购买的劳动量在社会发展过程中会不断减少，所以租赁协议约定的地租（一部分）会随社会劳动生产力变动。<br>工资是由对应劳动的数量、强度与技巧决定，而不是资本&#x2F;企业的大小。<br>利润是商品价格在扣除地租、工资后的剩余部分，这部分是资本垫付工资、原材料的风险的所得，利息可以作为一个特殊的例子。资本的利润只与资本的大小相关，当一个行业具有规模效应时，就会吸引资本流入，地租与工资占比就会不断下降，利润与利润率不断提高。</p><blockquote><p>刘强东一块钱工资这样看来就很滑稽了，劳动&#x2F;工资与利润相比，根本微不足道。</p><p>另一个例子是期权&#x2F;股票激励制度，将劳动者与资本进行一定程度绑定，这样劳动者就能同时作为劳动者与资本所有者身份参与生产。</p></blockquote><p><strong>商品的价格分为自然价格与市场价格</strong>，自然价格由地租自然水平、工资自然水平、资本的自然水平支配。当商品市场价格与自然价格相近时，价格就和价值相当。</p><p>决定市场价格上升的因素有二：</p><ol><li>货品的缺乏程度，即供需关系。但是参与供需关系的是既成劳动，而不是待成劳动，供不应求时市价上升，待成的工资不会上升（具体视劳动与最终商品的接近程度），所以超出市价的部分便成了利润。</li><li>竞争者的富有和奢侈程度。</li></ol><p>市场价格会围绕自然价格上下波动，这种波动包含了三要素的波动。如果地租下降，地主就会撤回部分土地；如果工资下降，劳动者就会撤回部分劳动；如果利润下降，资本就会部分撤回。不论是哪一部分，市价波动都会反馈给利益相关方，促使他们撤回或增加投入。</p><p>商品市价在长时间内超过自然价格的原因：</p><ol><li>特殊的意外事故引起的市价增高。比如自然灾害，先进生产技术的技术壁垒。</li><li>天然因素引起的市价增高。比如飞天茅台，天然原因的作用会一直持续下去，因为有效需求始终得不到充分供给。</li><li>特殊政策引起的市价增高。典型例子是垄断，垄断者会倾向将商品供应量控制在市场有效需求之下，这样就能获得超过自然价格的收益。（钻石恒永久，爱情永流传。让天下没有难做的生意。阿呸！！！）</li></ol><h4 id="工资"><a href="#工资" class="headerlink" title="工资"></a>工资</h4><blockquote><p>工资率是在什么状况下自然而然地确定的，这一状况受到了社会贫富、进步程度的哪些影响？</p></blockquote><p><strong>支配劳动价格的因素有两个：一是劳动需求；二是生活必需品和便利品的价格</strong>。劳动需求本质是供需关系，国家繁荣时，市场不断增加对劳动力的需求，劳动者就业机会增多，劳动者的工资也会因此提高。生活必需品和便利品就是物价水平，工资至少要能够使一个人及其家庭能够维持基本的生活，这一工资大概就是各地的最低工资标准了。</p><p>一个有意思的结论是：<strong>物价水平高时，工资反而低；物价水平低时，工资高</strong>。物资匮乏时，工人会迫切地想要改善生活，但是因为物价高昂，雇主雇佣更多工人的意愿较低，甚至减少维持现有工人数量的资金，就业机会减少，一些上层劳动者就会开始向下挤压下层劳动者的就业空间；物资丰富时，低廉的物价让雇主可以雇佣更多的工人，那么市场上对劳动的需求增加，劳动价格往往就会提高。</p><p><strong>劳动生产物是劳动的自然报酬，或者是劳动的自然工资。地租是从土地上的劳动生产物中扣除的第一个项目；第二个项目是利润</strong>。</p><p>随着劳动生产力的增强，单位劳动生产物所需劳动量减少，从而使得一切物品的价格都日渐低廉。实际上，一切物品都随着社会进步而变得低廉。</p><p>劳动者普通工资由劳资双方所订的契约决定。劳资双方的关系是利害关系，立场绝对不会一致。</p><p>人们可能经常听说工人的结合，却很少听到雇主的结合。实际上雇主随时随地可以结合，这是一种秘而不宣的团结一致的结合，目的就是使劳动工资不超过其实际应得工资。无论何时何地，哪个雇主敢破坏这种团结，那他就是做了最不明智的事，一定会被临近行业者和同行耻笑。</p><p>劳动者结合&#x2F;工会受到阻碍：</p><ul><li>劳动者结合的困难程度要远大于雇主结合的程度，相比雇主数量，劳动者数量庞大，每个人权衡利弊后，最终能完成结合的期望值就很低了，雇主则能随时随地结合。</li><li>雇主对劳动者的需要，没有劳动者对雇主的需要那么迫切，劳动者依靠靠工资维持生活，雇主即使不雇佣一个劳动者也能维持生活。</li><li>劳动者的结合通常是临时组织，往往是无路可走的情况下的选择，往往情绪化严重，可能采取一些疯狂的举措。雇主自然会求助政府镇压，结果往往是为首者受到惩罚。（在中国，有纪律的、非政府组织，要想合法地进行运动，需要各种审批，周期长。往往工人是无法承受这么耗下去。西方国家的工会与中国的工会。</li></ul><p><strong>决定劳动工资增高的因素，不是现有的国民财富有多庞大，而是国民财富的不断增长</strong>。所以，出现最高劳动工资的国家，往往不是最富裕的国家，而是那些最快变富裕、繁荣的国家。同理，快速成长的企业也会提供更丰厚的回报。</p><p>书中提到了中国。一直以来，中国都是世界上最富有的国家。它拥有最肥沃的土地、最精细的耕作、最多而且最勤勉的居民。然而不知从何时起，它似乎就开始停滞不前了。如果翻看现在的旅行家写的关于中国的报告，就会发现其中记述中国的耕作、勤劳及人口的稠密状况，几乎跟500年前马可波罗记述的同类报告没什么两样。中国财富的发展程度，也许早在马可波罗时代以前，就已经达到了该国法律制度所允许的顶峰了。</p><p>这段话不免令人新生感慨，中国早在公元12世纪就达到了封建制度的顶峰，但是中间这六百多年一直停步不前，直到被西方列强的坚船利炮打开国门后，才开始审视封建制度乃至打破它。</p><p>无论一个国家多么强大，其居民大多数也是仆役、劳力和各类工人。所以缩小贫富差距也是中国走向强大的必由之路。</p><p>一个人在为别人工作时，不可能会比为自己工作更卖力。</p><h4 id="资本-amp-利润"><a href="#资本-amp-利润" class="headerlink" title="资本&amp;利润"></a>资本&amp;利润</h4><blockquote><p>工资率是在什么状况下自然而然地确定的，这一状况受到了社会贫富、进步程度的哪些影响？</p></blockquote><p>影响利润的因素：</p><ul><li>商品价格的变动；</li><li>竞争者的多寡；</li><li>顾客的购买欲望；</li><li>商品运输或存储过程中的损耗。</li></ul><p>货币利息可以一定程度上反映利润。当使用货币能够获得较高利润时，通常可以提高货币的利息率；当使用货币所获利润较少时，则可以降低货币的利息率。这也比较符合常理，当经济过热时，国家央行就会提高利息率，收紧货币流通性；反之经济萧条时会降低利息甚至零利息，以刺激资本投资，促进经济发展。</p><p>商人&#x2F;资本家口中的经济情况不好可能是指利润降低，但是利润降低往往是繁荣的体现，因为市场对劳动力的需求增加，工资占比提高，自然利润下降，但是因为资本总量是在增长的，所以经济整体上是往好的方向发展。资本增加是因为投资增加，无利不起早。</p><p>俗话说，钱生钱。哪怕是用极少的钱，也能赚更多的钱。最困难的是如何得到最初的那点儿极少的钱。对于普通人来讲，也需要“资本”的原始积累。</p><h4 id="地租"><a href="#地租" class="headerlink" title="地租"></a>地租</h4><p>这一章的论述非常冗长且枯燥，中间几经看不下去了，或许是里面的内容并不是我感兴趣的——朴素的观点及论证，所以很大一部分采取了略读。</p><p>一块土地能提供地租的前提条件是，该土地上的生产物能够维持其上市所需的劳动，并且有部分剩余，剩余的部分包含了资本家为劳工垫付的资本、利润及地租。如果劳动产物没有剩余，雇主就不会有动力租赁土地。有点类似现在的投资人，如果某项投资活动的投资回报不高于这项投资活动的平均回报水平，那么资本就咩有动力对其进行投资。换个角度，平均投资回报其实就是资本成本。</p><p>并不是每块土地都能提供地租。那些总是能提供地租的土地生产物一般是生活必需品，即食物。当时生活必需品的需求得到满足之前，那些生产非必需品的土地应为供过于求甚至是“无求”而无法提供地租。</p><p>当社会生产力发展或者是土地改良，生产等量的生活必需品只需要以前一半的劳动量，那么多出的一半劳动量就可以去生产满足人类其它欲望或嗜好的物品，比如衣服、住宅、饰品等。大部分富人的愉悦，都是炫耀他们的富裕。对于他们来说，最大的炫耀就是拥有别人求之不得的、决定性的富裕标识。为了满足这部分需求，一些土地也开始能够提供地租，比如钻石矿。</p><p>一国的财富会随着劳动年产物的逐渐增大而增大时，就会有大量的商品，它们需要大量的通货才能流通，现实中通货的体现就是货币。这也说明了，只要 GDP 在增长，那么货币供给也会随之增长，不然经济就无法顺畅运转。但是一般来说，货币供给都会保持一定程度的盈余，超量的货币供给会导致货币贬值。</p><p>良好的商业经营，最忌讳的就是独占，而只能靠自由和普遍竞争得以确立。一般商人的利益，无疑是扩大市场、缩小竞争，但是中国互联网普遍的经营套路是占领市场、”缩小竞争”。</p><p>《国富论》中大量的历史经济数据的论述，是我所没有想到的，在看到这些史实陈述时，只觉得索然无味，但这些又是论据，离开这些资料，所有结论都会如空中楼阁。所以读完这第一篇后，不准备继续往下了，待到后面时间富余再回过来体会。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国富论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AppStartup 源码阅读</title>
      <link href="/2021/07/10/60413caefef0.html"/>
      <url>/2021/07/10/60413caefef0.html</url>
      
        <content type="html"><![CDATA[<h2 id="App-Startup-介绍-amp-使用"><a href="#App-Startup-介绍-amp-使用" class="headerlink" title="App Startup 介绍&amp;使用"></a>App Startup 介绍&amp;使用</h2><p>官方介绍 App Startup 是一个启动期间优化组件&#x2F;库初始化的库：</p><blockquote><p>Streamline startup sequences and explicitly set the order of initialization.</p><p>Instead of defining separate <em>content providers</em> for each component you need to initialize, App Startup allows you to define component initializers that share a single content provider. This can significantly improve app startup time.</p></blockquote><p>介绍里提到了 ContentProvider，ContentProvider 会在应用启动（<code>Application#onCreate</code> 之前）初始化并回调 <code>onCreate</code>。基于此，很多三方库就会自定义 ContentProvider 并在 <code>onCreate</code> 中执行初始化操作，给库用户一种“不用初始化”的错觉，采用这种方式的三方库有 LeakCanary、WorkManager 等。</p><p>Trade-off 无处不在，这里也不例外。自定义 ContentProvider 虽然使库更易于使用，但代价是开销增加。</p><p>郭霖老师在<a target="_blank" rel="noopener" href="https://blog.csdn.net/guolin_blog/article/details/108026357">《Jetpack新成员，App Startup一篇就懂》</a>中提到，一个空 ContentProvider 也会有 2ms（特定机型）的耗时，一般初具规模的应用都会有几十上百三方库依赖，如果这些库都在启动期间初始化一个 ContentProvider，累计开销就会非常可观。</p><p>所以 App Startup 就提供一个统一的 ContentProvider，三方库们复用同一个组件，避免无意义的开销。</p><h3 id="简单上手"><a href="#简单上手" class="headerlink" title="简单上手"></a>简单上手</h3><p>每个初始化操作都被抽象成 <code>Initializer</code> 接口，开发者实现它并实现 <code>create</code> 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrInitializer</span> : <span class="type">Initializer</span>&lt;<span class="type">Unit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> create(context: Context) &#123;</span><br><span class="line">        <span class="comment">// staff here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">()</span></span>: List&lt;Class&lt;<span class="keyword">out</span> Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>AndroidManifest.xml</code> 中声明并注册你自定义的初始化类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">&quot;merge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.UrInitializer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果 <code>UrInitializer</code> 是其它某个 <code>Initliazer</code> 的依赖，则可以不在 <code>AndroidManifest</code> 声明。</p><p>另一个需要注意的是 value 取值需要写死 “androidx.startup”。</p></blockquote><p>这样 <code>UrInitializer#create</code> 就会在启动期间自动执行了。</p><p>如果你不想在启动期间自动初始化，而是需要时再初始化，可以在对应的 <code>meta-data</code> 节点下添加 <code>tools:node=&quot;remove&quot;</code>。然后在使用前手动触发初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AppInitializer.getInstance(context)</span><br><span class="line">    .initializeComponent(UrInitializer::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/app-startup">官网</a> 上有关于 App Startup 更详细的介绍。</p><h2 id="App-Startup-实现"><a href="#App-Startup-实现" class="headerlink" title="App Startup 实现"></a>App Startup 实现</h2><p>上面可以看到 App Startup 暴露的 API 非常少，自然它的实现也比较简单，核心逻辑在 <a target="_blank" rel="noopener" href="https://github.com/androidx/androidx/blob/androidx-main/startup/startup-runtime/src/main/java/androidx/startup/AppInitializer.java"><code>AppInistialzier</code></a> 中。</p><p>应用启动时，<a target="_blank" rel="noopener" href="https://github.com/androidx/androidx/blob/androidx-main/startup/startup-runtime/src/main/java/androidx/startup/InitializationProvider.java"><code>InitializationProvider#onCreate</code></a> 被调用，进而调用到 <code>AppInitializer#discoverAndInitialize</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> getContext();</span><br><span class="line">        AppInitializer.getInstance(context).discoverAndInitialize();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有 <code>Initializer</code> 发现与初始化都发生在 AppInitializer 里，下面就看下 <code>discoverAndInitialize</code> 中解析 Manifest 的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">discoverAndInitialize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ComponentName</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(mContext.getPackageName(),</span><br><span class="line">            InitializationProvider.class.getName());</span><br><span class="line">    <span class="type">ProviderInfo</span> <span class="variable">providerInfo</span> <span class="operator">=</span> mContext.getPackageManager()</span><br><span class="line">            .getProviderInfo(provider, GET_META_DATA);</span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">metadata</span> <span class="operator">=</span> providerInfo.metaData;</span><br><span class="line">    <span class="comment">// androidx.startup</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">startup</span> <span class="operator">=</span> mContext.getString(R.string.androidx_startup);</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; initializing = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; keys = metadata.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> metadata.getString(key, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!startup.equals(value)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(key);</span><br><span class="line">        <span class="keyword">if</span> (!Initializer.class.isAssignableFrom(clazz)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        doInitialize((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Initializer</span>&lt;?&gt;&gt;) clazz, initializing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>android:value=&quot;androidx.startup&quot;</code> 是起一个过滤的作用，所有 meta-data 会被解析成 Bundle 中的键值对。</p><p><code>doInitialize</code> 中使用 DFS 完成实际初始化操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> &lt;T&gt; T <span class="title function_">doInitialize</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Class&lt;? extends Initializer&lt;?&gt;&gt; component,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Set&lt;Class&lt;?&gt;&gt; initializing)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initializing.contains(component)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(</span><br><span class="line">                <span class="string">&quot;Cannot initialize %s. Cycle detected.&quot;</span>, component.getName()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">if</span> (mInitialized.containsKey(component)) &#123;</span><br><span class="line">        result = mInitialized.get(component);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initializing.add(component);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> component.getDeclaredConstructor().newInstance();</span><br><span class="line">        Initializer&lt;?&gt; initializer = (Initializer&lt;?&gt;) instance;</span><br><span class="line">        List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Initializer</span>&lt;?&gt;&gt;&gt; dependencies =</span><br><span class="line">                initializer.dependencies();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Initializer</span>&lt;?&gt;&gt; clazz : dependencies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInitialized.containsKey(clazz)) &#123;</span><br><span class="line">                <span class="comment">// DFS</span></span><br><span class="line">                doInitialize(clazz, initializing);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = initializer.create(mContext);</span><br><span class="line"></span><br><span class="line">        initializing.remove(component);</span><br><span class="line">        mInitialized.put(component, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doInitialize</code> 首先会判断依赖是否成环，确保不会出现死循环。</p><p>App Startup 核心代码不过百行，原理还是非常简单。</p><h2 id="不足与改进"><a href="#不足与改进" class="headerlink" title="不足与改进"></a>不足与改进</h2><p>虽然官方介绍 App Startup 能够优化启动期间三方库的初始化带来的多余性能开销，一定程度上简化代码，但是实际商业产品中有太多需要考虑的问题了，比如：</p><ul><li>任务优先级：App Startup 中 component 初始化顺序是不可控的，最先被用到的服务却不是第一个初始化，造成等待。</li><li>线程控制：App Startup 默认在主线程初始化，但是实际上很多库并不需要在主线程初始化，将这部分任务转移至子线程可以降低冷启动开销压力；同时线程还要支持优先级，保证重要任务尽快被执行。</li><li>多进程：某些库可能只在特定进程初始化并提供跨进程服务，比如 push 进程。</li><li>监听事件：优化冷启动性能时，凡是首屏之前不需要用到的服务都不应该初始化，那么就要在首屏上屏后发出通知并初始化。</li><li>耗时监控：商业产品还要对性能进行监控，避免性能劣化，冷启时间增加。</li></ul><p>GitHub 上有个 App Startup 增强版 —— <a target="_blank" rel="noopener" href="https://github.com/idisfkj/android-startup">android-startup</a> ，解决了一些不足，有兴趣的可以去学习一波。</p><p>后面也打算根据自己的理解造个轮子。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/app-startup">app-startup</a></p><p><a target="_blank" rel="noopener" href="https://android-developers.googleblog.com/2020/07/decrease-startup-time-with-jetpack-app.html">Decrease startup time with Jetpack App Startup</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SPI 原理</title>
      <link href="/2021/07/03/9e0c64b00d47.html"/>
      <url>/2021/07/03/9e0c64b00d47.html</url>
      
        <content type="html"><![CDATA[<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>SPI（Service Provider Interface） 是 JDK 6（1.6）引入的一种<strong>服务</strong>发现机制，这里 <em>Service</em> 通常是一个 <code>interface</code> 或 <code>class</code>，它定义了用户所能访问的接口； <em>Provider</em> 通常是 <em>Service</em> 实现类、子类或者定义了 <code>provider</code> 静态方法的任意类（JDK 9）。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfe718f36722c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SPI"></p><p>面向对象程序设计中，推荐模块之间基于接口，而不是具体的实现类进行交互，避免暴露具体的实现类及其装配过程（SOLID原则）。但如果只从程序设计角度看，还不足以支撑 JDK 引入 SPI，毕竟面向接口编程也不是什么难事，况且 SPI 还会有反射带来的性能损耗。分析 JDK 内置 SPI 的原因，可以从 JDK 内置的支持 SPI 的包去分析：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/Driver.html">Driver</a>：JDBC 4.0 开始支持 SPI，用户无需手动调用 <code>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;)</code> 注册驱动。</li><li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/persistence/spi/PersistenceProvider.html">PersistenceProvider</a>：JPA 服务接口。</li><li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/spi/LocaleServiceProvider.html">LocaleServiceProvider</a>：获取地区相关信息。</li></ul><p>可以看到 JDK 内置 SPI 都有一个共同特点，那就是只要将实现类所在的 jar 包安装到 classpath 或 modulepath 就可以自动被 JDK 加载，而不用调整代码。换言之，这些 jar 就是插件，在程序发布后还能根据需要安装不同插件，进而调整程序行为。</p><h2 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h2><p>SPI 描述了服务提供与发现的机制，ServiceLoader 则实现了对应的策略，提供切实可以的方式去定义与实现自己的 SPI。下面通过官方文档中的例子进行简要的说明。</p><h3 id="定义-SPI"><a href="#定义-SPI" class="headerlink" title="定义 SPI"></a>定义 SPI</h3><p>SPI 接口除不能描述服务提供者如何实现外，有两个一般准则：</p><ul><li>根据需要定义足够的接口。</li><li>接口需要服务提供者是直接实现接口还是作为 <em>proxy</em> 或 <em>factory</em> 间接提供服务（有点绕，其实是对 SPI 接口的一个分类，下面讨论）。</li></ul><p>下面是 ServiceLoader 文档中的接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CodecFactory</span> &#123;</span><br><span class="line">    Encoder <span class="title function_">getEncoder</span><span class="params">(String encodingName)</span>;</span><br><span class="line">    Decoder <span class="title function_">getDecoder</span><span class="params">(String encodingName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了编解码器工厂接口。一般来讲，编解码器的实例化开销都比较高（分配缓冲区），所以 <code>getEncoder</code> 和 <code>getDecoder</code> 提供了一个 <code>encodingName</code> 来指定需要的编解码器，如果是不支持的编解码格式，则直接返回 <code>null</code>，避免实例化所有编解码器后再一个个判断是否支持。这就是上面<strong>准则 2</strong>对应的 SPI 接口类型。</p><h3 id="实现、部署-SPI"><a href="#实现、部署-SPI" class="headerlink" title="实现、部署 SPI"></a>实现、部署 SPI</h3><p>在 JDK 9 支持 module 后，又新增了一种实现 SPI 接口的方式，直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since JDK 6</span></span><br><span class="line"><span class="keyword">package</span> com.example.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardCodecs</span> <span class="keyword">implements</span> <span class="title class_">CodecFactory</span> &#123;</span><br><span class="line">    Encoder <span class="title function_">getEncoder</span><span class="params">(String encodingName)</span> &#123; ... &#125;</span><br><span class="line">    Decoder <span class="title function_">getDecoder</span><span class="params">(String encodingName)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Since JDK 9</span></span><br><span class="line"><span class="keyword">package</span> com.example.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedCodecsFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StandardCodecs <span class="title function_">provider</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StandardCodecs</code> 直接实现 <code>CodecFactory</code> 并实现其中的两个方法，使用默认构造器初始化。JDK 9 之后我们可以使用声明了 “public static no-args method named ‘provider’ with a return type of Service” 的类作为服务提供者。</p><p><strong>在 JDK 9之前</strong>，以 jar 文件方式发布服务提供者还需要提供一个 <em>provider-configuration</em> 文件，列举所有服务提供者，使服务提供者能够被识别，配置文件存放在 <code>META-INF/services</code> 下面，文件名是 SPI 接口的全限定名，并写入服务提供者的全限定名作为内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#  META-INF/services/com.example.CodecFactory</span><br><span class="line">com.example.impl.StandardCodecs</span><br></pre></td></tr></table></figure><p>每一行就代表一个服务提供者，每一行 “#” 及后面的字符都会被忽略。</p><p><strong>如果以 module（JDK 9） 方式</strong> 发布服务提供者，则需要在 <em>module declaration</em> 使用 <code>provides</code> 指令声明服务提供者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> your.<span class="keyword">module</span>.name &#123;</span><br><span class="line">    ...</span><br><span class="line">    provides com.example.CodecFactory with com.example.impl.StandardCodecs;</span><br><span class="line">    provides com.example.CodecFactory with com.example.impl.ExtendedCodecsFactory;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明方式相比 jar 的 <em>provider-configuration</em> 要更集中一些。</p><h3 id="使用-SPI"><a href="#使用-SPI" class="headerlink" title="使用 SPI"></a>使用 SPI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);</span><br><span class="line"><span class="keyword">for</span>(CodecFactory factory: loader) &#123;</span><br><span class="line">    <span class="type">Encoder</span> <span class="variable">enc</span> <span class="operator">=</span> factory.getEncoder(<span class="string">&quot;PNG&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(enc != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// use enc to encode a PNG file</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用了 module，则还需要声明当前 module 为 Service 的消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> your.<span class="keyword">module</span>.name &#123;</span><br><span class="line">    uses com.example.impl.StandardCodecs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServiceLoader-实现"><a href="#ServiceLoader-实现" class="headerlink" title="ServiceLoader 实现"></a>ServiceLoader 实现</h3><p>不管是 JDK 9 之前还是之后，ServiceLoader 都是通过反射调用无参构造器或 <code>provider</code> 方法创建服务提供者实例。根据上面部署的方式，要拿到服务提供者，只需要读取到配置信息就可以了，即 ServiceLoader 的核心代码是配置信息的读取（个人看法）：</p><blockquote><p>核心代码在 ModuleServicesLookupIterator（JDK 9） 和 LazyClassPathLookupIterator 中，前者优先级更高。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceLoader#LazyClassPathLookupIterator#nextProviderClass</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; nextProviderClass() &#123;</span><br><span class="line">    <span class="comment">// configs: Enumeration&lt;URL&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// PREFIX: META-INF/services/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">        configs = loader.getResources(fullName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pending: Iterator&lt;String&gt;</span></span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> pending.next();</span><br><span class="line">    <span class="keyword">return</span> Class.forName(cn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceLoader 从 module 获取服务提供者相关部分比较复杂，所以只看解析部分吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceLoader#ModuleServicesLookupIterator#loadProvider</span></span><br><span class="line"><span class="keyword">private</span> Provider&lt;S&gt; <span class="title function_">loadProvider</span><span class="params">(ServiceProvider provider)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> provider.providerName();</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="keyword">module</span>, cn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if provider in explicit module then check for static factory method: provider</span></span><br><span class="line">    <span class="keyword">if</span> (inExplicitModule(clazz)) &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">factoryMethod</span> <span class="operator">=</span> findStaticProviderMethod(clazz);</span><br><span class="line">        <span class="keyword">if</span> (factoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; returnType = factoryMethod.getReturnType();</span><br><span class="line"></span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt; type = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt;) returnType;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProviderImpl</span>&lt;S&gt;(service, type, factoryMethod, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no factory method</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt; type = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt;) clazz;</span><br><span class="line">    Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt; ctor = getConstructor(clazz);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProviderImpl</span>&lt;S&gt;(service, type, ctor, acc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 9 module 加载之后，多个 module 会组成一个 module layer，一个 module layer 可以映射到多个 class loader，也即可以被多个 class loader 访问到里面的类。那么服务提供者会从当前 class loader 可访问的 module 开始搜索，然后从其 parent class loader 继续搜索直到 bootstrap class loader。可以看到 module 与相比 <em>provider-configuration</em> ，没有了读文件操作，理论上性能更优。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>网上一些文章都指出了 <code>ServiceLoader</code> 遍历性能会有点差，这中间的瓶颈在文件 IO（JDK 9 module 中无），因为需要遍历 classpath。当发布后的程序不要支持插件这种动态能力，这种无意义的性能开销就需要被规避。常用的优化手段有缓存和静态服务注册表，后者可能就不会使用 <code>ServiceLoader</code> 实现了。</p><p>至于 ServiceLoader 不是线程安全的缺点，很多类库都不是线程安全的好伐，这个缺点太牵强了！！！</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a></p><p><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-spi">Java Service Provider Interface</a></p><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html">Introduction to the Service Provider Interfaces</a></p><p><a target="_blank" rel="noopener" href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">Understanding Java 9 Modules</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《DangerFFmpeg》结语</title>
      <link href="/2021/06/10/53525ea83b2b.html"/>
      <url>/2021/06/10/53525ea83b2b.html</url>
      
        <content type="html"><![CDATA[<p>本文是 《DangerFFmpeg》系列教程结语，系列完整目录：<br>《<a href="/2021/05/14/8cf36b195b05.html">开篇</a>》<br>《<a href="/2021/05/15/1c458d50c524.html">第一节、屏幕截图</a>》<br>《<a href="/2021/05/16/aeb0b6c30d08.html">第二节、输出到屏幕</a>》<br>《<a href="/2021/05/20/d4b63d917433.html">第三节、播放声音</a>》<br>《<a href="/2021/05/22/71765970ad7e.html">第四节、多线程</a>》<br>《<a href="/2021/05/30/088658998748.html">第五节、视频同步</a>》<br>《<a href="/2021/06/05/d8b51b0cff00.html">第六节、同步音频</a>》<br>《<a href="/2021/06/09/2f01ccb59968.html">第七节、快进快退</a>》<br>《<a href="/2021/06/19/7ddfef63d330.html">结语</a>》</p><p>系列所有代码托管在 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><hr><h2 id="还有什么？"><a href="#还有什么？" class="headerlink" title="还有什么？"></a>还有什么？</h2><p>我们完成了一个可以工作的播放器，但肯定没有想象中那么好。我们做了很多功能，但是还有很多其它的能力可以添加：</p><ul><li>让我们面对现实，这个播放器挺糟糕的。我们基于的 ffplay 早就过时了，因此这个系列的教程需要一次大翻修。如果你想更进一步，使用 FFmpeg 完成更加正式的项目，我建议你下一步就去研究最新版的 ffplay。</li><li>错误处理。我们代码中的错误处理聊胜于无，这一块有很大的提升空间。</li><li>暂停。我们无法暂停，但是暂停显然是一个非常重要的功能。我们可以创建一个暂停标识位，当用户暂停时为其赋值，然后音频视频解码线程也会检查这个变量，停止解码。我们也可以用 <code>av_read_play</code> 支持网络。这很好解释，但是自己可能就不太好理解，可以考虑将这个作为课后作业，如果你打算进一步学习的话。小提示，可以参考 ffplay。</li><li>支持硬件加速。</li><li>按比特快进快退。如果你以字节而不是秒来计算快进快退的位置，在一些有非连续时间戳的视频上将会更加精确，比如 VOB 文件。</li><li>丢弃帧。如果视频进度落后太多，我们应该丢弃下一帧而不是缩短刷新间隔。</li><li>支持网络。我们的播放器现在还不支持播放在线资源。</li><li>支持原始视频数据，比如 YUV。如果支持 YUV 数据，需要配置一些参数才能播放，因为我们不能猜画面大小和时间基。</li><li>全屏播放。</li><li>更多选项，比如不同的图像格式；可以查看 ffplay 所支持的命令行参数。</li></ul><p>如果你想更进一步了解 FFmpeg，我们已经学习了一部分，下一步应该是要学习<strong>编码多媒体文件</strong>。FFmpeg 官方示例的 <code>output_example.c</code> 是一个不错的学习起点。我（原作者）也可能编写另一个关于编码的教程，但是现在还没有计划。</p><p><strong>UPDATE</strong></p><p>距离我上次更新已经过去很久了，音视频领域的软件变得更加成熟。这个教程只需要简单的 API 更新，一些基本概念上几乎没有变化。大多数的更新实际上只是简化了代码。然而，虽然我们重新审查并更新了教程中的代码，但是 ffplay 还是要比这个玩具优秀得多。坦率来说，作为一个真正的播放器，它的可用性几乎为零。所以，如果你或者未来想优化这个教程，去看看 ffplay ，看看我们缺少了那些能力。我猜大概是 ffplay 充分利用了硬件加速，不过我也可能遗漏了一些明显的事情。ffplay 可能发生了翻天覆地的变化，我很久没有看了。</p><p>但是我非常自豪，过去这么多年，这个教程还在帮助非常多的人。即使你需要去其它地方才能获取源代码。我非常感谢 <a target="_blank" rel="noopener" href="https://github.com/chelyaev/ffmpeg-tutorial">chelyaev</a> 将我 8！年前的代码中过时的 API 全部更新。</p><p>嗯，我希望这个能够指导一些人并且有趣。如果你对这篇教程有任何建议，发现错误，不同看法或赞誉，请通过 <a href="mailto:danger@gmail.com">danger@gmail.com</a> 联系我。请不要问我关于你 ffmpeg 项目的问题，因为我收到太多这样的邮件了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/end.html">原文链接</a></p><p><a target="_blank" rel="noopener" href="https://www.ffmpeg.org/">ffmpeg home page</a></p><p><a target="_blank" rel="noopener" href="http://www.inb.uni-luebeck.de/~boehme/using_libavcodec.html">Martin Bohme’s original tutorial</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
            <tag> SDL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《DangerFFmpeg》第七节、快进快退</title>
      <link href="/2021/06/09/eb12643f5d1e.html"/>
      <url>/2021/06/09/eb12643f5d1e.html</url>
      
        <content type="html"><![CDATA[<p>本文是 《DangerFFmpeg》系列教程第七节，系列完整目录：<br>《<a href="/2021/05/14/8cf36b195b05.html">开篇</a>》<br>《<a href="/2021/05/15/1c458d50c524.html">第一节、屏幕截图</a>》<br>《<a href="/2021/05/16/aeb0b6c30d08.html">第二节、输出到屏幕</a>》<br>《<a href="/2021/05/20/d4b63d917433.html">第三节、播放声音</a>》<br>《<a href="/2021/05/22/71765970ad7e.html">第四节、多线程</a>》<br>《<a href="/2021/05/30/088658998748.html">第五节、视频同步</a>》<br>《<a href="/2021/06/05/d8b51b0cff00.html">第六节、同步音频</a>》<br>《<a href="/2021/06/09/2f01ccb59968.html">第七节、快进快退</a>》<br>《<a href="/2021/06/19/7ddfef63d330.html">结语</a>》</p><p>系列所有代码托管在 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><hr><h2 id="响应快进快退操作"><a href="#响应快进快退操作" class="headerlink" title="响应快进快退操作"></a>响应快进快退操作</h2><p>我们现在准备给播放器添加快进快退功能，因为当你不能快退视频时确实很令人烦躁。另外，这篇教程也会让你看到 <code>av_seek_frame</code> 的使用非常简单。</p><p>我们让左方向键和右方向键快退或快进一点，比如10s，同时上方向键和下方向键快进或快退稍多一点，比如 60s。所以我们需要再修改下主事件循环以响应键盘事件。然而，当我们收到按键事件时，我们不能直接调用 <code>av_seek_frame</code>，需要在解封装循环里完成，即 <code>decodeThread</code>。所以，我们再往 <code>VideoState</code> 添加一些变量，用来表示快进快退的位置和标识位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> seekReq;</span><br><span class="line"><span class="type">int</span> seekFlags;</span><br><span class="line"><span class="type">int64_t</span> seekPos;</span><br></pre></td></tr></table></figure><p>现在我们需要修改事件循环，响应按键事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!is-&gt;quit) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SDL_KEYDOWN:</span><br><span class="line">      incr = <span class="number">0.0</span>;</span><br><span class="line">      <span class="keyword">switch</span> (event.key.keysym.sym) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDLK_LEFT:</span><br><span class="line">          incr = <span class="number">-3.0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDLK_RIGHT:</span><br><span class="line">          incr = <span class="number">3.0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDLK_UP:</span><br><span class="line">          incr = <span class="number">5.0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDLK_DOWN:</span><br><span class="line">          incr = <span class="number">-5.0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (incr != <span class="number">0.0</span>) &#123;</span><br><span class="line">        pos = <span class="built_in">getMasterClock</span>(is);</span><br><span class="line">        pos += incr;</span><br><span class="line">        spdlog::<span class="built_in">info</span>(<span class="string">&quot;seek: &#123;0&#125; - &#123;1&#125;&quot;</span>, incr, pos);</span><br><span class="line">        <span class="built_in">streamSeek</span>(is, <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(pos * AV_TIME_BASE), incr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要检测是否有按键事件，首先看是否收到 <code>SDL_KEYDOWN</code> 事件，然后通过 <code>event.key.keysym.sym</code> 检测哪个按键被按下。知道快进快退的具体方式（上下左右）后，通过将对应的偏移与 <code>getMasterClock</code> 返回的时钟相加计算出要快进快退到的位置。然后调用 <code>streamSeek</code> 移动到对应的位置。我们将快进快退位置的时间戳转换为解码器内部时间单位。回想一下，数据流的时间戳是以帧为单位而不是秒，计算公式是：<code>seconds = frames * time_base (fps)</code>。FFmpeg 编解码器默认 fps 是 1,000,000（所以 2s 会被转换成 2,000,000）。后面会看到我们为什么要进行这一层转换。</p><p>下面是 <code>streamSeek</code> 函数。注意我们在快退的时候才设置 flag：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">streamSeek</span><span class="params">(VideoState* is, <span class="type">int64_t</span> pos, <span class="type">int</span> rel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;seekReq) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;seekReq = <span class="literal">true</span>;</span><br><span class="line">  is-&gt;seekFlags = rel &lt; <span class="number">0</span> ? AVSEEK_FLAG_BACKWARD : <span class="number">0</span>;</span><br><span class="line">  is-&gt;seekPos = pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们回到 <code>decodeThread</code>，在这里我们会执行实际的快进快退操作。你会发现源代码中我们用 “seek stuff goes here” 标记了一个代码区域，我们会在那里实现快进快退的代码。</p><p>快进快退围绕 <code>av_seek_frame</code> 实现，这个函数接收一个 <code>AVFormatContext</code>，<code>AVStream</code> 的索引，时间戳以及一个标识位作为参数，它会快进快退到时间戳指定的位置，时间戳的单位是 <code>AVStream.time_base</code>，不过 <code>AVStream</code> 索引参数不是必选的（不指定时传 -1）。如果不传索引，那么 <code>time_base</code> 就是编解码器内部时间戳单位，或者说 1,000,000。这就是为什么我们要使用 <code>AV_TIME_BASE</code> 乘以 <code>seekPos</code>。</p><p>然而，有时候流索引传入 -1 在某些文件格式上会出现问题（极少情况），所以为了兼容性，我们将文件中第一个流传递给 <code>av_seek_frame</code> 。别忘了将时间戳转换成对应流的 <code>time_base</code> 单位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;seekReq) &#123;</span><br><span class="line">  <span class="type">int</span> streamIndex = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int64_t</span> seekTarget = is-&gt;seekPos;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;videoStream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    streamIndex = is-&gt;videoStream;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;audioStream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    streamIndex = is-&gt;audioStream;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (streamIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    seekTarget = <span class="built_in">av_rescale_q</span>(seekTarget, AV_TIME_BASE_Q, pFormatCtx-&gt;streams[streamIndex]-&gt;time_base);</span><br><span class="line">  &#125;</span><br><span class="line">  spdlog::<span class="built_in">info</span>(<span class="string">&quot;seek to &#123;0&#125;&quot;</span>, seekTarget);</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">av_seek_frame</span>(is-&gt;formatCtx, streamIndex, seekTarget, is-&gt;seekFlags);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    spdlog::<span class="built_in">error</span>(<span class="string">&quot;&#123;0&#125;:&#123;1&#125; error while seeking!&quot;</span>, is-&gt;filename, ret);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* handle packet queues... more later... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;seekReq = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>av_rescale_q</code>(a,b,c) 函数将时间戳从一个 <code>time_base</code> 转换成另一个 <code>time_base</code> 表示，计算可以简单理解成 <code>a*b/c</code>，虽然计算很简单，但是还是需要使用这个函数，因为计算可能发生溢出。<code>AV_TIME_BASE_Q</code> 是 <code>AV_TIME_BASE</code> 的分数表示，它们的区别体现在：<code>AV_TIME_BASE * time_in_seconds = avcodec_timestamp</code> 以及 <code>AV_TIME_BASE_Q * avcodec_timestamp = time_in_seconds</code> （注意 <code>AV_TIME_BASE_Q</code> 实际上是 <code>AVRational</code> 对象，所以你需要使用特殊的 q 函数进行处理）。</p><h2 id="清理缓冲"><a href="#清理缓冲" class="headerlink" title="清理缓冲"></a>清理缓冲</h2><p>我们通过 <code>av_seek_frame</code> 移动到了正确的位置，但是事情还没有结束，因为我们还有一个数据包队列的缓冲需要处理。在 <code>decodeThread</code> 中，我们需要清理队列，否则快进快退不能正常工作。除了我们定义的缓冲，编解码器内部也有缓冲需要清理。</p><p>为了清理缓冲，我们首先要定义一个清理队列的函数。然后我们需要告诉解码器清理内部缓冲。我们可以在清理队列后再放入一个特殊的数据包，然后当读取到这个数据包时，对应的 <code>videoThread</code> 和 <code>audioThread</code> 就会清理解码器中的缓冲。</p><p>让我们开始编写队列清理函数。实现非常简单，所以我就只贴代码了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">packetQueueFlush</span><span class="params">(PacketQueue* q)</span> </span>&#123;</span><br><span class="line">  AVPacketList *pkt, *pkt1;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">lock_guard</span>&lt;std::mutex&gt;(*(q-&gt;mtx));</span><br><span class="line">  <span class="keyword">if</span> (q-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (pkt = q-&gt;firstPkt; pkt != <span class="literal">nullptr</span>; pkt = pkt1) &#123;</span><br><span class="line">    pkt1 = pkt-&gt;next;</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(&amp;(pkt-&gt;pkt));</span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;pkt);</span><br><span class="line">  &#125;</span><br><span class="line">  q-&gt;lastPkt = <span class="literal">nullptr</span>;</span><br><span class="line">  q-&gt;firstPkt = <span class="literal">nullptr</span>;</span><br><span class="line">  q-&gt;nbPackets = <span class="number">0</span>;</span><br><span class="line">  q-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在队列清理干净了，让我们再将一个特殊数据包（flush packet）放入队列。不过我们要先声明并初始化这个包：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PacketQueue</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  AVPacket flushPkt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">packetQueueInit</span><span class="params">(PacketQueue* queue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  queue-&gt;flushPkt.data = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;FLUSH&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们把这个包放入队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle packet queues... more later... */</span></span><br><span class="line"><span class="keyword">if</span> (is-&gt;audioStream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">packetQueueFlush</span>(&amp;is-&gt;audioQueue);</span><br><span class="line">  <span class="built_in">packetQueuePut</span>(&amp;is-&gt;audioQueue, &amp;is-&gt;audioQueue.flushPkt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (is-&gt;videoStream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">packetQueueFlush</span>(&amp;is-&gt;videoQueue);</span><br><span class="line">  <span class="built_in">packetQueuePut</span>(&amp;is-&gt;videoQueue, &amp;is-&gt;videoQueue.flushPkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也需要调整 <code>packetQueuePut</code> 函数避免多次引用 <code>flushPkt</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">packetQueuePut</span><span class="params">(PacketQueue* queue, AVPacket* pkt)</span> </span>&#123;</span><br><span class="line">  AVPacketList* pktl;</span><br><span class="line">  AVPacket* dst = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">  <span class="keyword">if</span> (pkt != &amp;queue-&gt;flushPkt &amp;&amp; <span class="built_in">av_packet_ref</span>(dst, pkt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">av_packet_free</span>(&amp;dst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在音频解码函数和视频解码函数中，我们在 <code>packetQueueGet</code> 后调用 <code>avcodec_flush_buffers</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">audioDecodeFrame</span><span class="params">(VideoState* is, <span class="type">uint8_t</span>* buf, <span class="type">int</span> bufSize, <span class="type">double</span>* ptsPtr)</span> </span>&#123;</span><br><span class="line">  AVPacket pkt;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">packetQueueGet</span>(&amp;is-&gt;audioQueue, &amp;pkt, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pkt.data == is-&gt;audioQueue.flushPkt.data) &#123;</span><br><span class="line">    <span class="built_in">avcodec_flush_buffers</span>(is-&gt;audioCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>视频的处理和上面一样。</p><p>这就是全部内容了，编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main.sh assets/ohayo_oniityan.mp4</span></span><br></pre></td></tr></table></figure><p>尽情把玩你的不到 1000 行 C++ 语言制作的电影播放器​​吧！</p><p>当然，有很多我们使用过的功能可以添加。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/tutorial07.html">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
            <tag> SDL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《DangerFFmpeg》第六节、同步音频</title>
      <link href="/2021/06/05/de78c0e3e388.html"/>
      <url>/2021/06/05/de78c0e3e388.html</url>
      
        <content type="html"><![CDATA[<p>本文是 《DangerFFmpeg》系列教程第六节，系列完整目录：<br>《<a href="/2021/05/14/8cf36b195b05.html">开篇</a>》<br>《<a href="/2021/05/15/1c458d50c524.html">第一节、屏幕截图</a>》<br>《<a href="/2021/05/16/aeb0b6c30d08.html">第二节、输出到屏幕</a>》<br>《<a href="/2021/05/20/d4b63d917433.html">第三节、播放声音</a>》<br>《<a href="/2021/05/22/71765970ad7e.html">第四节、多线程</a>》<br>《<a href="/2021/05/30/088658998748.html">第五节、视频同步</a>》<br>《<a href="/2021/06/05/d8b51b0cff00.html">第六节、同步音频</a>》<br>《<a href="/2021/06/09/2f01ccb59968.html">第七节、快进快退</a>》<br>《<a href="/2021/06/19/7ddfef63d330.html">结语</a>》</p><p>系列所有代码托管在 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><p>我们已经完成了一个能够称得上播放器的视频播放器，所以让我们看看我们实现了什么东西。上节教程中，我们稍微优化了同步，即将视频时钟同步到音频时钟，而不是其它方式。我们将做与视频类似的事：创建一个内部视频时钟以跟踪视频线程的时间并将音频同步到该时钟。后面我们也会看到如何进行抽象，将音频和视频同步到外部时钟。</p><hr><h2 id="实现视频时钟"><a href="#实现视频时钟" class="headerlink" title="实现视频时钟"></a>实现视频时钟</h2><p>现在我们想要实现一个类似上节教程中音频时钟的视频时钟：一个内部值，给出视频从播放到现在的时间偏移。起初，你可能认为视频时钟就是简单地用上一帧的 PTS 更新。然而，不要忘了视频帧中间的时间间隔在毫秒级别下会非常大。解决办法增加另一个变量，记录我们什么时候将视频时钟更新为上一帧的 PTS。视频时钟真实值是 <code>PTS_of_last_time + (current_time - time_elapsed_since_PTS_value_was_set)</code>。这个方案和 <code>getAudioClock</code> 类似。</p><p>所以，在 <code>VideoState</code> 中增加 <code>double videoCurrentPts</code> 和 <code>int64_t videoCurrentPtsTime</code>。时钟更新操作在 <code>videoRefreshTimer</code> 中进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">VideoPicture* vp = &amp;is-&gt;picQueue[is-&gt;pqRIndex];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update video clock</span></span><br><span class="line">is-&gt;videoCurrentPts = vp-&gt;pts;</span><br><span class="line">is-&gt;videoCurrentPtsTime = <span class="built_in">av_gettime</span>();</span><br></pre></td></tr></table></figure><p>不要忘了在 <code>streamComponentOpen</code> 中初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;videoCurrentPtsTime = <span class="built_in">av_gettime</span>();</span><br></pre></td></tr></table></figure><p>然后，剩下的就是提供获取视频时钟的方法 —— <code>getVideoClock</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">getVideoClock</span><span class="params">(VideoState* is)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> delta = (<span class="built_in">av_gettime</span>() - is-&gt;videoCurrentPtsTime) / <span class="number">1000000.0</span>;</span><br><span class="line">  <span class="keyword">return</span> is-&gt;videoCurrentPts + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象时钟"><a href="#抽象时钟" class="headerlink" title="抽象时钟"></a>抽象时钟</h2><p>不过为什么要限制使用视频时钟呢？我们需要调整一下视频同步的代码，避免音频和视频相互同步。想象一下如果我们提供类似 ffplay 命令行选项，这将是一个混乱的场景。所以让我们进行一些抽象：我们创建一个新的套娃函数，<code>getMasterClock</code> 判断 <code>avSyncType</code> 然后选择性调用 <code>getAudioClock</code> 、<code>getVideoClock</code> 或 其它任何我们想要使用的时钟。我们甚至可以使用系统的时钟，暂时叫做 <code>getExternalClock</code> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AvSyncMaster</span> &#123;</span><br><span class="line">  AV_SYNC_AUDIO_MASTER,</span><br><span class="line">  AV_SYNC_VIDEO_MASTER,</span><br><span class="line">  AV_SYNC_EXTERNAL_MASTER,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> AvSyncMaster DEFAULT_AV_SYNC_TYPE = AV_SYNC_VIDEO_MASTER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getMasterClock</span><span class="params">(VideoState* is)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;avSyncType == AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getVideoClock</span>(is);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;avSyncType == AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getAudioClock</span>(is);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getExternalClock</span>(is);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    is-&gt;avSyncType = DEFAULT_AV_SYNC_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步音频"><a href="#同步音频" class="headerlink" title="同步音频"></a>同步音频</h2><p>接下来是最难的部分：将音频时钟同步到视频时钟。我们的策略是确定当前的音频时钟，与视频时钟做比较，然后计算出我们需要调整多少采样，即我们需要丢弃一些采样以加速还是增加一些来降低播放速度？</p><p>每次处理一组音频采样数据时，我们执行一个 <code>synchronizeAudio</code> 函数，以便对采样数据进行填充或压缩。然而，我们不想处理每一个采样数据时进行同步，因为音频解码的频率要比视频多得多。所以在开始做任何事情前，我们设置一个最小的连续调用 <code>synchronizeAudio</code> 且不同步的次数。当然，就像上次一样，“out of sync“ 指的时音频时钟和视频时钟的差值超过特定阈值。</p><p>假设我们已经拿到了 <strong>N</strong> 个不同步的音频采样。每个采样不同步的偏移量可能相差很大，所以我们计算这些采样数据的偏移的平均值。比如，第一次调用时 <code>synchronizeAudio</code> 时计算出偏移 <em>40ms</em>，第二次是 <em>50ms</em>，以此类推。但是我们不打算使用算数平均，因为最新的数据要比之前的数据重要，所以我们使用一个小数系数，叫做 <code>c</code>，然后将这些偏移按这样进行相加：<code>diff_sum = new_diff + diff_sum * c</code>。当我们计算平均偏移时，简单地计算 <code>avg_diff = diff_sum * (1 - c)</code> 作为平均偏移。</p><p>目前为止， <code>synchronizeAudio</code> 是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add or substract samples to get a better sync, return new audio buffer size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">synchronizeAudio</span><span class="params">(VideoState* is, <span class="type">uint8_t</span>* samples, <span class="type">int</span> samplesSize, <span class="type">double</span> pts)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;avSyncType == AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">    <span class="keyword">return</span> samplesSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> refClock = <span class="built_in">getMasterClock</span>(is);</span><br><span class="line">  <span class="type">double</span> diff = <span class="built_in">getAudioClock</span>(is) - refClock;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (diff &gt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">    <span class="comment">// difference is TOO big, reset diff stuff</span></span><br><span class="line">    is-&gt;audioDiffAvgCount = <span class="number">0</span>;</span><br><span class="line">    is-&gt;audioDiffCum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> samplesSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// accumulate the diffs</span></span><br><span class="line">  is-&gt;audioDiffCum = diff + is-&gt;audioDiffAvgCoef * is-&gt;audioDiffCum;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;audioDiffAvgCount &lt; AUDIO_DIFF_AVG_NB) &#123;</span><br><span class="line">    is-&gt;audioDiffAvgCount++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">double</span> avgDiff = is-&gt;audioDiffCum * (<span class="number">1.0</span> - is-&gt;audioDiffAvgCoef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shrinking/expanding buffer code ...</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> samplesSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一切看起来都挺顺利，我们知道了音频时钟与视频时钟或其它我们使用的时钟之间的偏移估计值。所以让我们在 “Shrinking&#x2F;expanding buffer code” 下方计算需要填充或丢弃多少采样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> avgDiff = is-&gt;audioDiffCum * (<span class="number">1.0</span> - is-&gt;audioDiffAvgCoef);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shrinking/expanding buffer code ...</span></span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">fabs</span>(avgDiff) &gt;= is-&gt;audioDiffThreshold) &#123;</span><br><span class="line">  <span class="type">int</span> bytesPerSample = <span class="number">4</span> * is-&gt;audioSt-&gt;codec-&gt;channels;</span><br><span class="line">  <span class="type">int</span> wantedSize = samplesSize + <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(diff * is-&gt;audioSt-&gt;codec-&gt;sample_rate * bytesPerSample);</span><br><span class="line">  <span class="type">int</span> minSize = samplesSize * ((<span class="number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>);</span><br><span class="line">  <span class="type">int</span> maxSize = samplesSize * ((<span class="number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  wantedSize = std::<span class="built_in">max</span>(wantedSize, minSize);</span><br><span class="line">  wantedSize = std::<span class="built_in">min</span>(wantedSize, maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住 <code>audio_length * (sample_rate * # of channels * 4)</code> 得到的结果是 <code>audio_length</code> 秒长度的音频的字节数。因此，我们想要的采样字节数量就是已有的采样字节数量加上或减去偏移量所对应的字节数量。我也会设置一个校正后数据大小的最大值和最小值，因为如果我对音频缓冲修改太多，到时用户听起来可能会有些刺耳。</p><blockquote><p>原文里的公式使用的 4 和前面教程的中 <code>SDL_AudioSpec</code> 音频格式是对应的。</p></blockquote><h2 id="校正采样数"><a href="#校正采样数" class="headerlink" title="校正采样数"></a>校正采样数</h2><p>现在我们需要去校正音频了。你可能注意到 <code>synchronizeAudio</code> 返回采样大小，返回值会告诉我们需要发送多少字节到 SDL 音频缓冲区。所以我们只需要将返回值设置为 <code>wantedSize</code> 就可以了。这在需要减少采样数据时是奏效的，但是如果需要扩充采样数据，我们不能直接将采样大小调大，因为缓冲区对应区域没有对应的音频采样数据！所以我们需要自行填充。但是填充什么内容呢？尝试预测音频是不可行的，所以我们直接使用最后一个音频采样进行填充。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wantedSize &lt; samplesSize) &#123;</span><br><span class="line">  <span class="comment">// remove samples</span></span><br><span class="line">  samplesSize = wantedSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wantedSize &gt; samplesSize) &#123;</span><br><span class="line">  <span class="comment">// add samples by copying final samples</span></span><br><span class="line">  <span class="type">int</span> nb = wantedSize - samplesSize;</span><br><span class="line">  <span class="type">uint8_t</span>* samplesEnd = samples + samplesSize - bytesPerSample;</span><br><span class="line">  <span class="type">uint8_t</span>* q = samplesEnd + bytesPerSample;</span><br><span class="line">  <span class="keyword">while</span> (nb &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(q, samplesEnd, bytesPerSample);</span><br><span class="line">    q += bytesPerSample;</span><br><span class="line">    nb -= bytesPerSample;</span><br><span class="line">  &#125;</span><br><span class="line">  samplesSize = wantedSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接返回 sampleSize，这个函数就结束了。然后要做的就是在 <code>audioCallback</code> 中使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">audioCallback</span><span class="params">(<span class="type">void</span>* userdata, <span class="type">uint8_t</span>* stream, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audioBufIndex &gt;= is-&gt;audioBufSize) &#123;</span><br><span class="line">      audioSize = <span class="built_in">audioDecodeFrame</span>(is, is-&gt;audioBuf, <span class="built_in">sizeof</span>(is-&gt;audioBuf), &amp;pts);</span><br><span class="line">      <span class="keyword">if</span> (audioSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        is-&gt;audioBufSize = <span class="number">1024</span>;</span><br><span class="line">        <span class="built_in">memset</span>(is-&gt;audioBuf, <span class="number">0</span>, is-&gt;audioBufSize);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        is-&gt;audioBufSize = <span class="built_in">synchronizeAudio</span>(is, is-&gt;audioBuf, audioSize, pts);</span><br><span class="line">      &#125;</span><br><span class="line">      is-&gt;audioBufIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们做的就是将 <code>synchronizeAudio</code> 调用插入。（记得检查一下源码我们在哪里初始化那些变量，我懒得定义了。）</p><p>完成之前还有最后一件事：我们需要添加个 <code>if</code> 判断，确保音频时钟是主时钟时不会进行视频同步：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;avSyncType != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">  <span class="comment">// udpate delay to sync to audio</span></span><br><span class="line">  <span class="type">double</span> refClock = <span class="built_in">getMasterClock</span>(is);</span><br><span class="line">  <span class="type">double</span> diff = vp-&gt;pts - refClock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// skip or repeat the frame. Take delay into account</span></span><br><span class="line">  <span class="comment">// FFplay still doesn&#x27;t &quot;know if this is the best guess.&quot;</span></span><br><span class="line">  <span class="type">double</span> syncThreshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">abs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= -syncThreshold) &#123;</span><br><span class="line">      delay = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= syncThreshold) &#123;</span><br><span class="line">      delay *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样！记得检查源码然后初始化那些我上面懒得定义和初始化的变量。然后编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main.sh assets/ohayo_oniityan.mp4</span></span><br></pre></td></tr></table></figure><p>源码已经上传 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a>，用餐愉快。</p><p>下一节中我们将实现快进快退。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/tutorial06.html">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
            <tag> SDL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《DangerFFmpeg》第五节、视频同步</title>
      <link href="/2021/05/30/64c8afe299e8.html"/>
      <url>/2021/05/30/64c8afe299e8.html</url>
      
        <content type="html"><![CDATA[<p>本文是 《DangerFFmpeg》系列教程第五节，系列完整目录：<br>《<a href="/2021/05/14/8cf36b195b05.html">开篇</a>》<br>《<a href="/2021/05/15/1c458d50c524.html">第一节、屏幕截图</a>》<br>《<a href="/2021/05/16/aeb0b6c30d08.html">第二节、输出到屏幕</a>》<br>《<a href="/2021/05/20/d4b63d917433.html">第三节、播放声音</a>》<br>《<a href="/2021/05/22/71765970ad7e.html">第四节、多线程</a>》<br>《<a href="/2021/05/30/088658998748.html">第五节、视频同步</a>》<br>《<a href="/2021/06/05/d8b51b0cff00.html">第六节、同步音频</a>》<br>《<a href="/2021/06/09/2f01ccb59968.html">第七节、快进快退</a>》<br>《<a href="/2021/06/19/7ddfef63d330.html">结语</a>》</p><p>系列所有代码托管在 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><p>上节教程中我们对代码进行了拆分，也正因如此，音视频同步实现也就比较简单了。</p><hr><blockquote><p><strong>CAVEAT</strong><br>原文写作时，音视频同步的代码取自于 ffplay。现在，ffplay 发生非常大的变化，ffmpeg 也有了非常多的优化，相应地，音视频同步策略也更新了。虽然本文的代码可以工作，但是还不够优雅，还有许多地方可以优化。</p></blockquote><h2 id="视频同步原理"><a href="#视频同步原理" class="headerlink" title="视频同步原理"></a>视频同步原理</h2><p>现在为止，我们开发了一个几乎没屌用的视频播放器，它能播放音频，也能播放视频，但是还不能叫做正常意义上的播放器。所以我们该怎么做呢？</p><h3 id="DTS-amp-PTS"><a href="#DTS-amp-PTS" class="headerlink" title="DTS &amp; PTS"></a>DTS &amp; PTS</h3><p>幸运的是，音频流和视频流里都含有应该以何种速度播放以及什么时候显示的信息。音频流有<strong>采样率</strong>，视频流有<strong>帧率</strong>。然而，如果我们简单地通过帧数和帧率相乘进行同步，有很大可能画面和音频会变得不同步。音频流中的数据包可能含有叫 DTS（decoding timestamp） 和 PTS（presentation timestamp）的信息。为了理解这两个值的含义，你需要了解视频编码存储的方式。一些视频格式，比如 MPEG，会使用到 <strong>B（bidirectional）帧</strong>，另外两种帧类型叫 <strong>I（Intro）帧</strong> 和 <strong>P（Predicted）</strong> 帧。 I 帧存储一张完整的图像；P 帧依赖于前面的 I 帧或 P 帧，存储了它们之间差量信息；B 帧与 P 帧类似，但是它同时依赖它前面与后面的帧！这就是为什么有时候<code>av_receive_frame</code> 既没有返回 <code>AVFrame</code> 又没有报错的原因。</p><p>让我们假设有一个视频，画面对应的帧序列排列：<code>I B B P</code>。在解码 B 帧之前，我们需要先解码 P。因此，编码后帧可能按照 <code>I P B B</code> 顺序存储。这就是为什么帧数据同时有 DTS 和 PTS 的原因。DTS 告诉解码器什么时候进行解码，PTS 告诉播放器什么时候渲染帧。对于这个例子，我们的视频流大概长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   PTS: 1 4 2 3</span><br><span class="line">   DTS: 1 2 3 4</span><br><span class="line">Stream: I P B B</span><br></pre></td></tr></table></figure><p>一般来讲，只有在使用了 B 帧的视频中 PTS 和 DTS 值是不相等的。</p><p>当我们从 <code>av_read_frame</code> 读取数据包（packet）时，包里就携带了 DTS 和 PTS。但是我们用到的是解码后的帧数据中的 PTS，并以此确定什么渲染。幸运的是，FFmpeg 提供了 <code>av_frame_get_best_effort_timestamp</code> 帮助我们获取 PTS。</p><blockquote><p><code>av_frame_get_best_effort_timestamp</code> 在 FFmpeg 4.4 中已经被标记为 deprecated 了，在系列尾声中，我们会解决代码中的 warning，使用新的 API 替换这些废弃的接口。</p></blockquote><h3 id="同步策略"><a href="#同步策略" class="headerlink" title="同步策略"></a>同步策略</h3><p>现在，我们知道了什么时候渲染帧，但是我们怎么编码实现呢？思路是这样的：在我们渲染完一帧后，计算出下一帧的渲染时间。然后启动一个定时器，在计算出的时间渲染下一帧，重复这个操作。和你猜想的一样，我们会用下一帧的 PTS 和当前系统时钟对比，计算出计时器定多久。这个方案可以工作，但是有两个问题需要特别处理。</p><p>首先，下一帧的 PTS 如何获取。你可能会想，我们可以直接通过帧率和当前帧的 PTS 计算出下一帧的 PTS。大多数情况下，这种方式是正确的。然而，一些视频的帧可能会重复显示，比如静止画面。这就意味着我们也需要持续显示当前帧特定时间。如果按照刚才的方式实现，很有可能视频播放速度就会变快。所以我们需要考虑这种情况。</p><p>第二个问题是，随着程序运行，音频和视频时钟之间差值越来越大，最后的结果就是音画不同步。理想情况下，我们不用担心这些问题。但是实际情况是，你的设备并不完美，很多视频文件也不完美。事实上，这种不完美才是计算机世界里的常态。</p><p>所以我们有三个选择：</p><ul><li>将音频同步到视频</li><li>将视频同步到音频</li><li>将音频和视频同步到外部时钟，比如系统时钟</li></ul><p>本次教程中，我们将会实现第二个策略。</p><h2 id="编码：获取视频帧-PTS"><a href="#编码：获取视频帧-PTS" class="headerlink" title="编码：获取视频帧 PTS"></a>编码：获取视频帧 PTS</h2><p>现在让我们看下相关实现。我们将需要向 <code>VideoState</code> 添加更多的属性，但是我们会在使用到的时候再添加。首先看到之前的 video 线程，还记得之前的教程话，我们会在这里获取数据包并进行解码。我们要做的就是从 <code>avcodec_receive_frame</code> 返回的帧数据中获取 PTS。第一步我们先从数据包中拿到 DTS，很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">packetQueueGet</span>(&amp;is-&gt;videoQueue, packet, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// means we quit getting packets</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> pts = <span class="number">0.0F</span>;</span><br><span class="line">  <span class="comment">// Decode video frame</span></span><br><span class="line">  ret = <span class="built_in">avcodec_send_packet</span>(is-&gt;videoCtx, packet);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">avcodec_receive_frame</span>(is-&gt;videoCtx, pFrame) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (packet-&gt;dts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">      pts = <span class="built_in">av_frame_get_best_effort_timestamp</span>(pFrame);</span><br><span class="line">    &#125;</span><br><span class="line">    pts *= <span class="built_in">av_q2d</span>(is-&gt;videoSt-&gt;time_base);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 DTS 值等于 <code>AV_NOPTS_VALUE</code>，将 <code>pts</code> 设置为 0。</p><p>嗯，非常简单。</p><p>最后我们把 pts 转换成了时间戳。<code>time_base</code> 取值等于 <code>1/framerate</code>（固定帧率的话），所以转换成秒单位时，我们直接乘以 <code>time_base</code> 就可以了。</p><h2 id="编码：使用-PTS-同步视频"><a href="#编码：使用-PTS-同步视频" class="headerlink" title="编码：使用 PTS 同步视频"></a>编码：使用 PTS 同步视频</h2><p>现在我们已经拿到了 pts，现在可以开始处理上面提到的两个问题了。我们定义一个 <code>synchronizeVideo</code> ，它会更新 PTS 以保持同步到特定时钟（但其实只是处理的帧多次显示的问题）。这个函数也会处理刚才提到的数据帧没有 PTS 的情况。同时，我们需要的记录下一帧何时渲染，这样才能保持帧率正确。我们可以定一个<strong>内部时钟</strong>记录启播到当前帧的时间（注意不是简单的拿当前时间和启播时间做差）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VideoState</span> &#123;</span><br><span class="line">  <span class="type">double</span> videoClock; <span class="comment">// pts of last decoded frame / predicted pts of next decoded frame</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>synchronizeVideo</code> 的实现，注释很详细了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">synchronizeVideo</span><span class="params">(VideoState* is, AVFrame* srcFrame, <span class="type">double</span> pts)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pts != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* if we have pts, set video clock to it */</span></span><br><span class="line">    is-&gt;videoClock = pts;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* if we aren&#x27;t given a pts, set it to the clock */</span></span><br><span class="line">    pts = is-&gt;videoClock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* udpate the video clock */</span></span><br><span class="line">  <span class="type">double</span> frameDelay = <span class="built_in">av_q2d</span>(is-&gt;videoSt-&gt;codec-&gt;time_base);</span><br><span class="line">  <span class="comment">/* if we are repeating a frame, adjust clock accordingly */</span></span><br><span class="line">  frameDelay += srcFrame-&gt;repeat_pict * (frameDelay / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  is-&gt;videoClock += frameDelay;</span><br><span class="line">  <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里考虑一帧多次展示的情况。将当前帧的</p><p>现在，拿到合适的 PTS 并且将数据帧入队：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// videoThread</span></span><br><span class="line">pts = <span class="built_in">synchronizeVideo</span>(is, pFrame, pts);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">queuePicture</span>(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>queuePicture</code> 只做了将 pts 写入 <code>VideoPicture</code> 的改动，所以需要给 <code>VideoPicture</code> 添加一个属性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VideoPicture</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">double</span> pts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queuePicture</span><span class="params">(VideoState* is, AVFrame* pFrame, <span class="type">double</span> pts)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ...sws_scale... */</span></span><br><span class="line">  vp-&gt;pts = pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经把带有 PTS 的 <code>VideoPicture</code> 写入了队列，让我们再来分析下视频刷新的函数 <code>videoRefreshTimer</code>。你应该还记得我们之前写死了 20ms 的刷新间隔，现在我们将看下如何计算出准确的刷新间隔。</p><p>我们的策略就是通过对比前一帧和当前帧的 PTS 来预测下一帧的 PTS。同时，我们需要将视频同步到音频时钟。我们将构造一个<strong>音频时钟（audio clock）</strong>：记录音频当前的播放到什么时间了，就像 MP3 上的数字时间一样。因为是视频同步到音频，所以 <code>videoRefreshTimer</code> 中会确认视频播放速度是快了还是慢了。</p><p>我们等会再看具体实现，现在假设我们有一个 <code>getAudioClock</code> 可以获取当前的音频时钟。拿到音频时钟后，如果发现音视频不同步，又要怎么做呢？直接快进到正确的帧会显得有点憨，我们需要更机智的方式。所以，我们对计算出的下帧刷新时间做适当调整：如果视频快了，就将刷新时间加倍；如果慢了就尽可能快地显示下一帧。调整完刷新时间或延时后，我们拿记录的内部时钟（<code>frameTimer</code>）和系统时钟做差。<code>frameTimer</code> 会累加每次视频刷新时计算的下一帧刷新时间&#x2F;延迟，换句话说，<code>frameTimer</code> 就是预期的下一帧刷新时间。我们简单地将延时相加，然后与系统时钟做差，得到的差值就是下次刷新的实际时延。纯文字描述可能优点绕，直接看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">videoRefreshTimer</span><span class="params">(<span class="type">void</span>* userdata)</span> </span>&#123;</span><br><span class="line">  VideoState* is = <span class="built_in">reinterpret_cast</span>&lt;VideoState*&gt;(userdata);</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;videoSt == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">scheduleRefresh</span>(is, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;picQueueSize == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">scheduleRefresh</span>(is, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  VideoPicture* vp = &amp;is-&gt;picQueue[is-&gt;pqRIndex];</span><br><span class="line">  <span class="type">double</span> delay = vp-&gt;pts - is-&gt;frameLastPts;  <span class="comment">// the pts from last time</span></span><br><span class="line">  <span class="keyword">if</span> (delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// if incorrect delay, use previous one</span></span><br><span class="line">    delay = is-&gt;frameLastDelay;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// save for next time</span></span><br><span class="line">  is-&gt;frameLastDelay = delay;</span><br><span class="line">  is-&gt;frameLastPts = vp-&gt;pts;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// udpate delay to sync to audio</span></span><br><span class="line">  <span class="type">double</span> audioClock = <span class="built_in">getAudioClock</span>(is);</span><br><span class="line">  <span class="type">double</span> diff = vp-&gt;pts - audioClock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// skip or repeat the frame. Take delay into account.</span></span><br><span class="line">  <span class="comment">// FFplay still doesn&#x27;t &quot;know if this is the best guess.&quot;</span></span><br><span class="line">  <span class="type">double</span> syncThreshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">abs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= -syncThreshold) &#123;</span><br><span class="line">      delay = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= syncThreshold) &#123;</span><br><span class="line">      delay *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;frameTimer += delay;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compute the READ delay</span></span><br><span class="line">  <span class="type">double</span> actualDelay = is-&gt;frameTimer - (<span class="built_in">av_gettime</span>() / <span class="number">1000000.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (actualDelay &lt; <span class="number">0.010</span>) &#123;</span><br><span class="line">    <span class="comment">// Really it should skip the picture instead</span></span><br><span class="line">    actualDelay = <span class="number">0.010</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scheduleRefresh</span>(is, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(actualDelay * <span class="number">1000</span> + <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(*(is-&gt;picQueueMutex))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// show the picture</span></span><br><span class="line">  <span class="built_in">videoDisplay</span>(is);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update queeu for next picture</span></span><br><span class="line">  <span class="keyword">if</span> (++is-&gt;pqRIndex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">    is-&gt;pqRIndex = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;picQueueSize--;</span><br><span class="line">  is-&gt;picQueueCond-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做几个检查：确保前一帧 PTS 和当前帧 PTS 的差值是合法的。如果不合法则复用上次计算结果。然后，计算出一个同步阈值，因为不可能做到绝对同步，只要差值在可接受范围内，就认为是同步的（人无法感知），ffplay 使用 0.01，即 10ms。最后，确保同步阈值不会比两个 PTS 之差小。最后控制刷新间隔最小不小于 10ms。</p><blockquote><p><code>std::abs(diff) &lt; AV_NOSYNC_THRESHOLD</code> 这个判断条件原文没有进行解释，我也没有理解这个条件的含义。<br>另一个疑问是，计算延时不应该是用下一帧 PTS 与当前帧 PTS 做差么？但是这里居然是用当前帧与上一帧做差，对于一帧需要重复展示多次的case，不就出问题了吗？前面的 synchronizeVideo 方法里计算的 videoClock 也基本没有起作用。<br>网上搜到的文章，都是这么直接“抄”的代码，只讲原理，不讲实现。等这个系列翻译完了分析下 ffplay 再回来填坑。</p></blockquote><p>我们向 <code>VideoState</code> 添加了一堆变量，记得别漏了。也别忘了在 <code>streamComponentOpen</code>初始化 <code>VideoState.frameTimer</code> 和 <code>VideoState.frameLastPts</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;frameTimer = <span class="built_in">av_gettime</span>()/ <span class="number">1000000.0</span>;</span><br><span class="line">is-&gt;frameLastPts = <span class="number">40</span>-e3;</span><br></pre></td></tr></table></figure><h2 id="同步：音频时钟"><a href="#同步：音频时钟" class="headerlink" title="同步：音频时钟"></a>同步：音频时钟</h2><p>现在是时候实现音频时钟了。我们可以在完成音频解码的 <code>audioDecodeFrame</code> 中更新音频时钟。记住，因为通常一个音频数据包可以解出多个音频帧，所以需要在两个地方更新时钟。第一个地方是拿到数据包后：将音频时钟设置为为数据包的 PTS。然后如果一个数据包有多个帧，我们可以通过计算每一帧的大小来估算音频时钟。所以当我们拿到数据包时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if update, update the audio clock w/pts</span></span><br><span class="line"><span class="keyword">if</span> (pkt.pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">  is-&gt;audioClock = <span class="built_in">av_q2d</span>(is-&gt;audioSt-&gt;time_base) * pkt.pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后解码得到音频帧时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keep audioClock update-to-date</span></span><br><span class="line"><span class="type">double</span> pts = is-&gt;audioClock;  <span class="comment">// used next time</span></span><br><span class="line"><span class="comment">// *pts_ptr = pts;</span></span><br><span class="line"><span class="type">int</span> bytesPerSample = <span class="number">4</span> * is-&gt;audioSt-&gt;codec-&gt;channels;</span><br><span class="line">is-&gt;audioClock += dataSize / bytesPerSample * is-&gt;audioSt-&gt;codec-&gt;sample_rate;</span><br></pre></td></tr></table></figure><p>一些细节：注释中有个 <code>pts_ptr</code> 变量，这个在下节将音频同步到视频时会用到（其实我也不知道会不会用到，可能因为实现不同而不会用到）。</p><p>现在我们终于可以实现 <code>getAudioClock</code> 函数了，然而它不是简单地返回 <code>is-&gt;audioClock</code>。注意我们在每次得到音频帧时更新音频时钟，但是如果你回顾一下 <code>audioCallback</code> 函数就会发现，将解码后的所有数据拷贝到音频缓冲区也是有时间开销的。这意味着 <code>is-&gt;audioClock</code> 可能比实际时钟要快。所以我们还要检查还剩有多少数据未被写入音频缓冲区。下面是完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Still not accurate */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getAudioClock</span><span class="params">(VideoState* is)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> pts = is-&gt;audioClock;  <span class="comment">// maintained in the audio thread</span></span><br><span class="line">  <span class="type">int</span> hwBufSize = is-&gt;audioBufSize - is-&gt;audioBufIndex;</span><br><span class="line">  <span class="type">int</span> bytesPerSample = is-&gt;audioSt-&gt;codec-&gt;channels * <span class="number">4</span>;</span><br><span class="line">  <span class="type">int</span> bytesPerSecond = is-&gt;audioSt-&gt;codec-&gt;sample_rate * bytesPerSample;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bytesPerSecond &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pts -= <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(hwBufSize) / bytesPerSecond;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你现在应该能够说出为什么这个函数起作用了;)</p><p>这就是所有内容了，编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main.sh assets/ohayo_oniityan.mp4</span></span><br></pre></td></tr></table></figure><p><img src="/img/2021/dangerffmpeg_threads.gif" alt="Sync video to audio"></p><blockquote><p>这张图其实还是上节教程的，反正没有声音你们大概率也看不出来差别 hhhh</p></blockquote><p>源码已经上传 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a>，请放心食用。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/tutorial05.html">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
            <tag> SDL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DangerFFmpeg】第四节、多线程</title>
      <link href="/2021/05/22/2ed076987343.html"/>
      <url>/2021/05/22/2ed076987343.html</url>
      
        <content type="html"><![CDATA[<p>本文是 《DangerFFmpeg》系列教程第四节，系列完整目录：<br>《<a href="/2021/05/14/8cf36b195b05.html">开篇</a>》<br>《<a href="/2021/05/15/1c458d50c524.html">第一节、屏幕截图</a>》<br>《<a href="/2021/05/16/aeb0b6c30d08.html">第二节、输出到屏幕</a>》<br>《<a href="/2021/05/20/d4b63d917433.html">第三节、播放声音</a>》<br>《<a href="/2021/05/22/71765970ad7e.html">第四节、多线程</a>》<br>《<a href="/2021/05/30/088658998748.html">第五节、视频同步</a>》<br>《<a href="/2021/06/05/d8b51b0cff00.html">第六节、同步音频</a>》<br>《<a href="/2021/06/09/2f01ccb59968.html">第七节、快进快退</a>》<br>《<a href="/2021/06/19/7ddfef63d330.html">结语</a>》</p><p>系列所有代码托管在 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面我们通过 SDL 的音频功能实现了音频播放能力，SDL 启动一个子线程并在需要音频数据的时候回调我们事先定义好的函数。现在我们将用类似的方式播放视频，这可以让代码更加模块化、更好管理，特别是当实现音视频同步时。那么我们从哪里开始聊呢？</p><p>首先我们注意到 <code>main</code> 函数做了太多事情：事件循环、读取数据包、解码视频。所以我们要做的就是把这些分开：我们将创建一个线程负责从流（stream）中读取数据包（packet），然后把它们添加到对应的队列中，并分别在 audio 线程和 video 线程中读取。我们在第二节中已经配置好了 audio 线程；video 线程将会有一点复杂，因为我们需要自己控制视频的播放。我们将把视频播放代码添加到主循环中，但是并不是每次循环播放一帧，而是将视频播放集成到 SDL 事件中。大致的思路就是解码视频并把帧数据（frame）保存到另一个队列（queue），然后创建自定义事件（FF_REFRESH_EVENT），然后当在事件循环中接收到这个事件时，它就会显示帧队列中的下一帧。下面是我们将要实现结构的 ASCII 插图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> ________ audio  _______      _____</span><br><span class="line">|        | pkts |       |    |     | to spkr</span><br><span class="line">| DECODE |-----&gt;| AUDIO |---&gt;| SDL |--&gt;</span><br><span class="line">|________|      |_______|    |_____|</span><br><span class="line">    |  video     _______</span><br><span class="line">    |   pkts    |       |</span><br><span class="line">    +----------&gt;| VIDEO |</span><br><span class="line"> ________       |_______|   _______</span><br><span class="line">|       |          |       |       |</span><br><span class="line">| EVENT |          +------&gt;| VIDEO | to monitor.</span><br><span class="line">| LOOP  |-----------------&gt;| DISP. |--&gt;</span><br><span class="line">|_______|&lt;---FF_REFRESH----|_______|</span><br></pre></td></tr></table></figure><p>使用事件循环控制视频播放的目的是，通过使用 <code>std::this_thread::delay</code> ，我们可以精确地控制下一帧画面什么显示在屏幕上。当我们在下一节中实现音视频同步的时候，可以非常简单地添加那些代码，确定下一次视频刷新时间使得画面能够<strong>在正确的时间</strong>显示在屏幕上。</p><h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><p>稍微清理一下代码。我们有所有的音频视频的编解码器信息，并且准备添加队列和缓冲区，还有其它的一些数据。所有的这些东西组合成一个逻辑单元，即视频（moive）。所以我们创建一个大的 <code>VideoState</code> 结构体保存这些信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VideoState</span> &#123;</span><br><span class="line">  AVFormatContext* formatCtx;</span><br><span class="line">  <span class="type">int</span> videoStream, audioStream;</span><br><span class="line"></span><br><span class="line">  AVStream* audioSt;</span><br><span class="line">  AVCodecContext* audioCtx;</span><br><span class="line">  PacketQueue audioQueue;</span><br><span class="line">  <span class="type">uint8_t</span> audioBuf[<span class="number">20480</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> audioBufSize;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> audioBufIndex;</span><br><span class="line">  AVPacket audioPkt;</span><br><span class="line"></span><br><span class="line">  AVStream* videoSt;</span><br><span class="line">  AVCodecContext* videoCtx;</span><br><span class="line">  PacketQueue videoQueue;</span><br><span class="line">  SwsContext* swsCtx;</span><br><span class="line"></span><br><span class="line">  std::thread decodeT;</span><br><span class="line">  std::thread videoT;</span><br><span class="line"></span><br><span class="line">  VideoPicture picQueue[VIDEO_PICTURE_QUEUE_SIZE];</span><br><span class="line">  <span class="type">int</span> pqWindex = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pqRIndex = <span class="number">0</span>;</span><br><span class="line">  std::mutex* picQueueMutex;</span><br><span class="line">  std::condition_variable* picQueueCond;</span><br><span class="line">  <span class="type">int</span> picQueueSize;</span><br><span class="line"></span><br><span class="line">  std::string filename;</span><br><span class="line"></span><br><span class="line">  SDL_Window* sdlWin;</span><br><span class="line">  SDL_Renderer* sdlRen;</span><br><span class="line">  SDL_Texture* sdlTex;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> quit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从结构体里大致知道我们接下来要获取什么信息。首先看到一些基本信息 —— <strong>格式上下文</strong>（AVFormatContext），<strong>音频视频流索引</strong> 以及对应的 <code>AVStream</code> 对象。可以看到音频相关的缓冲区也转移到了 <code>VideoState</code> 结构内。我们为视频新增了一个队列（queue）和用于存放解码后帧的缓冲区（buffer）。<code>VideoPicture</code> 也是新增的，后面会看到它的内部细节。然后我们也为将要创建的两个线程分配了两个 <code>std::thread</code> ，一个 <code>quit</code> 标识位和文件名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  VideoState *is;</span><br><span class="line"></span><br><span class="line">  is = <span class="built_in">reinterpret_cast</span>&lt;VideoState*&gt;(<span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(VideoState)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>av_mallocz</code> 函数的作用是申请内存并用 <code>0</code> 填充。</p><p>然后我们初始化帧缓冲队列（picQueue）的锁，因为我们在事件循环中调用渲染函数的会从帧缓冲队列中获取预先解码好的视频帧，同时，视频解码器也会将解码好的视频帧存入队列，我们不知道哪个操作先执行。你应该知道这是一个典型的<strong>竞态条件（race condition）</strong>。所以在启动任何线程前，先初始化好锁。然后将将要播放的文件名拷贝到 <code>VideoState</code> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;picQueueMutex = <span class="keyword">new</span> std::<span class="built_in">mutex</span>();</span><br><span class="line">is-&gt;picQueueCond = <span class="keyword">new</span> std::<span class="built_in">condition_variable</span>();</span><br><span class="line">is-&gt;filename = std::<span class="built_in">string</span>(argv[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h2 id="第一个线程：decodeThread"><a href="#第一个线程：decodeThread" class="headerlink" title="第一个线程：decodeThread"></a>第一个线程：decodeThread</h2><p>现在我们启动线程，开始工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;decodeT = std::<span class="built_in">thread</span>(decodeThread, is);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scheduleRefresh</span>(is, <span class="number">40</span>);</span><br></pre></td></tr></table></figure><p><code>scheduleRefresh</code> 将在后面定义，它实际上就是在延迟特定时间后触发 <code>FF_REFRESH_EVENT</code> 事件，收到事件后绘制下一帧视频。不过我们现在先把目光集中在 <code>std::thread</code> 上。</p><blockquote><p>原文是 C 实现，在 C++ 环境下，我们可以使用 <code>std::thread</code> 代替 <code>SDL_CreateThread</code> 去创建线程。</p></blockquote><p><code>std::thread</code> 会创一个新的线程，这个新的线程完全共享当前进程的内存地址空间，线程启动后执行指定的函数（<code>decodeThread</code>），并将参数传递给它。在这里，线程会执行 <code>decodeThread</code>，参数是 <code>VideoState*</code>。<code>decodeThread</code> 的前半部分没有新的知识，还是打开文件，查找音频流和视频流。唯一的不同是我们把获取到的信息保存在 <code>VideoState</code> 中。找到流后，我们调用另一个 <code>streamComponentOpen</code> 。音频和视频解码器的配置过程差不多，我们可以新增函数来复用这些相同的代码，这是非常自然的代码拆分方式。</p><p><code>streamCompoenentOpen</code> 会查找解码器，配置音频参数，将重要的信息保存在 <code>VideoState</code> 中，然后启动 audio 线程和 video 线程（audio 线程由 SDL 管理）。下面是相关代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">streamComponentOpen</span><span class="params">(VideoState* is, <span class="type">int</span> streamIndex)</span> </span>&#123;</span><br><span class="line">  AVFormatContext* pFormatCtx = is-&gt;formatCtx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (streamIndex &lt; <span class="number">0</span> || streamIndex &gt;= pFormatCtx-&gt;nb_streams) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AVCodec* pCodec = <span class="built_in">avcodec_find_decoder</span>(pFormatCtx-&gt;streams[streamIndex]-&gt;codec-&gt;codec_id);</span><br><span class="line">  <span class="keyword">if</span> (pCodec == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AVCodecContext* pCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(pCodec);</span><br><span class="line">  AVCodecParameters* pParams = <span class="built_in">avcodec_parameters_alloc</span>();</span><br><span class="line">  <span class="built_in">avcodec_parameters_from_context</span>(pParams, pFormatCtx-&gt;streams[streamIndex]-&gt;codec);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">avcodec_parameters_to_context</span>(pCodecCtx, pParams) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">avcodec_parameters_free</span>(&amp;pParams);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">avcodec_parameters_free</span>(&amp;pParams);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pCodecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">    <span class="comment">// setup SDL audio here</span></span><br><span class="line">    SDL_AudioSpec wantedSpec, spec;</span><br><span class="line">    wantedSpec.freq = pCodecCtx-&gt;sample_rate;</span><br><span class="line">    wantedSpec.format = AUDIO_F32;</span><br><span class="line">    wantedSpec.channels = pCodecCtx-&gt;channels;</span><br><span class="line">    wantedSpec.silence = <span class="number">0</span>;</span><br><span class="line">    wantedSpec.samples = pCodecCtx-&gt;channels * <span class="number">2</span>;</span><br><span class="line">    wantedSpec.callback = audioCallback;</span><br><span class="line">    wantedSpec.userdata = is;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SDL_OpenAudio</span>(&amp;wantedSpec, &amp;spec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      spdlog::<span class="built_in">error</span>(<span class="string">&quot;SDL_OpenAudio: &#123;s&#125;&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pCodecCtx, pCodec, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    spdlog::<span class="built_in">error</span>(<span class="string">&quot;Unsupported codec!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (pCodecCtx-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">      is-&gt;audioStream = streamIndex;</span><br><span class="line">      is-&gt;audioSt = pFormatCtx-&gt;streams[streamIndex];</span><br><span class="line">      is-&gt;audioCtx = pCodecCtx;</span><br><span class="line">      is-&gt;audioBufSize = <span class="number">0</span>;</span><br><span class="line">      is-&gt;audioBufIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">packetQueueInit</span>(&amp;is-&gt;audioQueue);</span><br><span class="line">      <span class="built_in">SDL_PauseAudio</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">      is-&gt;videoStream = streamIndex;</span><br><span class="line">      is-&gt;videoSt = pFormatCtx-&gt;streams[streamIndex];</span><br><span class="line">      is-&gt;videoCtx = pCodecCtx;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">packetQueueInit</span>(&amp;is-&gt;videoQueue);</span><br><span class="line"></span><br><span class="line">      is-&gt;videoT = std::<span class="built_in">thread</span>(videoThread, is);</span><br><span class="line">      <span class="comment">// initialize SWS context for software scaling</span></span><br><span class="line">      is-&gt;swsCtx = <span class="built_in">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width,</span><br><span class="line">                                  pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BILINEAR, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    defult:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码和上两节的差不多，不过现在它同时适用于音频和视频。还有一些小变化，我们使用 <code>VideoState*</code> 作为 <code>audioCallback</code> 的 userdata。 我们也将音频视频流分别使用 <code>audioSt</code> 和 <code>videoSt</code> 保存。同时，类似音频，我们为视频添加并配置了队列。最重要的点是启动 video 线程和 audio 线程，由这些代码完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">SDL_PauseAudio</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">  is-&gt;videoT = std::<span class="built_in">thread</span>(videoThread, is);</span><br></pre></td></tr></table></figure><p><code>SDL_PauseAudio</code> 前面的教程讲过，<code>std::thread</code> 和前面的使用方式一致。</p><p>回到 <code>decodeThread</code> 的后半部分，就是一个简单的 while 循环，不断的从流中读取数据包（packet）然后存入对应的队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!is-&gt;quit) &#123;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;audioQueue.size &gt; MAX_AUDIOQ_SIZE || is-&gt;videoQueue.size &gt; MAX_VIDEOQ_SIZE) &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AVPacket packet;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">av_read_frame</span>(is-&gt;formatCtx, &amp;packet) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;formatCtx-&gt;pb-&gt;error == <span class="number">0</span>) &#123;</span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is this a packet from video stream?</span></span><br><span class="line">  <span class="keyword">if</span> (packet.stream_index == is-&gt;videoStream) &#123;</span><br><span class="line">    <span class="built_in">packetQueuePut</span>(&amp;is-&gt;videoQueue, &amp;packet);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packet.stream_index == is-&gt;audioStream) &#123;</span><br><span class="line">    <span class="built_in">packetQueuePut</span>(&amp;is-&gt;audioQueue, &amp;packet);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">av_packet_unref</span>(&amp;packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除新增了队列大小检查和读取错误检查外，也没有什么新东西。 <code>AVFormatContext</code> 内部持有 <code>ByteIOContext</code> 类型的 <code>pb</code> 对象，<code>ByteIOContext</code> 保存了底层的文件信息。</p><p>While 循环结束后，会<strong>等待程序的其它部分结束</strong>或<strong>通知其它部分当前的解码工作结束</strong>了。这部分代码演示了如何发送自定义事件，后面我们也会使用同样的方式刷新视频：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!is-&gt;quit) &#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SDL_Event event;</span><br><span class="line">event.type = FF_QUIT_EVENT;</span><br><span class="line">event.user.data1 = is;</span><br><span class="line"><span class="built_in">SDL_PushEvent</span>(&amp;event);</span><br></pre></td></tr></table></figure><p>SDL 定义 <code>SDL_USEREVENT</code> 常量作为用户事件&#x2F;自定义事件的标识，第一个用户事件&#x2F;自定义事件需要使用 <code>SDL_USEREVENT</code> 进行赋值，第二个事件则是 <code>SDL_USEREVENT + 1</code>，以此类推。我本节程序中，<code>FF_QUIT_EVENT</code> 定义为 <code>SDL_USEREVENT + 1</code> 。自定义事件也可以根据情况传递用户数据（user data），这里我们传递的是 <code>VideoState</code>。最后调用 <code>SDL_PushEvent</code> 发送事件。在事件处理循环中，我们直接把 <code>FF_QUIT_EVENT</code> 放置到 <code>SDL_QUIT_EVENT</code> 中。后面会看到事件循环处理的详细实现，这里我们只需要保证 <code>FF_QUIT_EVENT</code> 发送后，我们能在捕获到这个事件并设置 <code>VideoState.quit</code> 。</p><h2 id="解码帧：video-thread"><a href="#解码帧：video-thread" class="headerlink" title="解码帧：video_thread"></a>解码帧：video_thread</h2><p>准备好解码器后，紧接着启动 video 线程进行解码。这个线程会从视频包队列中读取数据包（packet），然后将数据包发送到解码器进行解码，拿到解码后的视频帧后调用 <code>queuePicture</code> 将处理好的帧送入帧队列（<code>VideoState.picQueue</code>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">videoThread</span><span class="params">(VideoState* is)</span> </span>&#123;</span><br><span class="line">  AVFrame* pFrame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">  AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">packetQueueGet</span>(&amp;is-&gt;videoQueue, packet, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// means we quit getting packets</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decode video frame</span></span><br><span class="line">    ret = <span class="built_in">avcodec_send_packet</span>(is-&gt;videoCtx, packet);</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(packet);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">avcodec_receive_frame</span>(is-&gt;videoCtx, pFrame) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">queuePicture</span>(is, pFrame) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">av_frame_free</span>(&amp;pFrame);</span><br><span class="line">  spdlog::<span class="built_in">info</span>(<span class="string">&quot;decoding ends&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的大部分代码应该还比较熟悉，代码相比第二节做了简化。这里要注意是调用 <code>av_packet_unref</code> 解引用，调用 <code>av_frame_free</code> 释放内存。</p><h2 id="视频帧入队"><a href="#视频帧入队" class="headerlink" title="视频帧入队"></a>视频帧入队</h2><p>让我们看看将视频帧保存视频帧队列的函数。因为 <code>SDL_UpdateTexture</code> 可以直接接收原始 YUV 数据，所以我们直接在 <code>VideoPicture</code> 中保存 <code>AVFrame*</code>，下面是结构体的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VideoPicture</span> &#123;</span><br><span class="line">  AVFrame *frame;</span><br><span class="line">  <span class="type">int</span> width, height; <span class="comment">// source height &amp; width</span></span><br><span class="line">  <span class="type">bool</span> allocated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VideoState</code> 持有一个 <code>VideoPicture</code> 的数组（即帧队列）做为缓冲。然而，首次写入时需要分配一个 <code>AVFrame</code> 对象，后面可以复用了（注意这里添加 <code>allocated</code> 标识 <code>frame</code> 是否已经分配内存）。</p><p>为了把数组当成队列使用，我们还引入了两个“指针” —— 写索引和读索引。同时记录下缓冲队列中有多少可读帧数据。写入帧数据前要确保帧队列中有空闲区。然后我们检查将要写入的位置是否已经分配好了内存，没有则需要分配。当窗口大小发生变化时也需要重新分配！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">queuePicture</span><span class="params">(VideoState* is, AVFrame* pFrame)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* wait until we have space for a new pic */</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">((*is-&gt;picQueueMutex))</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (is-&gt;picQueueSize &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp; !is-&gt;quit) &#123;</span><br><span class="line">    is-&gt;picQueueCond-&gt;<span class="built_in">wait</span>(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is-&gt;quit) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// windex is set to 0 initially</span></span><br><span class="line">  VideoPicture* vp = &amp;is-&gt;picQueue[is-&gt;pqWindex];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate or resize the buffer</span></span><br><span class="line">  <span class="keyword">if</span> (vp-&gt;frame == <span class="literal">nullptr</span> || vp-&gt;width != is-&gt;videoSt-&gt;codec-&gt;width || vp-&gt;height != is-&gt;videoSt-&gt;codec-&gt;height) &#123;</span><br><span class="line">    vp-&gt;allocated = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">allocPic</span>(is);</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;quit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看下 <code>allocPic</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocPic</span><span class="params">(VideoState* is)</span> </span>&#123;</span><br><span class="line">  VideoPicture* vp = &amp;is-&gt;picQueue[is-&gt;pqWindex];</span><br><span class="line">  <span class="keyword">if</span> (vp-&gt;frame != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">av_free</span>(vp-&gt;frame-&gt;data);</span><br><span class="line">    <span class="comment">// we already have one make another, bigger/smaller</span></span><br><span class="line">    spdlog::<span class="built_in">info</span>(<span class="string">&quot;alloc a new frame&quot;</span>);</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;vp-&gt;frame);</span><br><span class="line">    vp-&gt;frame = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  spdlog::<span class="built_in">info</span>(<span class="string">&quot;fill the frame&quot;</span>);</span><br><span class="line">  <span class="comment">// Allocate a place to put our frame</span></span><br><span class="line">  vp-&gt;frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">  vp-&gt;width = is-&gt;videoSt-&gt;codec-&gt;width;</span><br><span class="line">  vp-&gt;height = is-&gt;videoSt-&gt;codec-&gt;height;</span><br><span class="line">  vp-&gt;allocated = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// Determine required buffer size and allocate buffer</span></span><br><span class="line">  <span class="type">int</span> nbBytes = <span class="built_in">avpicture_get_size</span>(AV_PIX_FMT_YUV420P, vp-&gt;width, vp-&gt;height);</span><br><span class="line">  <span class="type">uint8_t</span>* buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">av_malloc</span>(nbBytes * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign appropriate parts of the buffer to iamge planes in pFrameRGB</span></span><br><span class="line">  <span class="comment">// Note that pFrameRGB is an AVFrame, but AVFrame is superset</span></span><br><span class="line">  <span class="comment">// of AVPicture</span></span><br><span class="line">  <span class="built_in">avpicture_fill</span>(<span class="built_in">reinterpret_cast</span>&lt;AVPicture*&gt;(vp-&gt;frame), buffer, AV_PIX_FMT_YUV420P, vp-&gt;width, vp-&gt;height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到用于存放转换（<code>sws_scale</code>）后的 <code>AVFrame</code> 在这里进行了分配。记住我们把帧宽高保存到了 <code>VideoPicture</code> 中，因为我们要确保视频尺寸不会因某些原因发生变化。好了，我们分配好了 <code>AVFrame</code> 并准备接收帧数据。让我们回到 <code>queuePicture</code> 看看转换 <code>AVFrame</code> 的代码实现，你应该还熟悉这部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">queuePicture</span><span class="params">(VideoState* is, AVFrame* pFrame)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/* We have a place to put our picture on the queue */</span></span><br><span class="line">    <span class="built_in">sws_scale</span>(is-&gt;swsCtx, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>**&gt;(pFrame-&gt;data), pFrame-&gt;linesize, <span class="number">0</span>, is-&gt;videoSt-&gt;codec-&gt;height,</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>**&gt;(vp-&gt;frame-&gt;data), vp-&gt;frame-&gt;linesize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// now we inform out displat thread that we have a pic ready</span></span><br><span class="line">  <span class="keyword">if</span> (++is-&gt;pqWindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">    is-&gt;pqWindex = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;picQueueSize++;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分的重点就是使用 <code>sws_scale</code> 对原始帧进行转换，剩下的部分就是将数据“入队”。队列的工作原理就是往里添加数据直到填满，同时只要有数据就不断读取，这两个操作都依赖 <code>VideoState.picQueueSize</code>，所以需要加锁。所以我们在这里做的是不断增加<strong>写“指针”</strong>（必要时重置为 0），增加队列的数据数量。这样消费者就能直到队列中有可消费数据，如果队列满了，生产者也能知道。</p><h2 id="显示视频"><a href="#显示视频" class="headerlink" title="显示视频"></a>显示视频</h2><p>上面就是 video 线程的所有内容！现在我们完成了所有线程创建及其实现，除了一个 —— 还记得 <code>scheduleRefresh</code> 回调的方式嘛？看下它的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* schedule a video refresh in &#x27;delay&#x27; ms */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduleRefresh</span><span class="params">(VideoState* is, <span class="type">int</span> delay)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SDL_AddTimer</span>(delay, sdlRefreshTimerCb, is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SDL_AddTimer</code> 在延迟特定时间后触发回调函数，也可以传递数据。我们将使用这个函数触发视频刷新 —— 每次调用这个函数是，它就会设置一个计时器，计时器会触发一个用户事件，在 <code>main</code> 的事件循环我们就会从帧队列中获取一帧并展示它！呼（Phew）！</p><p>但是首先，看下我们怎么触发这个事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">sdlRefreshTimerCb</span><span class="params">(<span class="type">uint32_t</span> interval, <span class="type">void</span>* opaque)</span> </span>&#123;</span><br><span class="line">  SDL_Event event;</span><br><span class="line">  event.type = FF_REFRESH_EVENT;</span><br><span class="line">  event.user.data1 = opaque;</span><br><span class="line">  <span class="built_in">SDL_PushEvent</span>(&amp;event);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在开始了解发送事件。 <code>FF_REFRESH_EVENT</code> 定义为 <code>SDL_USEREVENT + 1</code>。需要注意的是，当我们返回 <code>0</code> 时，SDL 就会停止计数器，避免回调被多次调用。</p><blockquote><p>计时器发现当前时间超过预设时间时就会进行回调，当 0 返回就表示事件被消费了，计时器就不会再回调了。</p></blockquote><p>发送完 <code>FF_REFRESH_EVENT</code> 后，我们需要在事件循环中进行响应：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!is-&gt;quit) &#123;</span><br><span class="line">  <span class="built_in">SDL_WaitEvent</span>(&amp;event);</span><br><span class="line">  <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">case</span> FF_REFRESH_EVENT:</span><br><span class="line">      <span class="built_in">videoRefreshTimer</span>(event.user.data1);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们接着看 <code>videoRefreshTimer</code>，这个函数实际从帧队列中获取数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">videoRefreshTimer</span><span class="params">(<span class="type">void</span>* userdata)</span> </span>&#123;</span><br><span class="line">  VideoState* is = <span class="built_in">reinterpret_cast</span>&lt;VideoState*&gt;(userdata);</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;videoSt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;picQueueSize == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">scheduleRefresh</span>(is, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// VideoPicture* vp = &amp;is-&gt;picQ[is-&gt;pqRIndex];</span></span><br><span class="line">      <span class="comment">// Timing code goes here</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">scheduleRefresh</span>(is, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(*(is-&gt;picQueueMutex))</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// show the picture</span></span><br><span class="line">      <span class="built_in">videoDisplay</span>(is);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// update queeu for next picture</span></span><br><span class="line">      <span class="keyword">if</span> (++is-&gt;pqRIndex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">        is-&gt;pqRIndex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      is-&gt;picQueueSize--;</span><br><span class="line">      is-&gt;picQueueCond-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">scheduleRefresh</span>(is, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个非常简单的函数：从帧队列中获取数据，设置下次刷新的时间，调用 <code>videoDisplay</code> 将视频帧渲染上屏幕，然后移动队列读指针，并它的大小。你可能注意到我们并没有使用 <code>vp</code> 变量，原因是：在后面的教程开始实现音视频同步时，我们会访问时间信息，注释中也进行标注了 “Timing code goes here”。到时候，我们会计算出下一帧什么时候展示，并且将这个结果传递给 <code>scheduleRefresh</code> 函数。现在我们写死了 20ms 。从原理上讲了，你可以根据播放的文件调整这个数据的大小然后重新编译，不过这个有两个问题：</p><ol><li>播放一段时间后，声音和画面会不协调；</li><li>这很傻。</li></ol><p>这部分下节中再回过头来解决。</p><p>我们马上就要完成了，还剩最后一件事：<strong>渲染视频帧</strong>！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">videoDisplay</span><span class="params">(VideoState* is)</span> </span>&#123;</span><br><span class="line">  VideoPicture* vp = &amp;is-&gt;picQueue[is-&gt;pqRIndex];</span><br><span class="line">  <span class="keyword">if</span> (vp-&gt;frame == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AVFrame* frame = vp-&gt;frame;</span><br><span class="line">  <span class="comment">// Present the frame with SDL</span></span><br><span class="line">  <span class="built_in">SDL_RenderClear</span>(is-&gt;sdlRen);</span><br><span class="line">  <span class="comment">// Update texture</span></span><br><span class="line">  <span class="keyword">if</span> (is-&gt;sdlTex == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Create texture for displaying</span></span><br><span class="line">    SDL_Texture* texture = <span class="built_in">SDL_CreateTexture</span>(is-&gt;sdlRen, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,</span><br><span class="line">                                             is-&gt;videoCtx-&gt;width, is-&gt;videoCtx-&gt;height);</span><br><span class="line">    <span class="keyword">if</span> (texture == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      spdlog::<span class="built_in">error</span>(<span class="string">&quot;Could not create texture - &#123;s&#125;&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    is-&gt;sdlTex = texture;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">SDL_UpdateYUVTexture</span>(is-&gt;sdlTex, <span class="literal">nullptr</span>, frame-&gt;data[<span class="number">0</span>], frame-&gt;linesize[<span class="number">0</span>], frame-&gt;data[<span class="number">1</span>], frame-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                       frame-&gt;data[<span class="number">2</span>], frame-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate rect</span></span><br><span class="line">  <span class="type">float</span> aspectRatio;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;videoSt-&gt;codec-&gt;sample_aspect_ratio.num == <span class="number">0</span>) &#123;</span><br><span class="line">    aspectRatio = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(is-&gt;videoSt-&gt;codec-&gt;width) / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(is-&gt;videoSt-&gt;codec-&gt;height);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    aspectRatio =</span><br><span class="line">        <span class="built_in">av_q2d</span>(is-&gt;videoSt-&gt;codec-&gt;sample_aspect_ratio) * is-&gt;videoSt-&gt;codec-&gt;width / is-&gt;videoSt-&gt;codec-&gt;height;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> screenW, screenH, w, h;</span><br><span class="line">  <span class="built_in">SDL_GetWindowSize</span>(is-&gt;sdlWin, &amp;screenW, &amp;screenH);</span><br><span class="line">  h = screenH;</span><br><span class="line">  w = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">rint</span>(h * aspectRatio)) &amp; <span class="number">-3</span>;</span><br><span class="line">  <span class="keyword">if</span> (w &gt; screenW) &#123;</span><br><span class="line">    w = screenW;</span><br><span class="line">    h = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">rint</span>(w / aspectRatio)) &amp; <span class="number">-3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Center the movie</span></span><br><span class="line">  <span class="type">int</span> x = (screenW - w) / <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> y = (screenH - h) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  SDL_Rect dstRect&#123;x, y, w, h&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Draw texture</span></span><br><span class="line">  <span class="built_in">SDL_RenderCopy</span>(is-&gt;sdlRen, is-&gt;sdlTex, <span class="literal">nullptr</span>, &amp;dstRect);</span><br><span class="line">  <span class="comment">// Update the screen</span></span><br><span class="line">  <span class="built_in">SDL_RenderPresent</span>(is-&gt;sdlRen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为屏幕可以是任意尺寸（这里写死的是 640x480，当然用户的也能调整窗口大小），我们需要计算出视频显示区域的尺寸和位置。首先我们要计算出视频的宽高比，一些编解码器会有一个奇怪的<strong>采样宽高比（sample aspect ratio）</strong>，它指单个像素或采样的宽高比。编解码器中的宽高以像素作为单位，所以实际画面宽高比是<strong>编解码器宽高比</strong>与<strong>采样宽高比</strong>的乘积。如果编解码器的<strong>采样宽高比</strong>等于 0，这说明每个像素的尺寸是 1x1。然后我们对视频进行缩放，使得画面能够尽量撑满窗口。<code>&amp; -3</code> 位操作会将宽高向下取整到最接近的 4 的倍数上。得到缩放后的宽高后就可以进行居中定位了。</p><p>就是这样了！开始编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main.sh assets/ohayo_oniityan.mp4</span></span><br></pre></td></tr></table></figure><p><img src="/img/2021/dangerffmpeg_threads.gif" alt="Spawning Threads"></p><p>可以看到视频已经居中显示了，但是音画还是不同步。下个教程中我们将实现一个可以正常工作的播放器了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/tutorial04.html">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
            <tag> SDL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DangerFFmpeg】第三节、播放声音</title>
      <link href="/2021/05/20/9d77922cda47.html"/>
      <url>/2021/05/20/9d77922cda47.html</url>
      
        <content type="html"><![CDATA[<p>本文是 《DangerFFmpeg》系列教程第三节，系列完整目录：<br>《<a href="/2021/05/14/8cf36b195b05.html">开篇</a>》<br>《<a href="/2021/05/15/1c458d50c524.html">第一节、屏幕截图</a>》<br>《<a href="/2021/05/16/aeb0b6c30d08.html">第二节、输出到屏幕</a>》<br>《<a href="/2021/05/20/d4b63d917433.html">第三节、播放声音</a>》<br>《<a href="/2021/05/22/71765970ad7e.html">第四节、多线程</a>》<br>《<a href="/2021/05/30/088658998748.html">第五节、视频同步</a>》<br>《<a href="/2021/06/05/d8b51b0cff00.html">第六节、同步音频</a>》<br>《<a href="/2021/06/09/2f01ccb59968.html">第七节、快进快退</a>》<br>《<a href="/2021/06/19/7ddfef63d330.html">结语</a>》</p><p>系列所有代码托管在 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><blockquote><p>第二节中我们使用 send&#x2F;receive 模型对视频进行编码，但是实现上不利于拓展实现这一节的音频，所以我们把问题简化，只播放音频，在下一节中再将音频和视频组合起来。</p></blockquote><hr><h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p>现在我们准备要播放声音了。SDL 也提供了播放音频对应的方法。<code>SDL_OpenAudio</code> 用来的打开音频设备，它接受 <code>SDL_AudioSpec</code> 结构体作为参数，<code>SDL_AudioSpec</code> 描述了我们将要播放的音频的特征。</p><p>在演示播放音频步骤之前，我们先学习下计算机是如何处理音频的。数字音频由大量 <strong>采样（samples）</strong> 组成，每个采样点表示音频<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Waveform">波形</a>的取值。声音以固定的采样频率进行录制，并以每秒的采样数来衡量，换句话说就是我们以多快的速度播放音频。常见的采样频率由 22,050 和 44,100 Hz，它们分别是无线电广播和 CD 的采样频率。另外，大多数的音频可以有多个声道组成立体声和环绕声，比如，如果采样立体声，那么一次采样就会得到两个采样数据（sample）。当我们从视频文件中获取数据时，我们不知道能拿到多少个采样数据，但是 FFmpeg 不会返回不完整的采样，也就是说 FFmpeg 不会把一个立体声的采样拆分为多个采样数据并多次返回。</p><p>SDL 播放音频的方式是这样的：首先配置音频参数，这些参数有采样率（frequency），声道数，回调函数和 userdata。当我们开始播放音频，SDL 会不断地调用回调函数并要求我们将音频数据填充到它提供给我们的缓冲区中。在将音频配置写入 <code>SDL_AudioSpec</code> 之后，调用 <code>SDL_OpenAudio</code> 打开音频设备并拿到 <strong>另一个</strong> <code>SDL_AudioSpec</code> ，这个新拿到的 <code>SDL_AudioSpec</code> 就是实际需要使用的配置，也就是说无法保证一定能按照我们的期望配置播放音频，但是 SDL 会尽量满足我们的要求，找一个接近的配置。</p><h2 id="准备音频"><a href="#准备音频" class="headerlink" title="准备音频"></a>准备音频</h2><p>上面这些内容先暂时记在脑袋里，因为我们现在还没有拿到任何音频流相关信息。回到上一节的代码中，将查找视频流的代码替换成查找视频流的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the first audio stream</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> audioStream = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">    audioStream = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (audioStream == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Didn&#x27;t find a video or audio stream</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以从音频流里获取到 AVCodecContext 并拿到我们想要的信息了，就像处理视频流一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *pACodecCtxOrig = <span class="literal">nullptr</span>, *pACodecCtx = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// Get a pointer to the code context for the video stream</span></span><br><span class="line">pACodecCtxOrig = pFormatCtx-&gt;streams[audioStream]-&gt;codec;</span><br></pre></td></tr></table></figure><p>如果你还记得上一小节中的内容，我们还要打开音频解码器。这很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AVCodec* pACodec = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// Find the decoder for the video stream</span></span><br><span class="line">pACodec = <span class="built_in">avcodec_find_decoder</span>(pACodecCtxOrig-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span> (pACodec == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  spdlog::<span class="built_in">error</span>(<span class="string">&quot;Unsupported codec!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Codec not found</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Copy context parameters</span></span><br><span class="line">AVCodecParameters* pParams = <span class="built_in">avcodec_parameters_alloc</span>();</span><br><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(pParams, pACodecCtxOrig);</span><br><span class="line">pACodecCtx = <span class="built_in">avcodec_alloc_context3</span>(pACodec);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avcodec_parameters_to_context</span>(pACodecCtx, pParams) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">avcodec_parameters_free</span>(&amp;pParams);</span><br><span class="line">  spdlog::<span class="built_in">error</span>(<span class="string">&quot;Couldn&#x27;t copy codec contxt!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Error copying codec context</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">avcodec_parameters_free</span>(&amp;pParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open codec</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pACodecCtx, pACodec, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  spdlog::<span class="built_in">error</span>(<span class="string">&quot;Couldn&#x27;t open codec&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Couldn&#x27;t open codec</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Codec context 中包含了配置音频的所有信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup SDL audio here</span></span><br><span class="line">SDL_AudioSpec wantedSpec, spec;</span><br><span class="line">wantedSpec.freq = pACodecCtx-&gt;sample_rate;</span><br><span class="line">wantedSpec.format = AUDIO_F32;</span><br><span class="line">wantedSpec.channels = pACodecCtx-&gt;channels;</span><br><span class="line">wantedSpec.silence = <span class="number">0</span>;</span><br><span class="line">wantedSpec.samples = pACodecCtx-&gt;channels * <span class="number">2</span>;</span><br><span class="line">wantedSpec.callback = audioCallback;</span><br><span class="line">wantedSpec.userdata = pACodecCtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SDL_OpenAudio</span>(&amp;wantedSpec, &amp;spec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  spdlog::<span class="built_in">error</span>(<span class="string">&quot;SDL_OpenAudio: &#123;s&#125;&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们看看这些参数：</p><ul><li>freq：采样率。</li><li>format：告诉 SDL 将会播放什么格式的音频。“S16SYS” 中 “S” 表示 “有符号（signed）”， “16” 表示每个采样数据长度是 16 bits。然后 “SYS” 表示 “<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Endianness">字节序</a>” 采用系统的顺序。这就是 <code>avcodec_receive_frame</code> 接收到的音频格式。</li><li>channels：声道数。</li><li>silence：静音时的音量参考值。一般情况下传 0 就可以了。</li><li>samples：callback 回调时缓冲区的大小。比较合适的区间是 [512, 8192]，ffplay 用的 1024。</li><li>callback：传入一个回调函数，并在回调函数里将解码好的音频数据写入缓冲。后面会再详细说明。</li><li>userdata：callback 回调时的第一个 <code>void *</code> 参数。上面代码里传的是 <em>codec context</em>，后面会看到如何使用它。</li></ul><blockquote><p>这里我们把 foramt 写死成 <code>AUDIO_F32</code> ，因为示例音频格式是这个，待到后面我们再使用 <code>swr_scale</code> 对原始音频进行重采样以适配不同音频格式。</p></blockquote><p>最后，我们使用 <code>SDL_OpenAudio</code> 打开音频设备。</p><h2 id="缓冲队列"><a href="#缓冲队列" class="headerlink" title="缓冲队列"></a>缓冲队列</h2><p>到这里就开始从 <em>stream</em> 里获取音频数据了。但是，我们该如何处理这些数据呢？我们会持续地从视频文件中读取数据包（packet），但是与此同时，SDL 也会调用回调函数（callback）！解决方案是创建一个全局的数据结构，将读取到的数据包放进去，SDL 调用回调函数的时候就能从队列获取音频数据（未解码）了。下面我们将创建一个存放数据包（packet）的队列。FFmpeg 内置的 <code>AVPacketList</code> 能够帮我们完成这个队列，<code>AVPacketList</code> 简单来说就是一个链表节点。下面看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PacketQueue</span> &#123;</span><br><span class="line">  AVPacketList *firstPkt, *lastPkt;</span><br><span class="line">  <span class="type">int</span> nbPackets;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  std::mutex* aMutex;</span><br><span class="line">  std::condition_variable* aCond;</span><br><span class="line">&#125;;</span><br><span class="line">PacketQueue audioQueue;</span><br></pre></td></tr></table></figure><p>需要说明的是，<code>nbPackets</code> 和 <code>size</code> 不是一回事，<code>size</code> 指队列中 <code>packet-&gt;size</code> 相加后的字节数。同时注意到我们创建的一个 <code>std::mutext</code> 和 <code>std::condition_variable</code> ，这是因为 SDL 音频播放运行在一个独立的线程，如果不适当地给缓冲队列上锁，我们会把队列中的数据破坏。下面我们会看到如何实现一个队列，每个程序员都应该知道如何实现队列，这里我们已经提供好了，所以你可以全力去学习 SDL：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">packetQueueInit</span><span class="params">(PacketQueue* queue)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(queue, <span class="number">0</span>, <span class="built_in">sizeof</span>(PacketQueue));</span><br><span class="line">  queue-&gt;aMutex = <span class="keyword">new</span> std::mutex;</span><br><span class="line">  queue-&gt;aCond = <span class="keyword">new</span> std::condition_variable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们添加一个函数用于向队列中添加数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">packetQueuePut</span><span class="params">(PacketQueue* queue, AVPacket* pkt)</span> </span>&#123;</span><br><span class="line">  AVPacketList* pktl;</span><br><span class="line">  AVPacket* dst = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">av_packet_ref</span>(dst, pkt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pktl = <span class="built_in">reinterpret_cast</span>&lt;AVPacketList*&gt;(<span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(AVPacketList)));</span><br><span class="line">  <span class="keyword">if</span> (pktl == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pktl-&gt;pkt = *dst;</span><br><span class="line">  pktl-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(*(queue-&gt;aMutex))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue-&gt;lastPkt == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    queue-&gt;firstPkt = pktl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queue-&gt;lastPkt-&gt;next = pktl;</span><br><span class="line">  &#125;</span><br><span class="line">  queue-&gt;lastPkt = pktl;</span><br><span class="line">  queue-&gt;nbPackets++;</span><br><span class="line">  queue-&gt;size += pktl-&gt;pkt.size;</span><br><span class="line"></span><br><span class="line">  queue-&gt;aCond-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::lock_guard</code> 对 <code>std::mutex</code> 上锁，就可以安全地把数据添加到队列中，然后使用 <code>std::condition_variable::notify_all</code> 发送信号给对应的 get 函数（如果它在 waiting 状态的话），告诉它队列中有新的数据可以消费了。函数退出时 <code>std::lock_guard</code> 的析构函数会自动释放 <code>std::mutex</code> 的锁。</p><p>下面是对应的 “get” 函数，注意下 <code>std::condition_variable</code> 是怎么使当前函数阻塞（直到有新数据）的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> quit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">packetQueueGet</span><span class="params">(PacketQueue* queue, AVPacket* pkt, <span class="type">bool</span> block)</span> </span>&#123;</span><br><span class="line">  AVPacketList* pktl;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(*(queue-&gt;aMutex))</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (quit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pktl = queue-&gt;firstPkt;</span><br><span class="line">    <span class="keyword">if</span> (pktl != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      queue-&gt;firstPkt = pktl-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (queue-&gt;firstPkt == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        queue-&gt;lastPkt = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      queue-&gt;nbPackets--;</span><br><span class="line">      queue-&gt;size -= pktl-&gt;pkt.size;</span><br><span class="line">      *pkt = pktl-&gt;pkt;</span><br><span class="line">      <span class="built_in">av_free</span>(pktl);</span><br><span class="line">      ret = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">      ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queue-&gt;aCond-&gt;<span class="built_in">wait</span>(lk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你看到的，函数主体是一个死循环，这样就能保证一定能使函数被阻塞（当没有数据可以读取时）。我们使用 <code>std::condition_variable::wait</code> 避免无意义的空转，<code>std::condition_variable::wait</code> 所做其实就是让出 CPU 并等待 <code>std::condition_variable::notify_*</code> 的通知然后继续执行。但是，我们似乎在对 <code>std::mutex</code> 上锁后执行 <code>std::condition_variable::wait</code> —— 如果我们持有锁，那么 <code>packetQueuePut</code> 将无法往里添加数据！然而，<code>std::condition_variable::wait</code> 所做的另一件事就是释放 <code>std::mutex</code> 的锁，然后在被唤醒时再次尝试对 <code>std::mutex</code> 上锁。</p><h2 id="退出条件"><a href="#退出条件" class="headerlink" title="退出条件"></a>退出条件</h2><p>你应该也注意到了，我们声明了一个全局变量 <code>quit</code> ，并检查它以确保程序没有收到退出信号（SDL 会自动处理 <em>TERM（ternimate）</em> 信号）。否则，线程会一直执行导致程序无法退出，只能使用 <code>kill -9</code> 杀死进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDL_Event ev;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">SDL_PollEvent</span>(&amp;ev)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev.type == SDL_QUIT || (ev.type == SDL_KEYDOWN &amp;&amp; ev.key.keysym.sym == SDLK_ESCAPE)) &#123;</span><br><span class="line">    quit = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序终止时将 <code>quit</code> 设置为 <code>true</code>。</p><h2 id="发送-Packet"><a href="#发送-Packet" class="headerlink" title="发送 Packet"></a>发送 Packet</h2><p>剩下的事情就是初始化队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PacketQueue audioQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">avcodec_open2</span>(pACodecCtx, pACodec, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">packet_queue_init</span>(&amp;audioQueue);</span><br><span class="line">  <span class="built_in">SDL_PauseAudio</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SDL_PauseAudio</code> 最终启动音频设备，如果没有数据输入，音频设备将保持静音。</p><p>我们已经建初始化好缓冲队列，现在可以往里开始写入数据包（packet）了。我们进入读取数据包的循环中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">  ret = <span class="built_in">av_read_frame</span>(pFormatCtx, &amp;packet);</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (packet.stream_index == audioStream) &#123;</span><br><span class="line">      <span class="built_in">packetQueuePut</span>(&amp;audioQueue, &amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(&amp;packet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意读取成功并写入队列后就对 <code>packet</code> 进行解引用。</p><h2 id="获取-Packets"><a href="#获取-Packets" class="headerlink" title="获取 Packets"></a>获取 Packets</h2><p>现在让我们实现 <code>audioCallback</code> 函数，从缓冲队列中获取数据包。回调函数必须符合 <code>void callback(void *userdata, uint8_t *stream, int len)</code> 的形式，<code>userdata</code> 是我们传递给 SDL 的自定义数据， <code>stream</code> 是需要我们填充的缓冲区域，<code>len</code> 是缓冲区的大小。下面是实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">audioCallback</span><span class="params">(<span class="type">void</span>* userdata, <span class="type">uint8_t</span>* stream, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">  AVCodecContext* aCodecCtx = <span class="built_in">reinterpret_cast</span>&lt;AVCodecContext*&gt;(userdata);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> len1, audioSize;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> audioBuf[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> audioBufSize = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> audioBufIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (audioBufIndex &gt;= audioBufSize) &#123;</span><br><span class="line">      audioSize = <span class="built_in">audioDecodeFrame</span>(aCodecCtx, audioBuf, <span class="built_in">sizeof</span>(audioBuf));</span><br><span class="line">      <span class="keyword">if</span> (audioSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        audioBufSize = <span class="number">1024</span>;</span><br><span class="line">        <span class="built_in">memset</span>(audioBuf, <span class="number">0</span>, audioBufSize);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        audioBufSize = audioSize;</span><br><span class="line">      &#125;</span><br><span class="line">      audioBufIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len1 = audioBufSize - audioBufIndex;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len) &#123;</span><br><span class="line">      len1 = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(stream, audioBuf + audioBufIndex, len1);</span><br><span class="line">    len -= len1;</span><br><span class="line">    stream += len1;</span><br><span class="line">    audioBufIndex += len1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的循环，不断地从我们编写的另一个 <code>audioDecodeFrame</code> 函数中拉取数据，将数据保存一个中介中韩缓，然后尝试将 <code>len</code> 长度的数据写入 <code>stream</code>，如果可供写入的数据不足 <code>len</code> 则继续从 <code>audioDecodeFrame</code> 读取数据，如果 <code>stream</code> 空间无法完全写入，则将数据保存至下次回调。<code>audioBuf</code> 大小这里写死 20K，比较合理的是设置为最大音频帧大小的 1.5 倍，这个后面进行优化。</p><h2 id="解码音频"><a href="#解码音频" class="headerlink" title="解码音频"></a>解码音频</h2><p>现在开始真正完成编解码器相关部分，<code>audioDecodeFrame</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">audioDecodeFrame</span><span class="params">(AVCodecContext* aCodecCtx, <span class="type">uint8_t</span>* buf, <span class="type">int</span> bufSize)</span> </span>&#123;</span><br><span class="line">  AVPacket pkt;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">packetQueueGet</span>(&amp;audioQueue, &amp;pkt, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">avcodec_send_packet</span>(aCodecCtx, &amp;pkt);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bufIndex = <span class="number">0</span>;</span><br><span class="line">  AVFrame* frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">avcodec_receive_frame</span>(aCodecCtx, frame) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> dataSize =</span><br><span class="line">        <span class="built_in">av_samples_get_buffer_size</span>(<span class="literal">nullptr</span>, aCodecCtx-&gt;channels, frame-&gt;nb_samples, aCodecCtx-&gt;sample_fmt, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert</span>(dataSize &lt;= bufSize - bufIndex);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf + bufIndex, frame-&gt;data[<span class="number">0</span>], dataSize);</span><br><span class="line">    bufIndex += dataSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">av_free</span>(frame);</span><br><span class="line">  <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">  <span class="keyword">return</span> bufIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从 <code>packetQueueGet</code> 中取得一个数据包（packet），然后将其送入解码器。因为音频数据包中可能含有多个音频帧，所以接下来使用一个循环反复调用 <code>avcodec_send_packet</code> 直到没有数据可以读取。函数退出时对 <code>packet</code> 进行解引用，避免内存泄漏。</p><p>这就是全部的代码了，我们已经将音频从主读取循环传送到队列，然后在 <code>audioCallback</code> 中读取出来，该函数将数据传递给 SDL，SDL 接着将数据输出到声卡。现在可以编译了。</p><p>因为我们没有处理视频，所以没有画面。但是声音能按照正常速度播放。为什么音频不像视频那样走样呢？这是因为音频信息中有采样率 —— 音频信息能够在程序运行后就立马解出，但是音频只是根据采样率在闲暇时播放流中的数据。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我们现在已经可以尝试同步音视频了，但是首先我们需要将程序重新组织一下。将音频数据存入队列然后在单独的线程中播放的方法工作得非常好：它使得代码更易于管理和模块化。在我们开始同步音视频前，我们需要让代码更容易阅读、修改。下一节：多线程。</p><p>源码已经上传 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/tutorial03.html">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
            <tag> SDL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DangerFFmpeg】第二节、输出到屏幕</title>
      <link href="/2021/05/16/2c85b990b932.html"/>
      <url>/2021/05/16/2c85b990b932.html</url>
      
        <content type="html"><![CDATA[<p>本文是 《DangerFFmpeg》系列教程第二节，系列完整目录：<br>《<a href="/2021/05/14/8cf36b195b05.html">开篇</a>》<br>《<a href="/2021/05/15/1c458d50c524.html">第一节、屏幕截图</a>》<br>《<a href="/2021/05/16/aeb0b6c30d08.html">第二节、输出到屏幕</a>》<br>《<a href="/2021/05/20/d4b63d917433.html">第三节、播放声音</a>》<br>《<a href="/2021/05/22/71765970ad7e.html">第四节、多线程</a>》<br>《<a href="/2021/05/30/088658998748.html">第五节、视频同步</a>》<br>《<a href="/2021/06/05/d8b51b0cff00.html">第六节、同步音频</a>》<br>《<a href="/2021/06/09/2f01ccb59968.html">第七节、快进快退</a>》<br>《<a href="/2021/06/19/7ddfef63d330.html">结语</a>》</p><p>系列所有代码托管在 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><blockquote><p>同原文使用的 SDL 相比，SDL2 API 变更比较大，所以译文和原文会有一定差别。</p></blockquote><hr><h2 id="SDL-和视频"><a href="#SDL-和视频" class="headerlink" title="SDL 和视频"></a>SDL 和视频</h2><p>为了绘制到屏幕上，我们将使用 <a target="_blank" rel="noopener" href="http://www.libsdl.org/">SDL2</a> 框架。SDL2 是 Simple Direct Layer2 的缩写，它是个非常棒的多媒体应用开发库，支持跨平台，并且在许多项目中都有使用。你可以从官网获取 SDL2 的源码或直接将其开发包安装到系统上。从本节开始，你需要添加 SDL2 依赖才能编译教程中的代码。</p><blockquote><p>macOS 上推荐 <code>brew install sdl2</code> 安装 SDL2。为了表达方便，如无特别说明，后文提到的 SDL 都表示 SDL2。</p></blockquote><p>SDL 有许多绘制图片的方法，并且有一个适合显示视频 —— <code>SDL_UpdateYUVTexture</code>。<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/YCbCr">YUV（准确地说是 YCbCr）</a> 是与 RGB 类似的图像存储格式。不准确地说，Y 代表 <strong>亮度（brightness or luma）</strong> 分量，U 和 V 就是 <strong>颜色（color）</strong> 分量。YUV 要比 RGB 更加复杂，为了实现各种优化（主要是体积），YUV 可能会丢弃一些颜色信息，比如两个 Y 分量共享一对 UV 分量。SDL 的 SDL_Texture 可以接收 YUV 的三个分量并绘制出来。SDL2 比 SDL 支持的 YUV 格式更多，本文使用性能较好的 YV12 格式。还有一种 YUV 格式，称作 YUV420P，与 YV12 类似，不同的是 U、V 分量的先后顺序相反。其中 <em>420</em> 表示的是图像的 YUV 分量是按照 4:2:0 的比例<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Chroma_subsampling">采样</a>的，差不多是一个颜色分量被四个亮度分量所共享，即颜色分量只有原始数据的 1&#x2F;4。这种采样方式的优点是可以节省带宽，因为人眼无法感知到这种变化。“P” 表示存储格式是 <strong>分层的（planar）</strong>，即 Y、U 和 V 分开存储在不同的数组里。FFmpeg 可以将图像转换成 YUV420P 格式，另一个便利是，很多视频采用 YUV420P 格式存储，或者很容转换成 YUV420P。</p><p>所以我们现在的计划是替换<a href="https://clsrfish.github.io/2021/05/15/1c458d50c524.html">第一节</a>中的 <code>SaveFrame</code>，将<strong>帧数据（frame）</strong>输出到屏幕上。不过在开始之前我们需要先了解如何使用 SDL。首先，我们需要添加头文件并且初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL_thread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize SDL</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SDL_Init</span>(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER) != <span class="number">0</span>) &#123;</span><br><span class="line">  spdlog::<span class="built_in">error</span>(<span class="string">&quot;Could not initialize SDL - &#123;s&#125;&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">  <span class="built_in">SDL_Quit</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SDL_Init</code> 的参数表明我们想要的使用什么功能，比如这里就是需要支持视频、音频以及时钟系统。<code>SDL_GetError</code> 可以方便地获取调试信息。</p><blockquote><p>如何添加 SDL 到项目可以参考源码。</p></blockquote><h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><p>现在我们需创建一个窗口（SDL_Window）去渲染的内容，可以使用 <code>SDL_CreateWindow</code> 创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SDL_Window* win = <span class="built_in">SDL_CreateWindow</span>(<span class="string">&quot;Tutorial 02: Outputting to the Screen&quot;</span>, SDL_WINDOWPOS_CENTERED,</span><br><span class="line">                                     SDL_WINDOWPOS_CENTERED, <span class="number">640</span>, <span class="number">480</span>, SDL_WINDOW_SHOWN)</span><br><span class="line"><span class="keyword">if</span> (win == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    spdlog::<span class="built_in">error</span>(<span class="string">&quot;Could not create window - &#123;s&#125;&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">    <span class="built_in">SDL_Quit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SDL_CreateWindow</code> 接受一个标题，窗口的位置，窗口的大小以及窗口的属性，如果返回值为 <code>nullptr</code> 则是窗口创建失败，直接退出程序。</p><h2 id="创建-Renderer-和纹理"><a href="#创建-Renderer-和纹理" class="headerlink" title="创建 Renderer 和纹理"></a>创建 Renderer 和纹理</h2><p>窗口已经显示出来了，看起来还比较简单。为了绘制帧数据，还需要创建 SDL_Renderer 和<strong>纹理（SDL_Texture）</strong>，纹理其实是一块可以存放图像数据的内存，Renderer 则使用纹理中的数据进行绘制。在创建 Renderer 时还要关联窗口，因为 Renderer 需要知道绘制到哪里：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDL_Renderer* ren = <span class="built_in">SDL_CreateRenderer</span>(win, <span class="number">-1</span>, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);</span><br><span class="line"><span class="keyword">if</span> (ren == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">SDL_DestroyWIndow</span>(win);</span><br><span class="line">    <span class="built_in">SDL_Quit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数指定需要使用的图形驱动，传入 -1 表示使用第一个满足要求的驱动。第三个参数（flags）指明了我们的要求，比如这里要支持硬件加速和垂直同步。</p><p>Renderer 创建好后就可以创建纹理（SDL_Texture）了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_Texture* texture = <span class="built_in">SDL_CreateTexture</span>(ren, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, width, height);</span><br></pre></td></tr></table></figure><p><code>SDL_CreateTexture</code> 可以创建一个空白的纹理对象。它的第二个参数指定了接受的纹理格式，这传入文章开头说的 YV12 对应的常量。第三个参数则指定了我们希望图形驱动如何管理数据，它有三种形式：</p><ul><li><code>SDL_TEXTUREACCESS_STATIC</code>：数据上传之后很少更新。</li><li><code>SDL_TEXTUREACCESS_STREAMING</code>：更新非常频繁。</li><li><code>SDL_TEXTUREACCESS_TARGET</code>：作为渲染的输出目标，比如在后台绘制，但是不希望它显示在屏幕上，就可以用这种纹理暂时存储。</li></ul><p>显然我们应该用 <code>SDL_TEXTUREACCESS_STREAMING</code>。</p><h2 id="绘制画面"><a href="#绘制画面" class="headerlink" title="绘制画面"></a>绘制画面</h2><p><a href="https://clsrfish.github.io/2021/05/15/1c458d50c524.html">第一节</a>中我们将原始帧数据转换成了 24-bit RGB 格式，这里需要改成 YUV420P，FFmpeg 没有直接提供 YV12 格式，我们可以在<strong>使用 YUV420P 时调换一下 UV 的位置</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AVFrame* pFrame420P = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="keyword">if</span> (pFrame420P == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine required buffer size and allocate buffer</span></span><br><span class="line"><span class="type">int</span> nbBytes = <span class="built_in">avpicture_get_size</span>(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line"><span class="type">uint8_t</span>* buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">av_malloc</span>(nbBytes * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize SWS context for software scaling</span></span><br><span class="line">SwsContext* pSwsCtx = <span class="built_in">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width,</span><br><span class="line">                                       pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BILINEAR, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>现在我们可以将 <code>pFrame420P</code> 的数据上传到 <code>testure</code> 进行展示了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clear the current rendering target</span></span><br><span class="line"><span class="built_in">SDL_RenderClear</span>(ren);</span><br><span class="line"><span class="comment">// Update texture</span></span><br><span class="line"><span class="built_in">SDL_UpdateYUVTexture</span>(texture, <span class="literal">nullptr</span>, pFrameYV12-&gt;data[<span class="number">0</span>], pFrameYV12-&gt;linesize[<span class="number">0</span>], pFrameYV12-&gt;data[<span class="number">1</span>],</span><br><span class="line">                        pFrameYV12-&gt;linesize[<span class="number">1</span>], pFrameYV12-&gt;data[<span class="number">2</span>], pFrameYV12-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// Draw texture</span></span><br><span class="line"><span class="built_in">SDL_RenderCopy</span>(ren, texture, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// Update the screen</span></span><br><span class="line"><span class="built_in">SDL_RenderPresent</span>(ren);</span><br><span class="line"><span class="comment">// Take a quick break after all that hard work</span></span><br><span class="line"><span class="built_in">SDL_Delay</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>YUV420P 数据分层存储在 <code>pFrame420P-&gt;data</code> 中。<code>pFrame420P-&gt;linesize</code> 正如其命名一样，保存了 <code>pFrame420P-&gt;data</code> 每层数组的大小&#x2F;长度，要注意这个长度包含了<strong>内存对齐</strong>添加的额外空间，这个数据和 SDL 的 “pitches” 是对应的。</p><p><code>SDL_RenderCopy</code> 最后两个参数指定了显示区域和显示位置，因为这个不是我们的关注点，所以都传 <code>nullptr</code>，画面会填满整个窗口，感兴趣可以计算个准确的矩形区域。</p><p>每次渲染结束我们都暂停 50ms，避免画面变化过快，当然这里的 50ms 无法在真实项目中使用，后面我们将会看到如何动态调整延时以获得准确的播放帧率。</p><h3 id="SDL-event-system"><a href="#SDL-event-system" class="headerlink" title="SDL event system"></a>SDL event system</h3><p>我们再看看 SDL 的另外一个功能：事件系统。SDL 配置了当你打字、在窗口内移动鼠标或向 SDL 发送信号时，SDL 会产生一个<strong>事件（event）</strong>。如果你想处理用户输入，你的程序可以检查这些事件。程序也可以构造事件发送给 SDL，这个在多线程编程时是个非常有用的能力，我们将在第四节中看到。回到我们的程序，我们在每次发送 packet 之前检查事件队列。在这里我们只处理 <code>SDL_QUIT</code> 和 <code>SDLK_ESCAPE</code> 按下的事件，以便主动的退出程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SDL_Event ev;</span><br><span class="line"><span class="keyword">while</span> (!hasError &amp;&amp; !hasFinished) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">SDL_PollEvent</span>(&amp;ev)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ev.type == SDL_QUIT || (ev.type == SDL_KEYDOWN &amp;&amp; ev.key.keysym.sym == SDLK_ESCAPE)) &#123;</span><br><span class="line">        hasFinished = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasFinished) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开始播放"><a href="#开始播放" class="headerlink" title="开始播放"></a>开始播放</h3><p>在修改完对应代码后，我们就可以编译运行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main.sh assets/ohayo_oniityan.mp4</span></span><br></pre></td></tr></table></figure><p><img src="/img/2021/dangerffmpeg_output_screen.gif" alt="Compile and run"></p><p>运行程序之后发现了什么？帧率和原视频不一致，因为我们写死了 20fps。我们现在还没有计算帧数据该什么时候展示的代码，后面（第五节里）我们会去处理视频同步的问题。但是首先，我们缺少了更重要的东西：声音！</p><p>这些就是本节教程的全部内容，源码已经上传 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/tutorial02.html">原文链接</a></p><p><a target="_blank" rel="noopener" href="https://libsdl.org/">SDL</a></p><p><a target="_blank" rel="noopener" href="https://www.willusher.io/pages/sdl2">SDL 2.0 Tutorial</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
            <tag> SDL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DangerFFmpeg】第一节、屏幕截图</title>
      <link href="/2021/05/15/44c86f9f725a.html"/>
      <url>/2021/05/15/44c86f9f725a.html</url>
      
        <content type="html"><![CDATA[<p>本文是 《DangerFFmpeg》系列教程第一节，系列完整目录：<br>《<a href="/2021/05/14/8cf36b195b05.html">开篇</a>》<br>《<a href="/2021/05/15/1c458d50c524.html">第一节、屏幕截图</a>》<br>《<a href="/2021/05/16/aeb0b6c30d08.html">第二节、输出到屏幕</a>》<br>《<a href="/2021/05/20/d4b63d917433.html">第三节、播放声音</a>》<br>《<a href="/2021/05/22/71765970ad7e.html">第四节、多线程</a>》<br>《<a href="/2021/05/30/088658998748.html">第五节、视频同步</a>》<br>《<a href="/2021/06/05/d8b51b0cff00.html">第六节、同步音频</a>》<br>《<a href="/2021/06/09/2f01ccb59968.html">第七节、快进快退</a>》<br>《<a href="/2021/06/19/7ddfef63d330.html">结语</a>》</p><p>系列所有代码托管在 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>视频文件有一些基本构成成分。首先，视频文件本身叫做 <strong>容器（container）</strong>，容器的类型决定信息在文件中如何存储。AVI 和 Quicktime 就是容器的两个例子。然后，你会遇到一组 <strong>流（stream）</strong>，举例来说，视频文件通常会有 <em>音频流</em> 和 <em>视频流</em>（ <em>流</em> 描述了 “一组按时间先后排列的数据（data element）”）。流中的数据称作 <strong>帧（frame）</strong>（帧一般会被编码成一个个包，包解开后才是帧）。每个流都是事先使用各种 <strong>编解码器（codec）</strong> 编码好的。编码器定义了原始数据是何如  <strong>编码（COded）</strong> 和 <strong>解码（DECoed）</strong> 的，所以组合起来就叫做 <strong>编码器（CODEC）</strong> 了。DivX 和 MP3 就是编解码器的两个例子。<strong>包（Packet）</strong> 紧接着从流中被读取出来。包是可以包含（<em>有的包可能不会携带原始数据</em>）能够被解码原始数据帧的数据块，拿到数据帧后我们就可以根据需要对其进行修改了。对于我们来说，每个包都包含完整的数据帧，音频则是多个数据帧。</p><p>对于简单的需求，处理视频和音频的流程非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OPEN video_stream FROM video.avi</span><br><span class="line">READ packet FROM video_stream INTO frame</span><br><span class="line">IF frame NOT COMPLETE GOTO 20</span><br><span class="line">DO SOMETHING WITH frame</span><br><span class="line">GOTO 2</span><br></pre></td></tr></table></figure><p>使用 FFmpeg 处理多媒体文件就和上面的流程差不多，不过一些大型项目的 <strong>DO SOMETHING</strong> 步骤可能会非常复杂。在本节教程中，我们将打开视频文件并从中读取视频流，然后在 DO SOMETHING 步骤中将帧数据写入 PPM 文件。</p><blockquote><p>PPM 文件是啥？<br><a target="_blank" rel="noopener" href="http://netpbm.sourceforge.net/doc/ppm.html">PPM</a> 是 Portable PixMap 的缩写，是一种用文本格式紧密存储的 24-bit RGB 图像。后面在写 PPM 文件时还会再提到。</p></blockquote><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>首先，看下如何打开一个文件。使用 FFmpeg 前，你必须对其进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tutorial01::main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">av_register_all</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码注册 FFmpeg 中所有可用的文件和编解码器，后面打开对应格式文件时可以自动使用这些编解码器了。你只需要调用 <code>av_register_all</code> 一次，所以上面代码在 main 里调用。如果你不想注册所有的格式和编解码器，也可以单独注册指定的文件格式和编解码器，不过这通常没必要。</p><blockquote><p><del><code>av_register_all</code></del> 在 FFmpeg 4.0 被标记为 deprecated，文件格式和编解码器会自动地进行注册。</p></blockquote><p>现在我们可以真正地去打开文件了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *pFormatCtx = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open video file</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, argv[<span class="number">1</span>], <span class="literal">nullptr</span>, <span class="literal">nullptr</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// Couldn&#x27;t open file&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从第一个输入参数从获取文件名。 <code>avformat_open_input</code> 读取文件头并且将读取到的信息存储在 <code>pFormatCtx</code> 中。最后两个参数分别用来指定文件格式，和格式（解封装）参数，这里都传了 <code>nullptr</code>，libavformat 会自动检测这些参数值。</p><p>因为 <code>avformat_open_input</code> 只读取文件头信息，所以接下来我们还要确认文件中的流信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrive stream information</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// Couldn&#x27;t find stream information</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>avformat_open_input</code> 将读取的信息填充到 <code>pFormatCtx-&gt;streams</code>。这里介绍一个非常方便的调试函数，将文件中的信息输出到终端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dump information about the file onto standard error</span></span><br><span class="line"><span class="built_in">av_dump_format</span>(pFormatCtx, <span class="number">0</span>, argv[<span class="number">1</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>pFormatCtx-&gt;streams</code> 只是一个<strong>指针数组</strong>，大小是 <code>pFormatCtx-&gt;nb_streams</code>，我们将遍历这个数组并找到视频流：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *pCodecCtxOrig = <span class="literal">nullptr</span>, *pCodecCtx = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// Find the first video stream</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> videoStream = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        videoStream = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (videoStream == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// Didn&#x27;t find a video stream</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a pointer to the code context for the video stream</span></span><br><span class="line">pCodecCtxOrig = pFormatCtx-&gt;streams[videoStream]-&gt;codec;</span><br></pre></td></tr></table></figure><p><code>pFormatCtx-&gt;streams</code> 与编解码器（codec）相关的信息叫做 “编解码器上下文（codec context）”，上下文里包含了对应 <em>stream</em> 所使用编解码器的所有信息、参数等，而现在我们拿到了上下文的指针。不过我们还是需要根据上下文找到实际的编解码器实现并打开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AVCodec* pCodec = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// Find the decoder for the video stream</span></span><br><span class="line">pCodec = <span class="built_in">avcodec_find_decoder</span>(pCodecCtxOrig-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span> (pCodec == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    spdlog::<span class="built_in">error</span>(<span class="string">&quot;Unsupported codec!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// Codec not found</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Copy context parameters</span></span><br><span class="line">pCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(pCodec);</span><br><span class="line">AVCodecParameters* pParams = <span class="built_in">avcodec_parameters_alloc</span>();</span><br><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(pParams, pCodecCtxOrig);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avcodec_parameters_to_context</span>(pCodecCtx, pParams) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">avcodec_parameters_free</span>(&amp;pParams);</span><br><span class="line">    spdlog::<span class="built_in">error</span>(<span class="string">&quot;Couldn&#x27;t copy codec contxt!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// Error copying codec context</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">avcodec_parameters_free</span>(&amp;pParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open codec</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pCodecCtx, pCodec, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// Couldn&#x27;t open codec&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们不能直接使用 <em>stream</em> 里的 <code>AVCodecContext</code>，需要使用 <code>avcodec_parameters_to_context</code> 将 stream 中编解码器参数拷贝到新的 <code>pCodecCtx</code> 中。</p><blockquote><p>原文使用 <del><code>avcodec_copy_context</code></del> 实现参数拷贝，但在新版 FFmpeg 中已经被标记为 deprecated。</p></blockquote><h2 id="暂存数据"><a href="#暂存数据" class="headerlink" title="暂存数据"></a>暂存数据</h2><p>现在还需要有个地方存 <strong>帧数据（frames）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate video frame</span></span><br><span class="line">AVFrame* pFrame = <span class="built_in">av_frame_alloc</span>();</span><br></pre></td></tr></table></figure><p>因为我们打算输出 PPM 文件，所以还需要把 FFmpeg 解码出来的原始格式转换成 RGB 格式，FFmpeg 也能帮我们完成这些转换操作。对于大多数项目（包括我们的），都会将原始的数据帧转换成特定格式。现在让我们为新格式分配一个 <code>AVFrame</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVFrame* pFrameRGB = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="keyword">if</span> (pFrameRGB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配好 <code>pFrameRGB</code> 后，还需要指定一块内存区域存放转好的 RGB 数据。我们使用 <code>avpicture_get_size</code> 计算缓冲区的大小并申请内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine required buffer size and allocate buffer</span></span><br><span class="line"><span class="type">int</span> nbBytes = <span class="built_in">avpicture_get_size</span>(AV_PIX_FMT_RGB24, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line"><span class="type">uint8_t</span>* buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">av_malloc</span>(nbBytes * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>)));</span><br></pre></td></tr></table></figure><p><code>av_malloc</code> 是 FFmpeg 对 malloc 函数的简单封装，它可以保证申请到的内存地址是对齐的。不过 <code>av_malloc</code> 不会帮你解决内存泄漏、重复释放以及其它内存分配相关问题。</p><p>接着我们使用 <code>avpicture_fill</code> 将帧和新分配好缓冲区绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign appropriate parts of the buffer to iamge planes in pFrameRGB</span></span><br><span class="line"><span class="comment">// Note that pFrameRGB is an AVFrame, but AVFrame is superset</span></span><br><span class="line"><span class="comment">// of AVPicture</span></span><br><span class="line"><span class="built_in">avpicture_fill</span>(<span class="built_in">reinterpret_cast</span>&lt;AVPicture*&gt;(pFrameRGB), buffer, AV_PIX_FMT_RGB24, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br></pre></td></tr></table></figure><p>终于，我们可以开始从流读取数据了。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>接下来我们会读取整个视频流，从中读取数据包，并解码到数据帧中，当数据帧被填满后，进行格式转换并输出到 PPM 文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize SWS context for software scaling</span></span><br><span class="line">SwsContext* pSwsCtx = <span class="built_in">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width,</span><br><span class="line">                                      pCodecCtx-&gt;height, AV_PIX_FMT_RGB24, SWS_BILINEAR, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">AVPacket packet;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">bool</span> hasError = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> hasPktUnconsumed = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> hasPktEof = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> hasFinished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!hasError) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!hasError &amp;&amp; !hasPktEof) &#123;</span><br><span class="line">    <span class="comment">// Read packet from stream</span></span><br><span class="line">    <span class="keyword">if</span> (!hasPktUnconsumed) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ret = <span class="built_in">av_read_frame</span>(pFormatCtx, &amp;packet);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; packet.stream_index == videoStream) &#123;</span><br><span class="line">          hasPktUnconsumed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == AVERROR_EOF) &#123;</span><br><span class="line">          hasPktEof = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          hasError = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// Read next packet</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send packet to decoder</span></span><br><span class="line">    <span class="keyword">if</span> (!hasError) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasPktUnconsumed &amp;&amp; !hasPktEof) &#123;</span><br><span class="line">        ret = <span class="built_in">avcodec_send_packet</span>(pCodecCtx, &amp;packet);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="built_in">avcodec_send_packet</span>(pCodecCtx, <span class="literal">nullptr</span>);  <span class="comment">// Flush decoder, EOF will returned, then receive returns EOF.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF || ret == <span class="number">0</span>) &#123;</span><br><span class="line">        hasPktUnconsumed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hasError = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Receive frame from decoder</span></span><br><span class="line">  <span class="keyword">while</span> (!hasError) &#123;</span><br><span class="line">    ret = <span class="built_in">avcodec_receive_frame</span>(pCodecCtx, pFrame);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">sws_scale</span>(pSwsCtx, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>**&gt;(pFrame-&gt;data), pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height,</span><br><span class="line">                pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);</span><br><span class="line">      <span class="comment">// Save the frame to disk</span></span><br><span class="line">      <span class="keyword">if</span> (i++ &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">SaveFrame</span>(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;</span><br><span class="line">      hasFinished = ret == AVERROR_EOF;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hasError = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hasFinished) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个的过程还是比较简单：<code>av_read_frame</code> 读取数据包并将数据存储在 <code>AVPacket</code> 中。要注意这里的只分配了 packet 结构体，FFmpeg 内部会帮我们分配缓冲区，即 <code>packet.data</code>，不再使用后通过 <code>av_free_packet</code> 释放。<code>avcodec_send_packet</code> 将 packet 发送给解码器进行解码，<code>avcodec_receive_frame</code> 从解码器中接收帧数据。通常情况下一个 packet 可以解码出一个 frame，也存在一个 packet 解出多个 frame 或多个 packet 解出一个 frame 的情况。这种 send&#x2F;receive 模式是 FFmpeg 3.3 新引入的，本质上是一个状态机模型，用户根据不同的 send&#x2F;receive 状态决定下一步操作。</p><p><img src="/img/2021/send_receive_state_machine.png" alt="Send/Receive State"></p><blockquote><p>视频编码后的帧（P帧、B帧）会参考其前后的帧进行解码，所以有时候发送一个 packet 之后，由于参考帧还 ready 就需要等包含参考帧的 packet 解码之后才解码这个 packet。<br>另外有一些编码格式会用 packet 存储一些元数据，它们并不会解码出视频帧，只是为解码器提供参数。</p></blockquote><p>解码出 frame 后我们使用 <code>sws_scale</code> 将原始图像格式（pCodecCtx-&gt;pix_fmt）转换成 RGB 格式。最后使用 <code>SaveFrame</code> 将帧数据写入 PPM 文件。</p><p>现在剩下的是实现 <code>SaveFrame</code> 将 RGB 格式的帧数据写入 PPM 文件。等会会简单介绍些 PPM 文件格式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SaveFrame</span><span class="params">(AVFrame* pFrame, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> iFrame)</span> </span>&#123;</span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  ss &lt;&lt; <span class="string">&quot;frame&quot;</span> &lt;&lt; iFrame &lt;&lt; <span class="string">&quot;.ppm&quot;</span>;</span><br><span class="line">  std::string filename = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open file</span></span><br><span class="line">  <span class="function">std::ofstream <span class="title">file</span><span class="params">(filename, std::ios_base::out | std::ios_base::binary)</span></span>;</span><br><span class="line">  <span class="comment">// Write header</span></span><br><span class="line">  std::stringstream headerSs;</span><br><span class="line">  headerSs &lt;&lt; <span class="string">&quot;P6\n&quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line">  std::string header = headerSs.<span class="built_in">str</span>();</span><br><span class="line">  file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(header.<span class="built_in">c_str</span>()), header.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// Write pixel data</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line">    file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(pFrame-&gt;data[<span class="number">0</span>] + y * pFrame-&gt;linesize[<span class="number">0</span>]), width * <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SaveFrame</code> 使用 <code>out|binary</code> 模式打开文件，然后将 RGB 数据写入，一次写入一行数据。PPM 文件是 RGB 数据排列成一个长字符串的文件格式。如果你了解 HTML 颜色编写方式，PPM 就像是将每个颜色的像素值紧密排列起来，比如 <em>#ff0000#ff0000…</em> 是纯红色（注意实际存储的二进制，并没有 <em>#</em> 等分隔符）。Header 行存储了图像的尺寸和 RGB 色值的最大值。</p><p>现在回到 <code>main</code> 函数，当我们读取完视频流后，只需要完成一些清理工作就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free frame</span></span><br><span class="line"><span class="built_in">av_free</span>(buffer);</span><br><span class="line"><span class="built_in">av_free</span>(pFrameRGB);</span><br><span class="line"><span class="built_in">av_free</span>(pFrame);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the codec</span></span><br><span class="line"><span class="built_in">avcodec_close</span>(pCodecCtx);</span><br><span class="line"><span class="built_in">avcodec_close</span>(pCodecCtxOrig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the video file</span></span><br><span class="line"><span class="built_in">avformat_close_input</span>(&amp;pFormatCtx);</span><br></pre></td></tr></table></figure><p>你应该注意到我们使用 <code>av_free</code> 释放那些使用 <code>avcodec_alloc_frame</code> 和 <code>av_malloc</code> 申请的内存。</p><blockquote><p>程序运行部分就不赘述了，可以下载源码查看，执行后就能得到五张本文的封面图！！！</p></blockquote><p>这些就是本节教程的全部内容，源码已经上传 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">GitHub</a> 。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/tutorial01.html">原文链接</a></p><p><a target="_blank" rel="noopener" href="https://ffmpeg.org/doxygen/3.3/group__lavc__encdec.html">send&#x2F;receive encoding and decoding API overview</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/TaigaCon/p/10041926.html">FFmpeg 解码 API</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
            <tag> PPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【DangerFFmpeg】开篇</title>
      <link href="/2021/05/14/e9ab622cfede.html"/>
      <url>/2021/05/14/e9ab622cfede.html</url>
      
        <content type="html"><![CDATA[<p>前段时间学习 FFmpeg 的时候找到一个《How to Write a Video Player in Less Than 1000 Lines》系列文章，虽说 1000 行代码的以内的播放器，但是是基于 FFmpeg 2.x 和 SDL 实现的，而自己的电脑又是安装的 FFmpef 4.x 和 SDL2，所以有很多的 API 已经过时甚至是移除了，整个过程中的阻力比较大，最后也没有完全实现这个千行播放器。最近正好时间相对比较充裕，准备重整旗鼓，用新版 FFmpeg 和 SDL 重新挑战一波，然后也顺便把这个系列翻译成中文，加深理解。</p><p>因为这个原文章的网址是 <a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg">http://dranger.com/ffmpeg</a> ，所以称这次翻译系列就叫做 <strong>DangerFFmpeg</strong>。这个系列一共包含 9 个小结，第一节也就是本文正文部分即将翻译的开篇，最后一节是总结与展望，中间 7 小结才是本系列的重点。译文中会加入一些自己的理解，如有偏差，欢迎指出斧正。</p><blockquote><p><strong>本系列的开发环境</strong></p><p>操作系统：macOS BigSur<br>编程语言：C++ 14<br>FFmpeg 版本：FFmpeg 4.4<br>SDL 版本：SDL2</p></blockquote><p><strong>已完结，完整目录：</strong></p><p>《<a href="/2021/05/14/8cf36b195b05.html">开篇</a>》<br>《<a href="/2021/05/15/1c458d50c524.html">第一节、屏幕截图</a>》<br>《<a href="/2021/05/16/aeb0b6c30d08.html">第二节、输出到屏幕</a>》<br>《<a href="/2021/05/20/d4b63d917433.html">第三节、播放声音</a>》<br>《<a href="/2021/05/22/71765970ad7e.html">第四节、多线程</a>》<br>《<a href="/2021/05/30/088658998748.html">第五节、视频同步</a>》<br>《<a href="/2021/06/05/d8b51b0cff00.html">第六节、同步音频</a>》<br>《<a href="/2021/06/09/2f01ccb59968.html">第七节、快进快退</a>》<br>《<a href="/2021/06/19/7ddfef63d330.html">结语</a>》</p><hr><p><a target="_blank" rel="noopener" href="https://ffmpeg.org/">FFmpeg</a> 在视频应用或其它相关工具方面，是一款非常强大的工具库。FFmpeg 帮你解决视频处理过程中的各种麻烦问题，比如编解码与解封装等，这让多媒体应用开发变得更简单。FFmpeg 使用 C 进行开发，执行速度非常快，并且支持几乎所有编解码格式（通过集成不同的编解码器）。</p><p>FFmpeg 唯一的问题是文档聊胜于无（相关资料还是现在比较全了）。有一个 <a target="_blank" rel="noopener" href="http://www.inb.uni-luebeck.de/~boehme/using_libavcodec.html">教程</a> (作者是 <a target="_blank" rel="noopener" href="http://www.inb.uni-luebeck.de/staff/boehme-d.html">Martin Böhme</a>，现在已经无法访问了) 演示了 FFmpeg 基础用法和 doxygen 文档。情况就是这样，所以当我决定学习 FFmpeg 和 多媒体应用的工作原理时，我决定记录学习过程并且作为教程分享出来。</p><p>FFmpeg 附带有一个叫 ffplay 的示例程序，ffplay 是个简单的 C 程序，并且实现了一个完整的视频播放器。这个系列教程将从 <em>Martin Böhme</em> 教程的更新版本开始，基于 Fabrice Bellard 的 ffplay 开发一个可以正常工作的视频播放器。每个教程中，我都会介绍一两个新的设计思想，并解释如何实现它们。每篇教程都会有一个 Cpp 文件可供下载（当然是放 GitHub 啦），方便你在自己电脑上编译并学习。这些源代码会向你展示真实程序的工作方式，如何将学到的知识组装起来，并且会演示一些教程之外的技术细节。等我们学习完这个系列，我们将会得到一个 1000 行代码以内的视频播放器。</p><p>在编写播放器时，我们会使用 <a target="_blank" rel="noopener" href="https://www.libsdl.org/">SDL2</a> 输出视频文件的音频和图像。 SDL2 是一个非常优秀的跨平台多媒体库，在 MPEG 播放软件，模拟器以及许多视频游戏中都有应用。所以你需要事先给系统安装 SDL 开发库（mac 下 <code>brew install SDL2</code> 就完事了），这样才能成功编译教程中的程序。</p><p>这个系列面向的有一定开发经验的朋友，至少你应该了解 C 并对诸如<strong>队列</strong>、<strong>锁</strong>等概念有一定的了解。你也应该了解一些多媒体的基础知识，比如 waveforms，不过并不需要了解非常多，因为我会在教程中向你介绍一些概念。</p><p>这些教程也提供老式 ASCII 格式的教程记录，你也可以下载<a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/ffmpegtutorial.tar.gz">教程和源代码</a>或只有<a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg/ffmpegsource.tar.gz">源码</a>的压缩包。</p><blockquote><p>上面这句话就不要当真了。</p></blockquote><p>请随时通过 <a href="mailto:clsrfish@gmail.com">clsrfish@gmail.com</a> 向我反馈 bug、疑问、评论、想法、功能或任何其它相关消息。</p><hr><p>教程中代码上传至 <a target="_blank" rel="noopener" href="https://github.com/clsrfish/dangerffmpeg">https://github.com/clsrfish/dangerffmpeg</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://dranger.com/ffmpeg">Danger FFmpeg</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode遇上GoogleTest</title>
      <link href="/2021/05/08/919a851d9cd5.html"/>
      <url>/2021/05/08/919a851d9cd5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章将记录怎么用 <a target="_blank" rel="noopener" href="https://google.github.io/googletest/">GoogleTest</a> 来管理 LeetCode 的测试 case，以及优化 CMakeLists 配置避免每次都需要编译、链接整个工程，最后再利用 GitHub Action 进行自动化测试。文中不会对 Google Test 细节进行介绍，感兴趣的可以去官网阅读。</p><p>如果还不了解如何使用 VSCode 和 CMake 管理你的 C++ 工程，建议先看看<a href="./1.VSCode%E6%90%AD%E5%BB%BAC++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.md">这篇文章</a>。</p><p>本文基于 macOS 10.15，Linux 环境下差别不大，后面也会提到一些 Linux 相关的配置 。</p></blockquote><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>为了方便回顾每道 LeetCode 的 AC 过程，每道题的解答都在同一个 CMake 工程中进行管理，公共数据结构（比如 ListNode、TreeNode 等）使用单独的 model 模块进行管理，不同 LeetCode 就用命名空间 <code>leetcode_xxx</code> 进行隔离，通过 <code>xxx</code> 确定某次需要运行的 LeetCode 解答，整个工程统一编译链接，构建一个可执行文件。使用这种方式管理的工程目录结构大概长这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">├── build # 编译产物</span><br><span class="line">└── src</span><br><span class="line">    ├── 1.cpp</span><br><span class="line">    ├── 2.cpp</span><br><span class="line">    ├── xxx.cpp</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── model # 存放公共数据结构</span><br><span class="line">    │   ├── CMakeLists.txt</span><br><span class="line">    │   ├── list_node.cpp</span><br><span class="line">    │   └── list_node.hpp</span><br><span class="line">    └── utils # 存放工具函数</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        ├── stl_utils.cpp</span><br><span class="line">        └── stl_utils.hpp</span><br></pre></td></tr></table></figure><p>每道 LeetCode 解答（xxx.cpp）代码结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leetcode_xxx &#123;</span><br><span class="line"></span><br><span class="line">string key = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solutionName</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: 标题&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">Solution</span>().<span class="built_in">solutionName</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有 LeetCode 解答在 <code>main.cpp</code> 中用 <code>map&lt;std::string, int (*)()&gt;</code> 保存，通过指定 key 确认需要执行的 LeetCode：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span> (*)()&gt; leetcodes&#123;</span><br><span class="line">      <span class="built_in">PROBLEM</span>(leetcode_xxx), ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string lckey = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    <span class="comment">// 通过参数指定需要执行的 LeetCode</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    std::string input = std::<span class="built_in">string</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (leetcodes.<span class="built_in">count</span>(input) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      lckey = input;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;invalid input:&quot;</span> &lt;&lt; input &lt;&lt; <span class="string">&quot;, running &quot;</span> &lt;&lt; lckey &lt;&lt; <span class="string">&quot; instead&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> leetcodes[lckey]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每道题解代码格式固定，可以使用 VSCode <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">Snippet</a> 避免模板代码。这样，我们就可以在 VSCode 中快速创建新的 LeetCode 题解并调试了。</p><h3 id="1-1-编译速度影响刷题体验"><a href="#1-1-编译速度影响刷题体验" class="headerlink" title="1.1. 编译速度影响刷题体验"></a>1.1. 编译速度影响刷题体验</h3><p>按照上面的方式组织代码一开始运行得还不错，在有编译缓存的情况下 <strong>F5</strong> 能够在<strong>数秒内</strong>调试运行，全量编译耗时也在一个可接受的水平（<strong>20s</strong> 左右）。但是随着刷题量越来越多，编译链接速度出现了非常明显的下降，有时候也会在办公电脑上刷题（系统版本不同），全量编译造成的糟糕开发体验也越来越不可接受。</p><p>所以需要调整 CMakeLists 配置，<strong>指定需要调试的 LeetCode ，减少参与编译的源码数量（cpp 文件）</strong>。</p><h3 id="1-2-测试-Case-编写繁琐"><a href="#1-2-测试-Case-编写繁琐" class="headerlink" title="1.2. 测试 Case 编写繁琐"></a>1.2. 测试 Case 编写繁琐</h3><p>第二个影响刷题体验的问题是测试 Case 的编写。</p><p>正如上面实例代码，所有的测试 case 都需要自己手动构造参数并检验运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leetcode_xxx &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 编排测试 case</span></span><br><span class="line">    std::vector&lt;std::tuple&lt;std::string, <span class="type">int</span>&gt;&gt; testCases&#123;</span><br><span class="line">        std::<span class="built_in">make_tuple</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">5</span>),</span><br><span class="line">        std::<span class="built_in">make_tuple</span>(<span class="string">&quot;world&quot;</span>, <span class="number">5</span>),</span><br><span class="line">        std::<span class="built_in">make_tuple</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 2. 遍历测试 case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = testCases.<span class="built_in">begin</span>(); it != testCases.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        std::string input;</span><br><span class="line">        <span class="type">int</span> expected;</span><br><span class="line">        std::<span class="built_in">tie</span>(input, expected) = *it;</span><br><span class="line">        <span class="type">int</span> actual = <span class="built_in">Solution</span>().<span class="built_in">charCount</span>(input);</span><br><span class="line">        <span class="comment">// 3. 组装输出日志</span></span><br><span class="line">        <span class="keyword">if</span> ( actual != expected ) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;input(&quot;</span> &lt;&lt; input &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot; FAILED&quot;</span>&lt;&lt; std::endl</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\texpected: &quot;</span>&lt;&lt; expected &lt;&lt; <span class="string">&quot;actual: &quot;</span>&lt;&lt; actual &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;input(&quot;</span> &lt;&lt; input &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot; PASSED&quot;</span>&lt;&lt; std::endl</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每道题都需要手动完成上面代码中的 3 个步骤，存在一定量的模板代码，入参、返回值的数量和类型也没法用 Snippet 很好解决。特别是当某个 Test Case 计算出错需要调试时，需要注释某些 Test Case 进行针对调试，轻度强迫症患者认为这种操作不够优雅。</p><h2 id="2-使用-GoogleTest-管理-TestCase"><a href="#2-使用-GoogleTest-管理-TestCase" class="headerlink" title="2. 使用 GoogleTest 管理 TestCase"></a>2. 使用 GoogleTest 管理 TestCase</h2><blockquote><p>每道 LeetCode 题解都是一个简单函数调用，非常适合单元测试。</p></blockquote><p>GooleTest 是 Google 开源的 C++ 测试、Mock 框架，基于 <strong>xUnit</strong> 架构实现，用过 xUnit 的朋友上手几乎没有额外的理解成本。GoogleTest 遵照以下理念（摘自官网）实现：</p><ol><li>Tests should be independent and repeatable. It’s a pain to debug a test that succeeds or fails as a result of other tests. googletest isolates the tests by running each of them on a different object. When a test fails, googletest allows you to run it in isolation for quick debugging.</li><li>Tests should be well organized and reflect the structure of the tested code. googletest groups related tests into test suites that can share data and subroutines. This common pattern is easy to recognize and makes tests easy to maintain. Such consistency is especially helpful when people switch projects and start to work on a new code base.</li><li>Tests should be portable and reusable. Google has a lot of code that is platform-neutral; its tests should also be platform-neutral. googletest works on different OSes, with different compilers, with or without exceptions, so googletest tests can work with a variety of configurations.</li><li>When tests fail, they should provide as much information about the problem as possible. googletest doesn’t stop at the first test failure. Instead, it only stops the current test and continues with the next. You can also set up tests that report non-fatal failures after which the current test continues. Thus, you can detect and fix multiple bugs in a single run-edit-compile cycle.</li><li>The testing framework should liberate test writers from housekeeping chores and let them focus on the test content. googletest automatically keeps track of all tests defined, and doesn’t require the user to enumerate them in order to run them.</li><li>Tests should be fast. With googletest, you can reuse shared resources across tests and pay for the set-up&#x2F;tear-down only once, without making tests depend on each other.</li></ol><p>如果上面这些理解都落实到了 GoogleTest 实现中，我们将从繁琐的测试 Case 编写中解放出来，专注于问题本身。利用 GoogleTest，我们不用手动遍历参数组合、不用在某个统一位置（<code>main.cpp</code>）手动指定需要执行那个问题（第 5 条）；当测试失败时，框架会自动输出参数和结果，并且可以运行特定参数组合的 Test Case 而不是通过注释代码实现（第 1 条，第 4 条）。</p><h3 id="2-1-添加-Google-Test-依赖"><a href="#2-1-添加-Google-Test-依赖" class="headerlink" title="2.1. 添加 Google Test 依赖"></a>2.1. 添加 Google Test 依赖</h3><p>有很多种方式添加 GoogleTest 的依赖，比如 拷贝源码或依赖静态&#x2F;动态库、git submodule 以及 CMake FetchContent。显然，第一种方式是灵活性最低的一种，既没办法快速升级新版本，还要配置好 header、.so、.a 路径，在新机器上还需要重新下载这些文件（如果把它们加入版本控制就另当别论了）。第二种方式较第一种稍好，可以快速升级并在新机器上建立环境。第三种方式是本文使用的方式，也是 GoogleTest 官方推荐的，较 git submodule，可以让 CMake 帮我们管理 gtest 项目路径变量，下面是相关配置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include 要求 CMake &gt;= 3.11</span></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line"><span class="comment"># Google Test 官网推荐使用最新 commit，非常勇</span></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">    gtest</span><br><span class="line">    GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">    GIT_TAG release-<span class="number">1.10</span>.<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="comment"># 获取/创建 gtest 相关变量</span></span><br><span class="line">FetchContent_GetProperties(gtest)</span><br><span class="line"><span class="comment"># 注意这里的 gtest 是上面 gtest 的小写, 个人感觉全小写可读性更高.</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> gtest_POPULATED)</span><br><span class="line">    <span class="comment"># 下载gtest源码到指定目录</span></span><br><span class="line">    FetchContent_Populate(gtest)</span><br><span class="line">    <span class="comment"># message($&#123;gtest_SOURCE_DIR&#125; $&#123;gtest_BINARY_DIR&#125;)</span></span><br><span class="line">    <span class="comment"># 将 gtest 工程添加到编译流程</span></span><br><span class="line">    <span class="keyword">add_subdirectory</span>(<span class="variable">$&#123;gtest_SOURCE_DIR&#125;</span> <span class="variable">$&#123;gtest_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># FetchContent_Declare 后面的配置可以用下面一行配置代替.</span></span><br><span class="line"><span class="comment"># FetchContent_MakeAvailable(googletest)</span></span><br></pre></td></tr></table></figure><p>配置好后重新执行 <code>CMake: Configure</code> 就会自动下载 gtest 项目并解压到 <code>build/_dep</code>（默认目录）。</p><p><img src="/img/2021/cmake_configure.jpg" alt="CMake: Configure"></p><h3 id="2-2-创建测试程序"><a href="#2-2-创建测试程序" class="headerlink" title="2.2. 创建测试程序"></a>2.2. 创建测试程序</h3><p>接下来需要为测试创建一个 executable target，首先编写测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// hello_test.cpp</span><br><span class="line">TEST(HelloTest, BasicAssertions) &#123;</span><br><span class="line">  // Expect two strings not to be equal.</span><br><span class="line">  EXPECT_STRNE(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">  // Expect equality.</span><br><span class="line">  EXPECT_EQ(7 * 6, 42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TEST</code> 是一个宏函数，它定义了测试集合名称和测试 Case 名称，宏展开后会一个 <code>class</code>，类似的宏函数还有 <code>TEST_F</code>、<code>TEST_P</code>，至于它们的实现细节，以及如何做到自动收集所有的测试 Case，暂时还没来得及去探究，等后面有时间了再回过头补上。</p><p>然后修改 <code>CMakeLists.txt</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启测试，非常重要</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">  hello_test</span><br><span class="line">  hello_test.cpp</span><br><span class="line">)</span><br><span class="line"><span class="comment"># gtest_main 在 gtest 项目中定义，在前面用 add_subdirectory 引入了，所以这里可以直接使用</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">  hello_test</span><br><span class="line">  gtest_main</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line">gtest_discover_tests(hello_test)</span><br></pre></td></tr></table></figure><p><code>gtest_discover_tests</code> 使用 post-build 从 target（hello_test）中获取所有定义的测试 Case。<code>gtest_main</code> 中定义了 main 函数，会根据输入参数（–gtest_filter 等）自动执行测试 Case。</p><blockquote><p>所以即使只想执行某一个测试Case，也需要完整编译工程。<br>使用 <code>TEST_F</code> 和 <code>TEST_P</code> 也还是会存在一定模板代码，继续用 Snippet 解决。</p></blockquote><h3 id="2-3-C-TestMate-拓展"><a href="#2-3-C-TestMate-拓展" class="headerlink" title="2.3. C++ TestMate 拓展"></a>2.3. C++ TestMate 拓展</h3><p>完成上面两个步骤之后就可以编译并运行单元测试了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -S . -B build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build &amp;&amp; ctest</span></span><br></pre></td></tr></table></figure><p>在<a href="../../Cpp/1.VSCode%E6%90%AD%E5%BB%BAC++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.md">VSCode搭建C++开发环境</a>中讲解过怎么使用 VSCode <strong>F5</strong> 代替命令行一键运行，这里就不做过多赘述了。</p><p><strong>F5</strong> 虽然能快速地运行测试，但是测试 Case 的执行结果在 <strong>DEBUG CONSOLE</strong> 中不是非常直观（没有高亮显示），并且无法单独调试某个失败的 Case，粒度比较粗。这里推荐安装 <a target="_blank" rel="noopener" href="https://github.com/matepek/vscode-catch2-test-adapter">C++ TestMate</a>，它会在 <strong>Test Explorer</strong> 中列举出所有的测试 Case，支持一键运行所有 Case 的同时也支持或特定 Case&#x2F;Suite 的运行、调试（见截图，实际体验会很不错）。</p><p><img src="https://github.com/matepek/vscode-catch2-test-adapter/raw/master/resources/Screenshot_2019-05-28.png" alt="C++ TestMate"></p><p>因为 C++ TestMate 通过可执行文件列举测试 Case，安装拓展后要根据你实际的工程配置下可执行文件&#x2F;编译产物的位置：<br><img src="/img/2021/cpp_testmate_exeutables.jpg"></p><blockquote><p>如果可执行文件名带有 test 字样，并且在 build、out 等目录中，使用默认配置就可以了。</p></blockquote><p><strong>一个小坑</strong></p><p>在配置 VSCode 一键运行时掉进了一个坑，导致 <strong>F5</strong> 一键运行无法断点调试，但是用 C++ TestMate 的调试按钮就可以断点调试。但是 C++ TestMate 列举测试 Case 依赖可执行文件的构建成功，所以修改完代码需要先 <strong>build</strong> 再在 C++ TestMate 中启动调试，流程变麻烦了。</p><p>各种排查之后发现是因为添加了两个参数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// launch.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMake - Build and launch debuging(lldb)&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/main_test&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="comment">// cause debugger not able to attach</span></span><br><span class="line">                <span class="string">&quot;--gtest_list_tests&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;--gtest_output=xml:$&#123;workspaceFolder&#125;/build/gtest_list.xml&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>当时是安装好 C++ TestMate 后去查看它都有哪些可以优化体验的配置，然后就看到了 <strong>Test List Caching</strong> 配置，说是能加速测试 Case 在 Test Explorer 中刷新的速度，没多想就给加上了参数，然后就掉坑了。因为实际体验这两个参数加上好像也没啥变化，所以就不要画蛇添足了。</p><p><img src="/img/2021/cpp_testmate.jpg"></p><h2 id="3-优化编译速度"><a href="#3-优化编译速度" class="headerlink" title="3. 优化编译速度"></a>3. 优化编译速度</h2><p>第 2 节中我们利用 GoogleTest 解决了测试 Case 编写繁琐的问题，现在要解决是如何优化编译速度，<strong>进一步提高刷题的幸福感</strong>。</p><p>先看下 <code>src/CMakeLists.txt</code> 的内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(. SRC)</span><br><span class="line"><span class="keyword">add_library</span> (src <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><p>内容非常简单，就是将 <strong>src</strong> 目录下所有 <code>.cpp</code> 编译链接成一个 <em>libsrc.a</em> 。由于每个 <code>.c/.cc/.cxx/.cpp</code> 文件都是一个独立的编译单元，都需要独立解析 include 的 header 文件，如果 header 中有 template（STL、Boost），就会实例化相同的模板实例。LeetCode 到目前为止一共 2K+ 道题，触发一次全量编译差不多得花 30min+（MacBook pro 2017），所以随着刷题数量的增加，在编译上浪费的时间也会越来越多，体验越来越差。</p><p>所以最直接的想法就是<strong>指定需要参与编译的源文件，即指定 LeetCode 题号对应的源文件</strong>，将编译耗时保持在数秒之内。</p><blockquote><p>题解文件名按 xxx.cpp 命名，对应测试代码是 xxx_test.cpp</p></blockquote><p>下面是优化后的 <code>src/CMakeLists.txt</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LEETCODE_SRC_FILE <span class="string">&quot;ALL&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;Which src files need compiling.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;LEETCODE_SRC_FILE&#125;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;ALL&quot;</span> <span class="keyword">OR</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="variable">$&#123;LEETCODE_SRC_FILE&#125;</span>)</span><br><span class="line">  <span class="keyword">aux_source_directory</span>(. SRC)</span><br><span class="line">  <span class="keyword">add_library</span> (src <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">add_library</span> (src <span class="variable">$&#123;LEETCODE_SRC_FILE&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>我们定义 <code>LEETCODE_SRC_FILE</code> 指定需要编译的源文件，然后在根目录的 <code>CMakeLists.txt</code> 中接收命令行参数并传递值给 <code>LEETCODE_SRC_FILE</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">set</span>(LEETCODE_PROBLEM <span class="string">&quot;ALL&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;Choose the problem to run, all problems will be build if not specified or not found.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;LEETCODE_PROBLEM&#125;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;ALL&quot;</span>)</span><br><span class="line">    <span class="comment"># Build all.</span></span><br><span class="line">    <span class="keyword">set</span>(LEETCODE_SRC_FILE <span class="string">&quot;ALL&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">    <span class="keyword">aux_source_directory</span>(./<span class="keyword">test</span> TEST_SUIT_SRCS)</span><br><span class="line">    <span class="keyword">add_executable</span>(main <span class="variable">$&#123;TEST_SUIT_SRCS&#125;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># Build single.</span></span><br><span class="line">    <span class="keyword">set</span>(LEETCODE_SRC_FILE <span class="variable">$&#123;LEETCODE_PROBLEM&#125;</span>.cpp CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">    <span class="keyword">add_executable</span>(main <span class="keyword">test</span>/<span class="variable">$&#123;LEETCODE_PROBLEM&#125;</span>_test.cpp)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>这里再次定义了个类似的 <code>LEETCODE_PROBLEM</code> 变量，即“题号”，然后在编译时通过 <code>-DLEETCODE_PROBLEM=XX</code> 传递给 CMake，这样就做到了指定源码编译。</p><blockquote><p><code>set</code> 命令的用法见 <a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/git-stage/command/set.html">CMake 文档</a>，<code>FORCE</code> 是为了保证参数不受缓存影响而及时生效。</p></blockquote><p>对应的，再调整下 <code>tasks.json</code>，加上 <code>LEETCODE_PROBLEM</code> 参数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;process&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: cmake debug build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmake&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;--log-level=DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-DCMAKE_BUILD_TYPE=Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="comment">// twoSum</span></span><br><span class="line">                <span class="string">&quot;-DLEETCODE_PROBLEM=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="comment">// cwd: build</span></span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这样每次只需要修改 <code>tasks.json</code> 就可以直接 <strong>F5</strong> 调试了。</p><h2 id="4-使用-GitHub-Action-自动化测试"><a href="#4-使用-GitHub-Action-自动化测试" class="headerlink" title="4. 使用 GitHub Action 自动化测试"></a>4. 使用 GitHub Action 自动化测试</h2><p>虽然到这里我们已经可以愉快地刷题了，但是刷题过程中对数据结构的修改可能影响了已有题解，考虑到编译耗时，我们又不太可能会随时全量编译，这些未及时发现的问题就累积下来了。</p><p>这里我们可以借助 GitHub Actions 提供的 CI&#x2F;CD 能力，在 push 之后执行全量编译并执行测试，失败了还可以配置邮件通知，及时暴露问题。</p><p>这里就直接贴配置了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">gtest:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Run</span> <span class="string">tests</span> <span class="string">on</span> <span class="string">GTest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="comment"># 在 macOS 和 Linux 两个平台测试，提高代码可移植性.</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">os:</span> [<span class="string">macos-latest</span>, <span class="string">ubuntu-latest</span>]</span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">buildDir:</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; github.workspace &#125;&#125;</span>/build&quot;</span></span><br><span class="line">      <span class="attr">executable:</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Project</span> <span class="string">checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">latest</span> <span class="string">CMake</span> <span class="string">and</span> <span class="string">ninja</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">lukka/get-cmake@latest</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">CMake,</span> <span class="string">build</span> <span class="string">with</span> <span class="string">CMake</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">lukka/run-cmake@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">cmakeListsTxtPath:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.workspace</span> <span class="string">&#125;&#125;/CMakeLists.txt</span></span><br><span class="line">          <span class="attr">buildDirectory:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.buildDir</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 不指定 LEETCODE_PROBLEM 默认是全量编译.</span></span><br><span class="line">          <span class="attr">cmakeAppendedArgs:</span> <span class="string">&quot;--log-level=DEBUG -Wdev -DCMAKE_BUILD_TYPE=Debug&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">executable</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.buildDir</span> <span class="string">&#125;&#125;/$&#123;&#123;</span> <span class="string">env.executable</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>然后可以在 README.md 中配置个<a target="_blank" rel="noopener" href="https://docs.github.com/en/actions/managing-workflow-runs/adding-a-workflow-status-badge">徽标</a>，显示上次自动化测试的执行结果。</p><blockquote><p>如果本地没有 Linux 环境，可以使用 docker 容器曲线救国。</p></blockquote><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>GoogleTest 将我们从繁琐的测试 Case 中解放出来；而最小化编译使我们免于低效地等待编译；GitHub Actions 则帮助我们及时纠正不小心引入的问题。工欲善其事，必先利其器，善于利用工具，改进影响效率的瓶颈，避免陷入低效陷阱。</p><p>完整项目代码见 <a target="_blank" rel="noopener" href="https://github.com/Clsrfish/leetcode">https://github.com/Clsrfish/leetcode</a> 。</p><h2 id="6-参考文章"><a href="#6-参考文章" class="headerlink" title="6. 参考文章"></a>6. 参考文章</h2><p><a target="_blank" rel="noopener" href="https://google.github.io/googletest/">Google Test</a></p><p><a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/module/FetchContent.html">FetchContent</a></p><p><a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/git-stage/command/set.html">CMake set</a></p><p><a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/git-stage/module/GoogleTest.html">GoogleTest Module</a></p><p><a target="_blank" rel="noopener" href="https://github.com/features/actions">GitHub Actions</a></p><p><a target="_blank" rel="noopener" href="https://docs.github.com/en/actions/managing-workflow-runs/adding-a-workflow-status-badge">Adding a workflow status badge</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> GoogleTest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 搭建 C++ 开发环境</title>
      <link href="/2021/01/18/38be76b81723.html"/>
      <url>/2021/01/18/38be76b81723.html</url>
      
        <content type="html"><![CDATA[<p>毕业后开始对 C++ 着迷，但是毕竟工作基本用不上，所以大多数时候都是写一些小程序。因为日常开发使用 Android Studio，所以在选择 C++ 编辑器&#x2F;IDE 时自然而然想到了它的兄弟 CLion，不过还是因为 JB 家的东西都太吃内存而放弃了；第二个想到的是 XCode，颜值与实力并存，最终没有选择 XCode 还是因为它”过度”封装，无法把握工程细节和编译过程（也可能是我没找到相关设置）。最后选择 VSCode 是因为它足够轻量，简单配置后就能像 IDE 一样一键运行&#x2F;调试，同时工程文件所见即所得，不会像 XCode 无法直观地知道源文件的磁盘路径。</p><hr><h2 id="1-安装拓展"><a href="#1-安装拓展" class="headerlink" title="1. 安装拓展"></a>1. 安装拓展</h2><p>VSCode 原生并不支持 C&#x2F;C++ 开发，所以需要安装一些拓展来提供一些必要的能力：<strong>语法高亮</strong>、<strong>错误提示</strong>、<strong>自动补全</strong>以及最重要的<strong>调试&#x2F;运行</strong>。</p><h3 id="1-1-C-x2F-C"><a href="#1-1-C-x2F-C" class="headerlink" title="1.1. C&#x2F;C++"></a>1.1. C&#x2F;C++</h3><p><img src="https://ms-vscode.gallerycdn.vsassets.io/extensions/ms-vscode/cpptools/1.1.3/1607049308689/Microsoft.VisualStudio.Services.Icons.Default" alt="C/C++"></p><p>巨硬提供的 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C&#x2F;C++</a> 拓展，安装量远超其它 C&#x2F;C++ 拓展，提供了几乎所有 C++ 开发所需要的功能。</p><p>默认配置下也能用得比较开心，但是每个人的快乐都不太一样，所以还是要简单配置下，下面是一些个人认为需要额外配置的设置项：</p><ul><li>C_Cpp.formatting，格式化风格，Unix[-like]下就选 clangFormat 吧；</li><li>C_Cpp.clang_format_sortIncludes，include 的头文件排序（很棒）；</li><li>C_Cpp.clang_format_fallbackStyle，配置默认的代码风格，可选的有 LLVM、Google 等，每个都试试选个自己喜欢的就好；</li><li>C_Cpp.intelliSenseUpdateDelay，默认的智能提示延迟比较大，设置小点可以更快地看到提示；</li><li>C_Cpp.default.configurationProvider，智能提示配置，比如C++ 标准、头文件目录等，但是后面我们也会在 CMakeLists.txt 里配置相同的信息，为避免重复，就有了这个选项，填 <code>ms-vscode.cmake-tools</code> 就好了（下面会安装）。有可能在安装完 C&#x2F;C++ 后 VSCode 自动创建了个 <code>c_cpp_properties.json</code> 它就是 C&#x2F;C++ 默认的智能提示配置，不过我们设置 configurationProvider 后，可以删除这个文件。</li></ul><blockquote><p>更多的配置可以看 C&#x2F;C++ 的 README。</p><p>C&#x2F;C++ 的智能提示响应速度有点慢，如果追求极致体验，可以另外安装 clangd 插件，并关闭 C&#x2F;C++ 的语法检测和智能提示。实际体验速度确实快，不过格式化配置有点小问题，所以我暂时就没有使用，可能后续回有改进吧。</p></blockquote><h3 id="1-2-CMake-拓展"><a href="#1-2-CMake-拓展" class="headerlink" title="1.2. CMake 拓展"></a>1.2. CMake 拓展</h3><p>其实安装完 C&#x2F;C++ 拓展已经可以开发 C++ 程序了，不过随着学习的深入，需要借助一些工具来管理我们的 C&#x2F;C++ 工程，减少不必要的手工操作。</p><p>这里安装 <a target="_blank" rel="noopener" href="https://twxs.gallerycdn.vsassets.io/extensions/twxs/cmake/0.0.17/1488841920286/Microsoft.VisualStudio.Services.Icons.Default">CMake</a> 和 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">CMake Tools</a> 就好了。前者为 CMake 脚本文件提供语法高亮和智能提示，后者为 CMake-based 工程提供快捷操作。</p><p>具体怎么配置到后面用到的时候再讨论。</p><blockquote><p>CLion 默认使用 CMake 管理工程</p></blockquote><h2 id="2-开始调试"><a href="#2-开始调试" class="headerlink" title="2. 开始调试"></a>2. 开始调试</h2><p>国际惯例，以 hello world （main.cpp）为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-编译运行"><a href="#2-1-编译运行" class="headerlink" title="2.1. 编译运行"></a>2.1. 编译运行</h3><p>安装好 C&#x2F;C++ 拓展后直接 <strong>F5</strong> 运行（调试）程序（单文件的 hello world），第一次运行会提示你完成一些基本配置。</p><p><img src="/img/2021/1st_f5.jpg" alt="press F5 for the first time"></p><p>如果用的 macOS&#x2F;Linux ，那就选 <strong>GDB&#x2F;LLDB</strong>，Window 用户就选 <strong>Windows</strong>， 选完调试工具后紧接着需要选择要使用的<strong>编译器</strong>，下面是 macOS 下给出的几个选择，对齐 Xcode 使用 clang++ 就好了。</p><p><img src="/img/2021/1st_f5_compiler.jpg" alt="choose compiler"></p><p>指定好编译器后就会开始编译并运行程序，不出意外就能在 <em>Debug Console</em> 中看到 <code>hello world</code> 了。</p><h3 id="2-2-编译产物"><a href="#2-2-编译产物" class="headerlink" title="2.2. 编译产物"></a>2.2. 编译产物</h3><p>执行完上面操作后目录下多了一些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .vscode # VSCode 生成的编译/调试配置文件</span><br><span class="line">│   ├── launch.json</span><br><span class="line">│   └── tasks.json</span><br><span class="line">├── main # 可执行程序</span><br><span class="line">├── main.cpp # 源代码</span><br><span class="line">└── main.dSYM # 调试信息，添加编译选项 -g 时产生，没有它就无法调试</span><br><span class="line">    └── Contents</span><br><span class="line">        ├── Info.plist</span><br><span class="line">        └── Resources</span><br><span class="line">            └── DWARF</span><br><span class="line">                └── main</span><br></pre></td></tr></table></figure><p><code>tasks.json</code> 中定义了编译任务：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span> <span class="comment">// 决定了任务是以单独进程还是命令执行</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang++&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定编译器</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span> <span class="comment">// 开启调试</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span> <span class="comment">// 需要编译的文件</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span> <span class="comment">// 指定输出文件</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span> <span class="comment">// 指定工作目录</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 定如何去匹配任务输出信息（比如语法错误、警告），并将信息展示在 PROBLEMS 中，这里选择 C/C++ 拓展提供的 gcc</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 指定任务所属集合</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span> <span class="comment">// 是否为任务集中默认任务</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task generated by Debugger.&quot;</span> <span class="comment">// 描述信息</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>launch.json</code> 中定义了启动配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang++ - Build and debug active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定调试类型，有 C/C++ 拓展提供支持</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定调试方式，是新启动程序并调试还是调试一个已启动的进程</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span> <span class="comment">// 可执行文件</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 可执行文件启动时的参数，对应 argv</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 环境变量</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> <span class="comment">// 是否打开外部终端进行调试</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span> <span class="comment">// 调试工具，lldb 或 gdb</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang++ build active file&quot;</span> <span class="comment">// 启动之前执行的任务, 调试之前需要有可执行文件，所以这里是执行一个编译任务</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-使用-CMake-管理工程"><a href="#3-使用-CMake-管理工程" class="headerlink" title="3. 使用 CMake 管理工程"></a>3. 使用 CMake 管理工程</h2><p>上面的配置方式对于单文件的 demo 是够用了，但是面对多文件工程，还是显得力不从心，比如需要手工把参加编译的源文件添加到编译任务的 <code>args</code> 参数中，并且源文件改名、变更目录都需要手工修改对应配置，否则会编译失败。</p><p>C++ 一直依靠社区发展，工程组织和依赖管理也没有一个“标准”，不过近年来 <a target="_blank" rel="noopener" href="https://cmake.org/">CMake</a> 似乎已经成为了事实上的 C++ 工程管理工具，CMake 并不直接编译，而是有序地组织系统构建工具来支持开发、测试以及发布等。CMake 还一个非常棒的功能是它能够根据配置文件（CMakeLists.txt）生成其它工具、平台的工程配置（Unix[-like] 的 Makefile、MSVC 的 solution等），非常适合需要跨平台的项目。</p><blockquote><p>CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK.</p></blockquote><p>macOS 下 CMake 可以通过 <code>brew install cmake</code> 安装。</p><h3 id="3-1-CMake-配置"><a href="#3-1-CMake-配置" class="headerlink" title="3.1. CMake 配置"></a>3.1. CMake 配置</h3><p>CMake 使用 CMakeListx.txt 来组织工程，一般来说就是每个文件夹一个都拥有一个 CMakeLists.txt。为了演示 CMake 管理多源文件工程，我们新增一个 <code>src/test.cpp</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build # 编译输出目录</span><br><span class="line">├── libs # 第三方依赖</span><br><span class="line">├── CMakeLists.txt # 工程根 CMakeLists.txt 文件</span><br><span class="line">├── config.h.in # 配置模板，用来生成工程信息 h 文件</span><br><span class="line">├── main.cpp # 入口文件，调用 test.cpp 中定义的函数</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt # 子目录 CMakeLists.txt</span><br><span class="line">    └── test.cpp # 定义一个简单函数的 cpp 文件</span><br></pre></td></tr></table></figure><p>这里只需要关注两个 CMakeLists.txt 文件，首先是根目录的 CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>) <span class="comment"># cmake 版本要求</span></span><br><span class="line"><span class="keyword">project</span>(demo VERSION <span class="number">0.0</span>.<span class="number">1</span>) <span class="comment"># 配置项目名称以及版本号，详细配置可以查阅 CMake 文档</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>) <span class="comment"># 选择 C++ 版本，一般都是 11 及往上</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>) <span class="comment"># 我也忘了具体干啥的了</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>) <span class="comment"># 项目 configure 结束后输出 compile_commands.json 到 build 目录，clang 等一些工具依赖它做智能提示，等会执行编译就能看到了</span></span><br><span class="line"><span class="comment"># 这里就是指定配置模板文件以及对应的输出目录，PROJECT_SOURCE_DIR 是根 CMakeLists.txt 所在目录，PROJECT_BINARY_DIR 是编译输出目录，也即 build（执行cmake 时指定） 目录</span></span><br><span class="line"><span class="keyword">configure_file</span> (</span><br><span class="line">  <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/config.h.in</span><br><span class="line">  <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/config.h</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置去哪些目录下寻找头文件，</span></span><br><span class="line"><span class="comment"># 当项目引入第三方依赖是就可以把第三方依赖的头文件目录加进来</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">    /usr/local/<span class="keyword">include</span></span><br><span class="line">    <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 配置去哪些目录寻找动态/静态库</span></span><br><span class="line"><span class="comment"># 当项目引入第三方依赖是就可以把第三方依赖的库文件目录加进来</span></span><br><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">    /usr/local/lib</span><br><span class="line">    <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 添加一个子目录/工程，注意这里的 src 和下面的 src 不是同一个东西，这里是一个路径，下面是库名称，只不过 库-src 是在 路径-src 里定义，因为没想到好名字就都用 src 了</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个可执行文件的构建目标，这里直接使用项目名称（demo）作为输出文件名称</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"><span class="comment"># 将构建目标与库（静态/动态）进行链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> src)</span><br></pre></td></tr></table></figure><p>再来看 src 目录下的 CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当目录下有多个源文件时，aux_source_directory 可以搜集指定目录下所有 c/cpp 文件，并结果存储在 SRC 中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个静态库的构建目标 src，这就和上面的配置呼应上了。</span></span><br><span class="line"><span class="comment"># add_library 默认是构建静态库，也可以配置成 SHARED</span></span><br><span class="line"><span class="keyword">add_library</span>(src <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><p>简单配置后，就可以执行命令开始构建了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-B 指定输出目录，-C 指定工作目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake . -B build &amp;&amp; make -C build</span></span><br></pre></td></tr></table></figure><p><img src="/img/2021/cmake_run.jpg" alt="cmake run"></p><p>执行完命令后的 build 目录长这样：</p><p><img src="/img/2021/project_after_build.jpg"></p><p><strong>demo</strong> 文件就是可执行文件，<code>config.h</code> 就是模板配置生成的头文件。</p><h3 id="3-2-更加优雅地运行"><a href="#3-2-更加优雅地运行" class="headerlink" title="3.2. 更加优雅地运行"></a>3.2. 更加优雅地运行</h3><p>到目前为止，我们已经用 CMake 将工程组织了起来，但是 run 代码的方式还比较原始，而且也没有办法利用 VSCode 进行代码调试。所以接下来就继续配置，可以通过 F5 一键执行 cmake 并启动调试。</p><p>这里还是修改 <code>launch.json</code> 和 <code>tasks.json</code> ，将构建的操作交给 cmake 执行，首先看 <code>launch.json</code> ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMake - Build and debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/demo&quot;</span><span class="punctuation">,</span> <span class="comment">// 修改 program 为构建后的可执行文件路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: make&quot;</span> <span class="comment">// 修改前置任务为构建任务</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接着修改&#x2F;重写 <code>tasks.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;process&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: cmake debug build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmake&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span> <span class="comment">// -g Generate source-level debug information</span></span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Run cmake debug build&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;process&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: make&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="comment">// &quot;-d&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// make 依赖 cmake 输出</span></span><br><span class="line">                <span class="string">&quot;C/C++: cmake debug build&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Make the target file&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>tasks.json</code> 中的两个 task 对应着 <code>cmake . -B build &amp;&amp; make -C build</code>，那么启动 <code>launch.json</code> 之前就会先执行构建命令，从而做到了一键运行并启动调试。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>到这里，一个满足基本开发需求的 VSCode C++ 环境算是搭好了，对于一个完整的项目，还需要<strong>测试</strong>（<strong>test</strong>） 以及 <strong>发布</strong>（<strong>pack</strong>） ，这俩的配置方式和<strong>构建</strong>（<strong>build</strong>）类似，并且 CMake 也提供了相应的功能，感兴趣可以将环境配置继续完善。</p><p>然后呢打算等有时间了把一些常用工程模板打包成 VSCode 插件，挖个坑。</p><h2 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5. 参考文章"></a>5. 参考文章</h2><p><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C++ Extension</a></p><p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference">c_cpp_properties.json reference</a></p><p><a target="_blank" rel="noopener" href="https://cmake.org/">CMake</a></p><p><a target="_blank" rel="noopener" href="https://kingsamchen.github.io/2019/02/10/use-cmake-and-git-as-your-cpp-dependency-manager/">C++ 工程依赖管理新方向：CMake &amp; Git</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次 Head Buffer Overflow</title>
      <link href="/2021/01/11/fe653e503611.html"/>
      <url>/2021/01/11/fe653e503611.html</url>
      
        <content type="html"><![CDATA[<p>昨晚刷 LeetCode-17 最后提交时，本以为能一遍就 pass，结果直接给报了个 heap buffer overflow：<br><img src="/img/2021/head_buffer_overflow.png" alt="head buffer overflow"></p><p>第一次碰到这种内存错误，信息量比较少，加上本地能正常运行，一时间也不知道问题在哪里。</p><p>下面是提交的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt; mapping = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">letterCombinations</span><span class="params">(<span class="type">const</span> std::string&amp; digits)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;std::string&gt; result;</span><br><span class="line">        std::vector&lt;<span class="type">char</span>&gt; path;</span><br><span class="line">        <span class="built_in">backtrace</span>(digits, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">const</span> std::string&amp; digits, std::vector&lt;<span class="type">char</span>&gt;&amp; path, std::vector&lt;std::string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> index = path.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(path.<span class="built_in">data</span>()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">char</span>&gt;&amp; choices = mapping[digits[index] - <span class="string">&#x27;2&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(choices[i]);</span><br><span class="line">            <span class="built_in">backtrace</span>(digits, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-Address-Sanitizer"><a href="#1-Address-Sanitizer" class="headerlink" title="1. Address Sanitizer"></a>1. Address Sanitizer</h2><p>遇到问题没有思路时的思路就是 Google，因为确实不是什么疑难杂症（鄙人才疏学浅），所以很快也就找到了问题：LeetCode 使用 Address Sanitizer 检测非法内存操作。</p><p>Address Sanitizer 其实是 <a target="_blank" rel="noopener" href="https://github.com/google/sanitizers">sanitizer</a> 项目的下工具之一，它的核心功能就是检测非法内存访问。同一项目下还有其它不同的检测工具：</p><ul><li>MemorySanitizer，检测未初始化内存的使用；</li><li>ThreadSanitizer，检测并发和死锁；</li><li>LeakSanitizer，检测内存泄漏；</li><li>HWASAN，硬件优化的 Address Sanitizer；</li><li>其它工具。</li></ul><p>LLVM 从 3.1 起就已经内置了 ASAN，所以只要在编译时传递 flag 就能开启了，非常方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang++ -fsanitize=address -O1 -fno-omit-frame-pointer -g -o main.out main.cpp</span></span><br></pre></td></tr></table></figure><p><code>-fsanitize=address</code> 告诉编译器开启 ASAN，<code>-O1</code> 保证性能损耗不会太大并且禁用内联，<code>-fno-omit-frame-pointer</code> 在输出错误信息时保留完整的调用栈（LeetCode 上就没有栈信息）。</p><p>ASAN 大致原理是插桩+hook malloc，关于 ASAN 更多详细介绍及配置可以参考 <a target="_blank" rel="noopener" href="https://github.com/google/sanitizers/wiki/AddressSanitizer%E3%80%82">https://github.com/google/sanitizers/wiki/AddressSanitizer。</a></p><h2 id="2-CMake-集成-ASAN"><a href="#2-CMake-集成-ASAN" class="headerlink" title="2. CMake 集成 ASAN"></a>2. CMake 集成 ASAN</h2><p>了解 ASAN 后就是将它集成到工程里并复现开头的错误。</p><p>我的 LeetCode 源码使用 CMake 管理，所以就是配置 CMake，让 CMake 告诉底层 clang++ 开启 ASAN：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fsanitize=address -O1 -fno-omit-frame-pointer&quot;</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>这样就为工程全局开启了 ASAN，如果只想为某个编译 target 开启 ASAN，则可以使用 <code>target_compile_options</code> 。</p><h2 id="3-解决问题"><a href="#3-解决问题" class="headerlink" title="3. 解决问题"></a>3. 解决问题</h2><p>集成 ASAN 后再直接运行，果然就给抛出了异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==30037==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000352 at pc 0x000100d2d634 bp 0x7ffeeef9eb50 sp 0x7ffeeef9e310</span><br><span class="line">READ of size 3 at 0x602000000352 thread T0</span><br><span class="line">    #0 0x100d2d633 in wrap_strlen+0x183 (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x1a633)</span><br><span class="line">    #1 0x100c7ed98 in std::__1::char_traits&lt;char&gt;::length(char const*) __string:253</span><br><span class="line">    #2 0x100c7ed74 in std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::basic_string&lt;std::nullptr_t&gt;(char const*) string:819</span><br><span class="line">    #3 0x100c653f8 in std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::basic_string&lt;std::nullptr_t&gt;(char const*) string:817</span><br><span class="line">    #4 0x100c7da8a in leetcode_0017::Solution::backtrace(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::vector&lt;char, std::__1::allocator&lt;char&gt; &gt;&amp;, std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt; &gt;&amp;) 0017.cpp:42</span><br><span class="line">    #5 0x100c7db38 in leetcode_0017::Solution::backtrace(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::vector&lt;char, std::__1::allocator&lt;char&gt; &gt;&amp;, std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt; &gt;&amp;) 0017.cpp:49</span><br><span class="line">    #6 0x100c7db38 in leetcode_0017::Solution::backtrace(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::vector&lt;char, std::__1::allocator&lt;char&gt; &gt;&amp;, std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt; &gt;&amp;) 0017.cpp:49</span><br><span class="line">    #7 0x100c70406 in leetcode_0017::Solution::letterCombinations(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;) 0017.cpp:35</span><br><span class="line">    #8 0x100c6ff0b in leetcode_0017::main() 0017.cpp:59</span><br><span class="line">    #9 0x100c70b78 in main main.cpp:64</span><br><span class="line">    #10 0x7fff20336620 in start+0x0 (libdyld.dylib:x86_64+0x15620)</span><br><span class="line"></span><br><span class="line">0x602000000352 is located 0 bytes to the right of 2-byte region [0x602000000350,0x602000000352)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #0 0x100d687ed in wrap__Znwm+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x557ed)</span><br><span class="line">    #1 0x100c72b98 in std::__1::__libcpp_allocate(unsigned long, unsigned long) new:253</span><br><span class="line">    #2 0x100c78ed8 in std::__1::allocator&lt;char&gt;::allocate(unsigned long, void const*) memory:1869</span><br><span class="line">    #3 0x100c78db8 in std::__1::allocator_traits&lt;std::__1::allocator&lt;char&gt; &gt;::allocate(std::__1::allocator&lt;char&gt;&amp;, unsigned long) memory:1586</span><br><span class="line">    #4 0x100c7e5ef in std::__1::__split_buffer&lt;char, std::__1::allocator&lt;char&gt;&amp;&gt;::__split_buffer(unsigned long, unsigned long, std::__1::allocator&lt;char&gt;&amp;) __split_buffer:318</span><br><span class="line">    #5 0x100c7e498 in std::__1::__split_buffer&lt;char, std::__1::allocator&lt;char&gt;&amp;&gt;::__split_buffer(unsigned long, unsigned long, std::__1::allocator&lt;char&gt;&amp;) __split_buffer:317</span><br><span class="line">    #6 0x100c7e079 in void std::__1::vector&lt;char, std::__1::allocator&lt;char&gt; &gt;::__push_back_slow_path&lt;char const&amp;&gt;(char const&amp;) vector:1623</span><br><span class="line">    #7 0x100c7dd45 in std::__1::vector&lt;char, std::__1::allocator&lt;char&gt; &gt;::push_back(char const&amp;) vector:1640</span><br><span class="line">    #8 0x100c7db25 in leetcode_0017::Solution::backtrace(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::vector&lt;char, std::__1::allocator&lt;char&gt; &gt;&amp;, std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt; &gt;&amp;) 0017.cpp:48</span><br><span class="line">    #9 0x100c7db38 in leetcode_0017::Solution::backtrace(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::vector&lt;char, std::__1::allocator&lt;char&gt; &gt;&amp;, std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt; &gt;&amp;) 0017.cpp:49</span><br><span class="line">    #10 0x100c70406 in leetcode_0017::Solution::letterCombinations(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;) 0017.cpp:35</span><br><span class="line">    #11 0x100c6ff0b in leetcode_0017::main() 0017.cpp:59</span><br><span class="line">    #12 0x100c70b78 in main main.cpp:64</span><br><span class="line">    #13 0x7fff20336620 in start+0x0 (libdyld.dylib:x86_64+0x15620)</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x1a633) in wrap_strlen+0x183</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x1c0400000010: fa fa 00 04 fa fa 00 00 fa fa 00 06 fa fa fd fd</span><br><span class="line">  0x1c0400000020: fa fa 00 00 fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x1c0400000030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x1c0400000040: fa fa fd fa fa fa 03 fa fa fa 03 fa fa fa 03 fa</span><br><span class="line">  0x1c0400000050: fa fa 03 fa fa fa 03 fa fa fa 04 fa fa fa 03 fa</span><br><span class="line">=&gt;0x1c0400000060: fa fa 04 fa fa fa fd fa fa fa[02]fa fa fa fa fa</span><br><span class="line">  0x1c0400000070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x1c0400000080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x1c0400000090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x1c04000000a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x1c04000000b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07</span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==30037==ABORTING</span><br></pre></td></tr></table></figure><p>根据上面的调用栈（#10~1）异常在调用 <code>result.push_back(std::string(path.data()))</code> 时抛出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: std::vector&lt;char&gt;</span></span><br><span class="line"><span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(path.<span class="built_in">data</span>()));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更准确地讲，异常是在构造 <code>std::string</code> 时抛出。<code>std::string</code> 构造函数接收一个以 <code>\0</code> 结尾 <code>char*</code>，这样它才能确定根据 <code>\0</code> 确定需要拷贝的 <code>char</code> 的数量，但是 <code>std::vector&lt;char&gt;::data</code> 返回的 <code>char*</code> 并不是以 <code>\0</code> 结尾，所以构造器就会（非法）访问到 <code>char*</code> 后面的内存，因为 <code>vector</code> 是在 heap 上动态申请分配内存，所以错误描述就是 <strong>heap-buffer-overflow</strong>。至于为什么本机没有报错，大概是后一字节内存内容恰好是 <code>\0</code> 。</p><p>最后的修复方案就不赘述了，在完成一些优化并提交后，得到了下面的分数😃 ：<br><img src="/img/2021/17score.png" alt="score"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>如果你正在刷 LeetCode，不妨也开启 ASAN ，模拟更真实的 LeetCode 环境。</p><h2 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5. 参考文章"></a>5. 参考文章</h2><p><a target="_blank" rel="noopener" href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangpeterx/article/details/88775434">LeetCode 报错解决</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> AddressSanitizer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新一代图像格式——WebP</title>
      <link href="/2020/11/15/67111d4cc67a.html"/>
      <url>/2020/11/15/67111d4cc67a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近开始写公众号，本地写 Markdown 图片都是用相对路径，复制粘贴到微信公众号编辑器就跪了，手动上传图片的过程中想到了 WebP，就思考是不是可以尝试把图片后缀都统一成 WebP呢？当然现实是公众号不支持上传 WebP 后缀的图片，即使公众号后台会把你上传的 PNG&#x2F;JPEG 转成 WebP 🐶 。</p></blockquote><h2 id="1-了解-WebP"><a href="#1-了解-WebP" class="headerlink" title="1. 了解 WebP"></a>1. 了解 WebP</h2><p>WebP 是 Google 研发的具有先进有损无损压缩算法的图片格式，主要的特点有：高压缩率、支持透明通道、支持动图。据 WebP 官网的描述，在图片质量等同的条件下，WebP 无损压缩后的图片文件大小比对应的 PNG 图片小 26%，有损压缩图片比对应 JPEG 图片小 25～34%。</p><figure class="half">    <img src="/img/audiovisual/lenna.png" alt="Png">    <img src="/img/audiovisual/lenna_webp.webp" alt="WebP"></figure><p>目前主流浏览器，如 Google Chrome、FireFox、Edge 以及 Opera (macOS Big Sur Safari 实测支持 WebP)等，都原生支持 WebP 了。虽然 WebP 是面向 Web 推出的解决方案，但是凭借其优越压缩比，其它平台、工具也逐渐加入了支持 WebP 的队伍。</p><h2 id="2-使用-WebP"><a href="#2-使用-WebP" class="headerlink" title="2. 使用 WebP"></a>2. 使用 WebP</h2><p>虽然主流浏览器原生支持 WebP，但 macOS 直到 Big Sur 才原生支持预览 WebP 图片，所以想要查看 WebP 图片，可能还需要额外安装一些软件才行（VSCode 支持查看 WebP）。</p><p>WebP 包含了一套轻量的编解码库 <code>libwebp</code>，同时提供了开箱即用的命令行工具：</p><ul><li>cwebp，将其它图片格式转成 WebP，不支持 Gif；</li><li>dwebp，将 WebP 格式转成其它图片格式；</li><li>vwebp，预览 WebP 图片，作用不是很大；</li><li>gif2webp，将 Gif 图转成 WebP 格式；</li><li>webpmux，将静态 WebP 图片组合成动态 WebP 图片，或从动态 WebP 中抽帧。</li></ul><p>这些工具的使用可以看官网文档或者doc，这里不赘述。</p><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h3><p>借助这些工具就能完成 WebP 与其它格式之间的相互转换（程序员表示好评），macOS 可以通过 <code>brew install webp</code> 安装，但是 brew 默认的安装脚本禁用了 gif2webp，所以需要修改安装脚本：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行 brew edit webp 打开 webp 的安装脚本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Webp</span> &lt; <span class="title class_ inherited__">Formula</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">install</span></span><br><span class="line">      system <span class="string">&quot;./autogen.sh&quot;</span> <span class="keyword">if</span> build.head?</span><br><span class="line">      system <span class="string">&quot;./configure&quot;</span>, <span class="string">&quot;--prefix=<span class="subst">#&#123;prefix&#125;</span>&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;--disable-dependency-tracking&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;--disable-gl&quot;</span>,</span><br><span class="line">                            <span class="comment"># 删除下面一行</span></span><br><span class="line">                            <span class="string">&quot;--disable-gif&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;--enable-libwebpdecoder&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;--enable-libwebpdemux&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;--enable-libwebpmux&quot;</span></span><br><span class="line">      system <span class="string">&quot;make&quot;</span>, <span class="string">&quot;install&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>修改好脚本后重新安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew reinstall webp</span></span><br></pre></td></tr></table></figure><h3 id="2-2-批量转换"><a href="#2-2-批量转换" class="headerlink" title="2.2. 批量转换"></a>2.2. 批量转换</h3><blockquote><p>这些工具怎么使用可以看 man doc，描述得很清楚了。</p></blockquote><p>为了方便批量转换，定义一个shell函数，指定后缀批量（递归）转换当前目录下的图片：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">webp_cvr</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> suffix=<span class="variable">$&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="variable">$&#123;suffix&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Invlaid suffix: <span class="variable">$&#123;suffix&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> lower_suffix=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;suffix&#125;</span>&quot;</span> | awk <span class="string">&#x27;&#123;print tolower($0)&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> $(find ./ -iname <span class="string">&quot;*.<span class="variable">$&#123;suffix&#125;</span>&quot;</span>); <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$&#123;lower_suffix&#125;</span> = <span class="string">&quot;gif&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            gif2webp -v -q 100 <span class="variable">$&#123;img&#125;</span> -o <span class="variable">$&#123;img%.*&#125;</span>.webp</span><br><span class="line">        <span class="keyword">elif</span> [ <span class="variable">$&#123;lower_suffix&#125;</span> = <span class="string">&quot;png&quot;</span> ] || [ <span class="variable">$&#123;lower_suffix&#125;</span> = <span class="string">&quot;jpg&quot;</span> ] || [ <span class="variable">$&#123;lower_suffix&#125;</span> = <span class="string">&quot;jpeg&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            cwebp -v -progress -q 100 <span class="variable">$&#123;img&#125;</span> -o <span class="variable">$&#123;img%.*&#125;</span>.webp</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;img&#125;</span> not supported&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-参考文档"><a href="#3-参考文档" class="headerlink" title="3. 参考文档"></a>3. 参考文档</h2><p><a target="_blank" rel="noopener" href="https://developers.google.com/speed/webp/">WebP</a></p><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/WebP">WebP Wikipedia</a></p><p><a target="_blank" rel="noopener" href="https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html">探究WebP一些事儿</a></p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音频编码—PCM</title>
      <link href="/2020/11/14/991e072aaa6f.html"/>
      <url>/2020/11/14/991e072aaa6f.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-声音三要素"><a href="#1-声音三要素" class="headerlink" title="1. 声音三要素"></a>1. 声音三要素</h2><p>声音主观感受上主要有响度、音高、音色以及掩蔽效应等特征，其中响度、音高、音色在物理上可以量化成具有振幅、频率、相位的波，故称它们为声音的”三要素”。</p><ol><li>响度。表示声音能量的强弱，振幅越大，能量越大。</li><li>音高。表示人耳对音调高低的主观感受，物理上用频率与之对应，频率越高，音高越高。人耳可以识别的声音频率范围是 20~20kHz。</li><li>音色。从音乐的角度来讲，音色由乐器的材质决定。物理上，音色是是众多相位不同波形叠加产生，其中波形的基频产生的听得最清楚的音称为基音，各谐波(其它相位)微小震动产生的声音称为泛音。</li></ol><h2 id="2-A-x2F-D转换与PCM"><a href="#2-A-x2F-D转换与PCM" class="headerlink" title="2. A&#x2F;D转换与PCM"></a>2. A&#x2F;D转换与PCM</h2><p>要将自然界中的<strong>信号</strong>进行传输，声音转换成<strong>计算机能够识别的形式</strong>，前者称为<strong>模拟信号</strong>，后者称为<strong>数字信号</strong>，模拟信号与数字信号之间的转换过程就叫做**数模转换(A&#x2F;D)**。</p><p>PCM(Pulse Code Modulation) 是数字通信中编码方式的一种，也即计算所能识别的信号形式。PCM 通过对模拟信号进行采样、量化、编码而产生，接收 PCM 信号的端则将编码”还原”成模拟信号。采样过程将连续的信号按照固定时间间隔离散化(声音是一个连续信号)，根据奈奎斯特采样定理，为了保证最终的数字信号能比较完整的还原成模拟信号，采样频率必须是原信号频率的2倍及以上。采样完成了信号在时间纬度上的离散，但仍是模拟信号，因为样值在一定范围内仍然具有无限多取值可能，所以将取值范围按照一定步长划分为有限个取值，这就是量化。将量化后的样值按照一定规则排列就是编码了。</p><blockquote><p>简单来说，A&#x2F;D 转换就是将连续变成离散，将无限变成有限。</p></blockquote><p><img src="/img/2020/pcm_encoded_signal.webp" alt="PCM Encoded Signal"></p><p>在音视频领域，PCM 常用来保存原始音频数据，并且约定 PCM 等价于无损编码。很多高保真的音频也都采用 PCM 保存，缺点就是占用空间会比较多一些。</p><h2 id="3-音频编码"><a href="#3-音频编码" class="headerlink" title="3. 音频编码"></a>3. 音频编码</h2><h3 id="3-1-音频参数"><a href="#3-1-音频参数" class="headerlink" title="3.1. 音频参数"></a>3.1. 音频参数</h3><p>音频数据参数有<strong>采样率</strong>、<strong>采样位数</strong>以及<strong>声道数</strong>。</p><p>采样率指声音信号在 A&#x2F;D 转换过程中单位时间内的采样次数，单位是 Hz; 采样位数是指用多少 bit 数据对声音进行量化，常用的有 8 bit、16bit; 声道数又称音轨，不准确地理解是声源，人听到声音时会对声源进行定位，不同位置的声道数越多，效果就越逼真，常见声道数有:</p><ul><li>单声道，mono。</li><li>双声道，stereo，最常见的类型，包含左声道以及右声道。</li><li>2.1声道，在双声道基础上加入一个低音声道。</li><li>5.1声道，包含一个正面声道、左前方声道、右前方声道、左环绕声道、右环绕声道、一个低音声道，最早应用于早期的电影院。</li><li>7.1声道，在5.1声道的基础上，把左右的环绕声道拆分为左右环绕声道以及左右后置声道，主要应用于BD以及现代的电影院。</li></ul><p>若音频PCM格式描述为 44100kHz 16LE stereo，意思是采样率是 44100Hz，采样位数是 16bit(无符号数)并且单个采样采用小端法存储，stereo 表示双声道。</p><blockquote><p>量化的值可能是整数也可能是浮点数。</p></blockquote><h3 id="3-2-音频PCM存储"><a href="#3-2-音频PCM存储" class="headerlink" title="3.2. 音频PCM存储"></a>3.2. 音频PCM存储</h3><p>如果是单声道音频，那么采样数据按照时间顺序一次存储。如果音频是双声道，则左右声道采样按照时间顺序交错存储。</p><p><img src="/img/2020/pcm_data.webp" alt="PCM Data"></p><p>当使用 ffplay 播放 PCM 数据时，需要指定音频的采样率、采样位宽以及声道数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffplay -autoexit -ar 44100 -channels 2 -f s16le -i raw.pcm</span></span><br></pre></td></tr></table></figure><h3 id="3-3-WAV-格式"><a href="#3-3-WAV-格式" class="headerlink" title="3.3. WAV 格式"></a>3.3. WAV 格式</h3><p>原始PCM数据的一个问题就是每次播放时需要显式指定采样率等参数，比较直接的解决方案就是将这些参数也写入音频文件，让播放器帮我们解析这些参数。WAV 是 Microsoft 和 IBM 为 PC 开发的音频文件格式，它做的事情就是在文件头部写入一些描述信息，用来告诉播放器所需要的参数。</p><p>WAV 采用 RIFF 规范进行数据存储:</p><p><img src="/img/2020/wav_sound_format.webp" alt="WAV format"></p><p>第一列表示对应区块是采用大端法还是小端法进行存储; 第二列是区块在文件中的偏移位置，第四列是每个区块的大小，限定了区块的固定占用空间; 中间第三列就是每个区块的定义，规定了每个区块需要存放什么数据。</p><p>图中每个 Chunk 都有 ChunkID 和 ChunkSize，后面的 Chunk 都是第一个 Chunk 的 SubChunk。</p><p>第一个 ChunkID 内容是 “RIFF”，指明文件存储格式，随后 ChunkSize 内容是剩余文件长度(byte，4+(4+4+SubChunk1Size)+(4+4+SubChunk2Size))。Format 中存储 “WAVE”，表明这个文件存储的是 PCM 数据，确定了 Format 也就决定了如何解析剩余文件内容。</p><p>第二个 Chunk 描述了音频参数。AudioFormat 指明音频数据格式，PCM &#x3D; 1，如果不是 1 就表示音频数据是其它相应的压缩格式(比如 MP3)。BlockAlign &#x3D; NumChannels * BitsPerSample&#x2F;8，每次对音频数据的读写大小必须是 BlockAlign 的整数倍，并且只能从一个完整的 Block 的起始地址开始读写，从其它位置开始读写都是非法的。</p><p>前两个 Chunk 描述了音频数据的基本信息，第三个 Chunk 存储实际音频数据。</p><h3 id="3-4-读写-WAV"><a href="#3-4-读写-WAV" class="headerlink" title="3.4. 读写 WAV"></a>3.4. 读写 WAV</h3><p>下面演示如何将 PCM 存储为 WAV 文件以及如何从 WAV 文件中读取出原始 PCM 数据并打印音频参数。</p><blockquote><p>pcm 文件使用 <code>ffmpeg -i audio.mp3 -f s16le -acodec pcm_s16le out.pcm</code> 从音频文件中提取。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param0 executable program&#x27;s file path</span></span><br><span class="line"><span class="comment"> * @param1 raw pcm data file path</span></span><br><span class="line"><span class="comment"> * @param2 sample rate</span></span><br><span class="line"><span class="comment"> * @param3 sample size in bits</span></span><br><span class="line"><span class="comment"> * @param4 number of channels</span></span><br><span class="line"><span class="comment"> * @param4 output file path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_wav</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string pcm_file = std::<span class="built_in">string</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> sample_rate = std::<span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">int</span> sample_size = std::<span class="built_in">atoi</span>(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="type">int</span> nr_channels = std::<span class="built_in">atoi</span>(argv[<span class="number">4</span>]);</span><br><span class="line">    std::string wav_file = std::<span class="built_in">string</span>(argv[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read/write in binary mode</span></span><br><span class="line">    std::ifstream pcm_st;</span><br><span class="line">    pcm_st.<span class="built_in">exceptions</span>(std::fstream::failbit | std::fstream::badbit);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        pcm_st.<span class="built_in">open</span>(pcm_file, std::ios::in | std::ios::binary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::fstream::failure &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_E</span>(<span class="string">&quot;Failed to open: %s-%d %s&quot;</span>, argv[<span class="number">1</span>], pcm_st.<span class="built_in">fail</span>(), e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ofstream wav_st;</span><br><span class="line">    wav_st.<span class="built_in">exceptions</span>(std::fstream::failbit | std::fstream::badbit);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        wav_st.<span class="built_in">open</span>(wav_file, std::ios::out | std::ios::binary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::fstream::failure &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_E</span>(e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// define Header Chunk</span></span><br><span class="line">    ChunkHeader wav_header&#123;&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(wav_header.ChunkID, <span class="string">&quot;RIFF&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;RIFF&quot;</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(wav_header.Format, <span class="string">&quot;WAVE&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;WAVE&quot;</span>));</span><br><span class="line">    wav_st.<span class="built_in">seekp</span>(<span class="built_in">sizeof</span>(ChunkHeader), std::ios::cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define SubChunk1</span></span><br><span class="line">    ChunkFmt wav_fmt&#123;&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(wav_fmt.ChunkID, <span class="string">&quot;fmt &quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;fmt &quot;</span>));</span><br><span class="line">    wav_fmt.ChunkSize = <span class="built_in">sizeof</span>(wav_fmt) - <span class="number">8</span>;</span><br><span class="line">    wav_fmt.AudioFormat = <span class="number">1</span>;</span><br><span class="line">    wav_fmt.NrChannels = nr_channels;</span><br><span class="line">    wav_fmt.SampleRate = sample_rate;</span><br><span class="line">    wav_fmt.ByteRate = sample_rate * nr_channels * sample_size / <span class="number">8</span>;</span><br><span class="line">    wav_fmt.BlockAlign = nr_channels * sample_size / <span class="number">8</span>;</span><br><span class="line">    wav_fmt.BitsPerSample = sample_size;</span><br><span class="line">    wav_st.<span class="built_in">seekp</span>(<span class="built_in">sizeof</span>(ChunkFmt), std::ios::cur);</span><br><span class="line">    <span class="comment">// define SubChunk2</span></span><br><span class="line">    ChunkData wav_data&#123;&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(wav_data.ChunkID, <span class="string">&quot;data&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">    wav_st.<span class="built_in">seekp</span>(<span class="built_in">sizeof</span>(ChunkData), std::ios::cur);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;Writing pcm data&quot;</span>);</span><br><span class="line">    <span class="type">int</span> total_raw_data_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> readed_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *buffer = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(<span class="built_in">malloc</span>(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            pcm_st.<span class="built_in">read</span>(buffer, <span class="number">1024</span>);</span><br><span class="line">            readed_size = pcm_st.<span class="built_in">gcount</span>();</span><br><span class="line">            total_raw_data_size += readed_size;</span><br><span class="line">            wav_st.<span class="built_in">write</span>(buffer, readed_size);</span><br><span class="line">        &#125; <span class="keyword">while</span> (pcm_st.<span class="built_in">gcount</span>() &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::fstream::failure &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_E</span>(<span class="string">&quot;Oops, some error occured: %s&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wav_header.ChunkSize = <span class="number">4</span> + <span class="built_in">sizeof</span>(ChunkFmt) + <span class="built_in">sizeof</span>(ChunkData) + total_raw_data_size;</span><br><span class="line">    wav_data.ChunkSize = total_raw_data_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// seek at the beggining of the output file</span></span><br><span class="line">    wav_st.<span class="built_in">seekp</span>(<span class="number">0</span>, std::ios::beg);</span><br><span class="line">    <span class="comment">// write the header</span></span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;Writing header chunk&quot;</span>);</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(wav_header.ChunkID), <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">4</span>);</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_header.ChunkSize), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(wav_header.Format), <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;Writing format chunk&quot;</span>);</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(wav_fmt.ChunkID), <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">4</span>);</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.ChunkSize), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.AudioFormat), <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.NrChannels), <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.SampleRate), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.ByteRate), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.BlockAlign), <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.BitsPerSample), <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;Writing data chunk&quot;</span>);</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(wav_data.ChunkID), <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">4</span>);</span><br><span class="line">    wav_st.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_data.ChunkSize), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">    pcm_st.<span class="built_in">close</span>();</span><br><span class="line">    wav_st.<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;completed, %s&quot;</span>, argv[<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param0 executable program&#x27;s file path</span></span><br><span class="line"><span class="comment"> * @param1 wav file path</span></span><br><span class="line"><span class="comment"> * @param2 output file path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_wav</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string wav_file = std::<span class="built_in">string</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    std::string pcm_file = std::<span class="built_in">string</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read/write in binary mode</span></span><br><span class="line">    std::ifstream wav_st;</span><br><span class="line">    wav_st.<span class="built_in">exceptions</span>(std::fstream::failbit | std::fstream::badbit);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        wav_st.<span class="built_in">open</span>(wav_file, std::ios::in | std::ios::binary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::fstream::failure &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_E</span>(e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    std::ofstream pcm_st;</span><br><span class="line">    pcm_st.<span class="built_in">exceptions</span>(std::fstream::failbit | std::fstream::badbit);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        pcm_st.<span class="built_in">open</span>(pcm_file, std::ios::out | std::ios::binary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::fstream::failure &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_E</span>(<span class="string">&quot;Failed to open: %s-%d %s&quot;</span>, argv[<span class="number">1</span>], pcm_st.<span class="built_in">fail</span>(), e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChunkHeader wav_header&#123;&#125;;</span><br><span class="line">    ChunkFmt wav_fmt&#123;&#125;;</span><br><span class="line">    ChunkData wav_data&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read RIFF chunk</span></span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;Reading RIFF chunk&quot;</span>);</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(wav_header.ChunkID), <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">4</span>);</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_header.ChunkSize), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(wav_header.Format), <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">string</span>(wav_header.Format) != <span class="string">&quot;WAVE&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_E</span>(<span class="string">&quot;Invalid format: %s&quot;</span>, wav_header.Format);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// read fmt chunk</span></span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;Reading fmt chunk&quot;</span>);</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(wav_fmt.ChunkID), <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">4</span>);</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.ChunkSize), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.AudioFormat), <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.NrChannels), <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.SampleRate), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.ByteRate), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.BlockAlign), <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_fmt.BitsPerSample), <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read data chunk</span></span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;Reading data chunk&quot;</span>);</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(wav_data.ChunkID), <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">4</span>);</span><br><span class="line">    wav_st.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;wav_data.ChunkSize), <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;Reading pcm data&quot;</span>);</span><br><span class="line">    <span class="type">int</span> total_raw_data_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> readed_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *buffer = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(<span class="built_in">malloc</span>(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            wav_st.<span class="built_in">read</span>(buffer, <span class="number">1024</span>);</span><br><span class="line">            readed_size = wav_st.<span class="built_in">gcount</span>();</span><br><span class="line">            total_raw_data_size += readed_size;</span><br><span class="line">            pcm_st.<span class="built_in">write</span>(buffer, readed_size);</span><br><span class="line">        &#125; <span class="keyword">while</span> (wav_st.<span class="built_in">gcount</span>() &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::fstream::failure &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_E</span>(<span class="string">&quot;Oops, some error occured: %s&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcm_st.<span class="built_in">close</span>();</span><br><span class="line">    wav_st.<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;completed, %s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行执行后可以通过 ffplay 测试音频是否能正常播放:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写 pcm 写入 wav 文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffplay -autoexit -i build/out.wav</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 wav 文件提取 pcm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffplay -autoexit -ar 44100 -channels 2 -f s16le -i build/out.pcm</span></span><br></pre></td></tr></table></figure><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4. 参考文章"></a>4. 参考文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/junllee/article/details/7217435">声音”三要素”</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yongdaimi/p/10722355.html">音频属性相关</a></p><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WAV">WAV</a></p><p><a target="_blank" rel="noopener" href="http://soundfile.sapp.org/doc/WaveFormat/">WAVE PCM soundfile format</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色编码方式——YUV</title>
      <link href="/2020/11/12/f5f90233834e.html"/>
      <url>/2020/11/12/f5f90233834e.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-YUV-简介"><a href="#1-YUV-简介" class="headerlink" title="1. YUV 简介"></a>1. YUV 简介</h2><p>与 RGB 类似，YUV 也是一种非常流行的颜色编码方式。RGB 编码方式诉求人眼对<strong>色彩</strong>的感受，而 YUV 则关注人眼对<strong>亮度</strong>的敏感程度。人眼中除了感受色彩的视锥细胞外还有对亮度(能量)敏感的视杆细胞，在 <a href="./1.%E9%A2%9C%E8%89%B2%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94RGB.md">RGB</a> 中基本没有提到过视杆细胞对大脑成像的影响，但实际上 RGB 三原色分量都各自包含了亮度信息。</p><p>YUV 中 “Y” 表示<strong>亮度(Luminance)<strong>，”U” 和 “V” 则表示</strong>色度</strong>、**浓度(Chrominance、Chroma)**，UV 通常组合起来使用&#x2F;描述，Y 包含了完整图像信息。</p><blockquote><p>在计算机领域中，UV 分量有时也会称作蓝色通道和红色通道，基于此可以分别提取图片中蓝色和红色的物体轮廓</p></blockquote><p>YUV 诞生于黑白电视向彩色电视过渡时期，黑白电视只有灰度&#x2F;亮度(Y)信号，所以对于彩色电视信号，去除<strong>彩色(UV)信号</strong>就能兼容黑白电视。另一方由于人眼对亮度信号更加敏感，可以适当降低 UV 分量采样率以降低信号传输的带宽压力，实际上大多数YUV格式平均像素位数都小于24bit，所以 YUV 比 RGB 更加适合<strong>传输</strong>场景。</p><p>由于历史原因，YUV 实际上是一系列颜色编码(Y’UV，YUV，YCbCr，YPbPr)方式的统称，它们的原理大致相同，具体适用场景有些许差异。讨论这些 YUV族 格式不是这篇文章的重点(没有遇到过需要细分需求)，所以重点会放在 YUV 的采样格式与存储格式上。</p><h2 id="2-YUV-采样格式"><a href="#2-YUV-采样格式" class="headerlink" title="2. YUV 采样格式"></a>2. YUV 采样格式</h2><p>假设 YUV 每个分量使用 8bit 表示，一共24bit，那么一张 1080x1920 分辨率的图像就需要 5.93M 空间(不考虑压缩算法的情况下)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1080 * 1920 * 3 * 8bit = 49,766,400bit = 6,220,800byte = 6,075KB = 5.93M</span><br></pre></td></tr></table></figure><p>上面提到因为人眼对 Y 比对 UV 信号更加敏感，可以在传输场景中对 UV 分量采样(subsample)来降低数据大小。常用的采样格式有 YUV 4:4:4、YUV 4:2:2、YUV 4:2:0。</p><h3 id="2-1-YUV-4-4-4-采样"><a href="#2-1-YUV-4-4-4-采样" class="headerlink" title="2.1. YUV 4:4:4 采样"></a>2.1. YUV 4:4:4 采样</h3><p>4:4:4 表示全采样，每个像素点拥有完整的 YUV 三个分量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YC  YC  YC  YC</span><br><span class="line"></span><br><span class="line">YC  YC  YC  YC</span><br><span class="line"></span><br><span class="line">YC  YC  YC  YC</span><br><span class="line"></span><br><span class="line">YC  YC  YC  YC</span><br></pre></td></tr></table></figure><blockquote><p>上面字符表示4x4的图像，其中 UV 分量用 C 表示，下文同理。</p></blockquote><p>因为是全采样，所以并没有达到节省带宽的作用。</p><h3 id="2-2-YUV-4-2-2-采样"><a href="#2-2-YUV-4-2-2-采样" class="headerlink" title="2.2. YUV 4:2:2 采样"></a>2.2. YUV 4:2:2 采样</h3><p>4:2:2 表示水平2:1采样，垂直全采样，每两个 Y 分量共享一组UV分量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Y C Y  Y C Y</span><br><span class="line"></span><br><span class="line">Y C Y  Y C Y</span><br><span class="line"></span><br><span class="line">Y C Y  Y C Y</span><br><span class="line"></span><br><span class="line">Y C Y  Y C Y</span><br></pre></td></tr></table></figure><p>4:2:2 采样下 UV 分量占用带宽减少了一半，整体数据量也就变成了全采样的 <code>(1 + 0.5 + 0.5)/3 = 2/3</code>。</p><h3 id="2-3-YUV-4-2-0-采样"><a href="#2-3-YUV-4-2-0-采样" class="headerlink" title="2.3. YUV 4:2:0 采样"></a>2.3. YUV 4:2:0 采样</h3><p>4:2:0表示2:1的水平采样，垂直2:1采样，每4个 Y 分量共享一组 UV 分量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Y   Y  Y   Y</span><br><span class="line">  C      C</span><br><span class="line">Y   Y  Y   Y</span><br><span class="line"></span><br><span class="line">Y   Y  Y   Y</span><br><span class="line">  C      C</span><br><span class="line">Y   Y  Y   Y</span><br></pre></td></tr></table></figure><p>4:2:0 采样下 UV 分量占用带宽变成了全采样的 1&#x2F;4，整体数据量也就变成了全采样的 <code>(1 + 1/4 + 1/4)/3 = 1/2</code>，这也是目前比较主流的采样格式。</p><h2 id="3-YUV-存储格式"><a href="#3-YUV-存储格式" class="headerlink" title="3. YUV 存储格式"></a>3. YUV 存储格式</h2><p>采样格式描述了YUV三个分量的比例，存储格式描述了YUV分量的排列方式。</p><p>前面提到了 YUV 分量可以分开存储，目前有三种主流的存储格式：</p><ul><li>packed(打包格式)，YUV 分量连续交叉存储。</li><li>planar(平面格式)，YUV 三个分量分开存储，分为 Y、U、V 三个平面。</li><li>semi-planar(半平面格式)，Y 分量单独存储为一个平面，UV分量连续交叉存储为另一平面。</li></ul><p>根据采用的采样格式与存储格式的不同组合，就有了不同的 YUV 格式：</p><table><thead><tr><th></th><th>4:2:2 采样</th><th>4:2:0 采样</th></tr></thead><tbody><tr><td>packed 存储(1Plane)</td><td>YUYV、UYVY</td><td></td></tr><tr><td>planar 存储(3Plane)</td><td>422P(I422)</td><td>YV12、YU12(I420)</td></tr><tr><td>semi-planar 存储(2Plane)</td><td></td><td>NV12、NV21</td></tr></tbody></table><h3 id="3-1-4-2-2-采样-YUV-格式"><a href="#3-1-4-2-2-采样-YUV-格式" class="headerlink" title="3.1. 4:2:2 采样 YUV 格式"></a>3.1. 4:2:2 采样 YUV 格式</h3><p>4:2:2 采样下两个 Y 分量共享一组 UV 分量。</p><h4 id="3-1-1-YUYV、UYVY"><a href="#3-1-1-YUYV、UYVY" class="headerlink" title="3.1.1. YUYV、UYVY"></a>3.1.1. YUYV、UYVY</h4><p>YUYV、UYVY 采用 packed 存储格式，一帧画面只有一个平面(Plane)。这两种格式的存储方式非常直观，每两个像素占用4bytes。</p><p><strong>YUYV</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt;</span><br><span class="line">YUYV YUYV</span><br><span class="line">YUYV YUYV</span><br><span class="line">YUYV YUYV</span><br><span class="line">YUYV YUYV</span><br></pre></td></tr></table></figure><p><strong>UYVY</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt;</span><br><span class="line">UYVY UYVY</span><br><span class="line">UYVY UYVY</span><br><span class="line">UYVY UYVY</span><br><span class="line">UYVY UYVY</span><br></pre></td></tr></table></figure><h4 id="3-1-2-422P-I422"><a href="#3-1-2-422P-I422" class="headerlink" title="3.1.2. 422P(I422)"></a>3.1.2. 422P(I422)</h4><p>422P 采用 planar 存储格式，YUV 三个分量分开存储，一帧画面有三个平面(Plane)，每两个像素占4bytes。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line"></span><br><span class="line">UUUU</span><br><span class="line">UUUU</span><br><span class="line"></span><br><span class="line">VVVV</span><br><span class="line">VVVV</span><br></pre></td></tr></table></figure><h3 id="3-2-4-2-0-采样-YUV-格式"><a href="#3-2-4-2-0-采样-YUV-格式" class="headerlink" title="3.2. 4:2:0 采样 YUV 格式"></a>3.2. 4:2:0 采样 YUV 格式</h3><p>4:2:0 采样下四个 Y 分量共享一组 UV 分量。</p><h4 id="3-2-1-YV12、YU12-I420"><a href="#3-2-1-YV12、YU12-I420" class="headerlink" title="3.2.1. YV12、YU12(I420)"></a>3.2.1. YV12、YU12(I420)</h4><p>YV12、YU12(I420) 采用 planar 存储格式，YUV 分开存储，一帧画面有三个平面(Plane)，每四个像素占6bytes。两种格式根据UV存储顺序区分。</p><p><strong>YV12</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line"></span><br><span class="line">UUUU</span><br><span class="line"></span><br><span class="line">VVVV</span><br></pre></td></tr></table></figure><p><strong>YU12(I420)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line"></span><br><span class="line">VVVV</span><br><span class="line"></span><br><span class="line">UUUU</span><br></pre></td></tr></table></figure><p>可以看到这两种格式只是 U、V 平面排列先后的区别。</p><h4 id="3-2-2-NV12、NV21"><a href="#3-2-2-NV12、NV21" class="headerlink" title="3.2.2. NV12、NV21"></a>3.2.2. NV12、NV21</h4><p>NV12、NV21 采用 semi-planar 存储格式，Y 分量单独一个平面，UV 分量交叉连续存储为一个平面，每四个像素占6bytes。两种格式按照UV存储顺序区分。</p><p><strong>NV12</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line"></span><br><span class="line">UVUV</span><br><span class="line">UVUV</span><br></pre></td></tr></table></figure><p><strong>NV21</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line">YYYY</span><br><span class="line"></span><br><span class="line">VUVU</span><br><span class="line">VUVU</span><br></pre></td></tr></table></figure><blockquote><p>iOS 平台常用 NV12，Android 平台常用 NV21</p></blockquote><h3 id="3-3-内存对齐"><a href="#3-3-内存对齐" class="headerlink" title="3.3. 内存对齐"></a>3.3. 内存对齐</h3><p>现代计算机基本都搭载 32bit 或 64bit 的 CPU，它们一次处理最少读取 4、8 byte，如果少于这些反而需要做一些额外的寻址操作，影响性能，所以就有了内存对齐。内存对齐会在数据尾部补 0 以凑够 4、8byte，牺牲一部分内存换取性能.</p><p>大多数情况下图像的分辨率(宽、高)都是4的倍数，但是例外的case也不少，所以很多图像处理的框架中都会有内存对齐相关的概念，比如 FFmpeg 解码后的 linesize.</p><p><img src="/img/2020/YUV_stride.webp"></p><h2 id="4-YUV-lt-–-gt-RGB-转换"><a href="#4-YUV-lt-–-gt-RGB-转换" class="headerlink" title="4. YUV&lt;–&gt;RGB 转换"></a>4. YUV&lt;–&gt;RGB 转换</h2><p>因为图形显示时常用 RGB 模型，而 YUV 常用在数据传输场景，所以这两种颜色模型之间经常需要进行转换。不同的标准下的转换公式(formulas)也不太一样，下面是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rec._601">BT.601</a> 标准下的转换公式:</p><br/><p>$$<br>\begin{bmatrix}<br>Y\ U\ V<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>0.299 &amp; 0.587 &amp; 0.114\<br>-0.147 &amp; -0.289 &amp; 0.436\<br>0.615 &amp; -0.515 &amp; -0.100<br>\end{bmatrix}<br>\begin{bmatrix}<br>R\ G\ B<br>\end{bmatrix} \tag{1}<br>$$</p><br/><p>$$<br>\begin{bmatrix}<br>R\ G\ B<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 1.140\<br>1 &amp; -0.395 &amp; -0.581\<br>1 &amp; 2.032 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>Y\ U\ V<br>\end{bmatrix} \tag{2}<br>$$</p><blockquote><p>矩阵运算能够充分利用现代图形硬件(eg. GPU)进行加速，在SIMD架构处理器还没有出现之前，浮点运算开销比 fixed-point 算法慢很多，所以就是有一些使用整数运算代替浮点数运算的加速公式(存在精度损失).</p></blockquote><br/><p><img src="https://i.pcmag.com/imagery/encyclopedia-terms/color-space-conversion-cscnvert.fit_lim.size_800x.gif"></p><h2 id="5-YUV-图像操作–libyuv"><a href="#5-YUV-图像操作–libyuv" class="headerlink" title="5. YUV 图像操作–libyuv"></a>5. YUV 图像操作–libyuv</h2><p>YUV 图像常见的处理有缩放、裁剪、旋转、镜像以及格式转换等，这些操作都可以借助 Google 开源的 <a target="_blank" rel="noopener" href="https://chromium.googlesource.com/libyuv/libyuv/">libyuv</a> 快速实现。</p><h3 id="5-1-libyuv-简介"><a href="#5-1-libyuv-简介" class="headerlink" title="5.1. libyuv 简介"></a>5.1. libyuv 简介</h3><p>libyuv 支持:</p><ul><li>缩放原始 YUV 数据以压缩大小，支持点、双线性以及盒式插值.</li><li>将原始 webcam 格式转化成 YUV.</li><li>将 YUV 转换成 RGB 数据用于渲染或特效处理.</li><li>以90°倍数旋转图像.</li><li>针对x86&#x2F;x64、Arm、Mips 架构处理器指令优化.</li></ul><h3 id="5-2-libyuv-编译"><a href="#5-2-libyuv-编译" class="headerlink" title="5.2. libyuv 编译"></a>5.2. libyuv 编译</h3><p><a target="_blank" rel="noopener" href="https://chromium.googlesource.com/libyuv/libyuv/+/HEAD/docs/getting_started.md">Gettting Started</a> 详细地介绍了如何获取代码并编译，但是都看完还是比较头大，如果想快速编译出动态库使用，可以只看 <a target="_blank" rel="noopener" href="https://chromium.googlesource.com/libyuv/libyuv/+/HEAD/docs/getting_started.md#building-the-library-with-cmake">CMake</a> 部分.</p><blockquote><p>下面的操作都是在 macOS 下完成</p></blockquote><p>首先是 clone 代码到本地，对历史 commit 没兴趣可以指定 <code>--depth=1</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth=1 https://chromium.googlesource.com/libyuv/libyuv</span><br></pre></td></tr></table></figure><p>代码拉下来后就可以开始编译了，cmake 可以通过 <code>brew install cmake</code> 安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> out &amp;&amp; <span class="built_in">cd</span> out</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake 执行完会有一些 Warning，可以直接忽略</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure><p>执行完 make 不出意外的话，会得到下面三个产物:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── [595K]  libyuv.a</span><br><span class="line">├── [449K]  libyuv.dylib</span><br><span class="line">└── [391K]  yuvconvert</span><br></pre></td></tr></table></figure><p>yuvconvert</p><p>但是有一种情况很奇怪，当系统安装了 libjpeg 反而编译不过:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;_jpeg_CreateDecompress&quot;, referenced from:</span><br><span class="line">      libyuv::MJpegDecoder::MJpegDecoder() in mjpeg_decoder.cc.o</span><br><span class="line">  &quot;_jpeg_abort_decompress&quot;, referenced from:</span><br><span class="line">      libyuv::MJpegDecoder::UnloadFrame() in mjpeg_decoder.cc.o</span><br><span class="line">      libyuv::MJpegDecoder::FinishDecode() in mjpeg_decoder.cc.o</span><br><span class="line">  &quot;_jpeg_destroy_decompress&quot;, referenced from:</span><br><span class="line">      libyuv::MJpegDecoder::~MJpegDecoder() in mjpeg_decoder.cc.o</span><br><span class="line">  &quot;_jpeg_read_header&quot;, referenced from:</span><br><span class="line">      libyuv::MJpegDecoder::LoadFrame(unsigned char const*, unsigned long) in mjpeg_decoder.cc.o</span><br><span class="line">  &quot;_jpeg_read_raw_data&quot;, referenced from:</span><br><span class="line">      libyuv::MJpegDecoder::DecodeImcuRow() in mjpeg_decoder.cc.o</span><br><span class="line">  &quot;_jpeg_resync_to_restart&quot;, referenced from:</span><br><span class="line">      libyuv::MJpegDecoder::MJpegDecoder() in mjpeg_decoder.cc.o</span><br><span class="line">  &quot;_jpeg_start_decompress&quot;, referenced from:</span><br><span class="line">      libyuv::MJpegDecoder::StartDecode() in mjpeg_decoder.cc.o</span><br><span class="line">  &quot;_jpeg_std_error&quot;, referenced from:</span><br><span class="line">      libyuv::MJpegDecoder::MJpegDecoder() in mjpeg_decoder.cc.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br><span class="line">make[2]: *** [libyuv.dylib] Error 1</span><br><span class="line">make[1]: *** [CMakeFiles/yuv_shared.dir/all] Error 2</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure><p>这是因为 libyuv 依赖了 libjpeg，但是 CMakeList.txt 里却没有为其配置链接:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">INCLUDE</span> ( FindJPEG )</span><br><span class="line"><span class="keyword">if</span> (JPEG_FOUND)</span><br><span class="line">  <span class="keyword">include_directories</span>( <span class="variable">$&#123;JPEG_INCLUDE_DIR&#125;</span> )</span><br><span class="line">  <span class="keyword">target_link_libraries</span>( yuvconvert <span class="variable">$&#123;JPEG_LIBRARY&#125;</span> )</span><br><span class="line">  <span class="comment"># 加上下面两行就可以了</span></span><br><span class="line">  <span class="keyword">target_link_libraries</span>( yuvconvert <span class="variable">$&#123;JPEG_LIBRARY&#125;</span> )</span><br><span class="line">  <span class="keyword">target_link_libraries</span>( yuvconvert <span class="variable">$&#123;JPEG_LIBRARY&#125;</span> )</span><br><span class="line">  <span class="comment"># HAVE_JPEG 条件编译为真</span></span><br><span class="line">  <span class="keyword">add_definitions</span>( -DHAVE_JPEG )</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><blockquote><p><a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/module/FindJPEG.html">FindJPEG</a> 是 Cmake 内置模块.</p></blockquote><h3 id="5-3-libyuv-使用"><a href="#5-3-libyuv-使用" class="headerlink" title="5.3. libyuv 使用"></a>5.3. libyuv 使用</h3><p><del>留个坑，后面实战了再来补上</del></p><h2 id="6-参考文章"><a href="#6-参考文章" class="headerlink" title="6. 参考文章"></a>6. 参考文章</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/YUV">YUV</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75735751">一文理解YUV</a></p><p><a target="_blank" rel="noopener" href="https://glumes.com/post/ffmpeg/understand-yuv-format/">一文读懂YUV采样与格式</a></p><p><a target="_blank" rel="noopener" href="https://www.pcmag.com/encyclopedia/term/yuvrgb-conversion-formulas">yuvrgb-conversion-formulas</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>颜色编码方式——RGB</title>
      <link href="/2020/11/07/8c04fb45d635.html"/>
      <url>/2020/11/07/8c04fb45d635.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是RGB？"><a href="#1-什么是RGB？" class="headerlink" title="1. 什么是RGB？"></a>1. 什么是RGB？</h2><p>下面摘自 wikipedia 原文：</p><p><strong>三原色光模式（RGB color model）</strong>，又称<strong>RGB颜色模型</strong>或<strong>红绿蓝颜色模型</strong>，是一种<strong>加色模型</strong>，将红、绿、蓝三原色的色光以不同比例相加，以合成产生各种色彩光。</p><p>仔细地拆拆这句话，提出这么些疑问：</p><ul><li>什么是颜色？</li><li>什么是加色模型？</li><li>为什么将RGB定义为三原色？</li></ul><h3 id="1-1-什么是颜色？"><a href="#1-1-什么是颜色？" class="headerlink" title="1.1. 什么是颜色？"></a>1.1. 什么是颜色？</h3><p>这个问题看起有些莫名其妙，颜色不就是颜色么，还能是什么？颜色是生物学上的概念，是眼、脑和生活经验对物理世界的感知特征的描述，并且不同生物在颜色感知上是不一样的。在实际物理世界中，颜色只是人类对电磁波谱中可见光部分（特定波长，约312.30nm至745.40nm）的一个别称。</p><p>根据初中生物所学过的知识，人类眼底视网膜上遍布了许多能够感受光照刺激的<strong>视锥细胞</strong>，一般分为感受黄绿色（565nm）、绿色（535nm）和蓝紫色（420nm）三种细胞。这些细胞不是只接受这三种颜色的刺激，而是接收到这三种颜色对应光谱光照刺激所产生的信号最强烈，也就是说三种视锥细胞对任意可见光谱中的颜色都会产生相应的信号，这些<strong>信号的组合</strong>就是人眼所能分辨的颜色的总和。</p><h3 id="1-2-什么是加色模型？"><a href="#1-2-什么是加色模型？" class="headerlink" title="1.2. 什么是加色模型？"></a>1.2. 什么是加色模型？</h3><p><img src="/img/2020/AdditiveColor.webp" alt="AdditiveColor"></p><p>简单来说，就是通过将不同的颜色混合以产生新的颜色。这里产生新的颜色并不是指混合之后就变成了新的颜色，而是人眼所感受到的颜色。根据上面提到的，人眼所感受的颜色是由三种视锥细胞的不同信号组合产生，比方说，你眼睛所感受到的橙色，可能并不是真的橙色，而是由红色和绿色按照某种比例混合组成的，但是由于眼睛生理原因，我们没法从橙色中分辨出这两种光的颜色。事实上，现实生活中很多光都是都不是物理意义上的单一的纯色光。</p><p>既然有加色模型，那么是不是有<strong>减色模型</strong>呢？但是是肯定的。回想一下小时候玩的橡皮泥，最开始买来都是各种颜色分开的，玩着玩着就给混合到一起去了，随着混入的颜色越来越多，橡皮泥慢慢变成了深灰色，显然和上面的加色模型理论相悖。中学物理中有讲到，物体表面的颜色取决于物体反射了什么颜色（波长，其他波长的电磁波都被吸收了），所以不同颜色橡皮泥混合之后，大部分颜色都被吸收了，只能反射少量的颜色，所以看起来就深灰色（不是黑色）。</p><p><img src="/img/2020/SubtractiveColor.webp" alt="SubtractiveColor"></p><h3 id="1-3-为什么将RGB定义为三原色？"><a href="#1-3-为什么将RGB定义为三原色？" class="headerlink" title="1.3. 为什么将RGB定义为三原色？"></a>1.3. 为什么将RGB定义为三原色？</h3><p>现在我们清楚了人眼是如何感知颜色的，那么为什么选用 RGB 作为三原色呢？</p><p>其实原色的划分还是基于人眼的生理特性，三种视锥细胞都能接受光的刺激，根据受刺激程度最大时的波长可以分为 S（420nm）、M（535nm）、L（565nm）三种视锥细胞。纵然自然界有千万种颜色，但是从光进入人眼到信号传递到大脑，也就只有三种视锥细胞产生的电信号，而这三种电信号不同强度组合便被大脑解读成了不同颜色。</p><p>还有一个有意思的现象是，人眼对这三种电信号的混合信号的感知符合线性规律（格拉斯曼定律），这个也为颜色的线性计算提供了理论基础。到了上世纪20年代，David Wright 和 John Guild 独立地进行了”色匹配实验”，得到了不同光颜色的匹配函数（C &#x3D; Rr + Gg + Bb）。再后来国际照明协会（CIE）根据实验数据及结论定义了 CIE RGB 色彩空间：</p><p><img src="https://pic1.zhimg.com/80/v2-fb79a5877f3e979af5e70ab6257b5eb4_1440w.jpg" alt="CIE RGB"></p><p>上图中彩色凸形区域描述了人眼所能分辨的所有颜色（色域）。在这个凸形中任取两点的颜色进行混合，得到的颜色一定在这两点的连线上（线性关系）；那么同理，任取三点颜色进行混合，结果也一定在三角形内部的某个点上，三个从顶点射出并经过这个结果点点的射线与对边交点到达结果点的距离与三点颜色比例成正比。所以，为了能够尽量全的覆盖人眼所能识别的颜色，使用凸形三个”顶点”的颜色（RGB）作为三原色将是一个最为理想的选择。当然也应该注意到了，通过三个点构造出来的三角形始终无法覆盖全人眼的色域。</p><blockquote><p>这里是从感性角度的不准确描述，更加准确理论基础可以参考References部分🤣</p></blockquote><h3 id="1-4-色域"><a href="#1-4-色域" class="headerlink" title="1.4. 色域"></a>1.4. 色域</h3><p>还有一个非常重要的概念——色域。简单来说，色域就是各种颜色的集合，而人眼所能识别的色域也就是上面的  CIE RGB 色彩空间。但是实际中显示设备都无法完全覆盖人眼的的色域，所以就出现了耳闻能详的sRGB、Adobe RGB 等色域标准，这些色域标准定义了设备如何将<strong>编码表示的RGB</strong>解释成颜色。下面是一些常见的色域标准：</p><p><img src="https://pic3.zhimg.com/80/v2-bc13c6802efc369aa9f51414b87d94f2_720w.png"></p><p>可以很清楚的看到，不同的色域标准所覆盖的色域范围是不一样的，一般来说色域范围越大，就能显示出更加饱满（丰富）的色彩。其中 sRGB 色域是惠普与微软在1996年一起研发用于显示器、打印机以及因特网的标准RGB色域，这种标准得到了W3C、英特尔等厂商的支持，并且许多开源软件以及文件格式也加入到 sRGB 队伍中来，因此可以认为 sRGB 色域能够在现代绝大部分设备上显示（一些高端的摄影设备可能没有支持这一标准）。</p><p>当一个色域范围更大的色域标准（Adobe RGB）显示在支持一个较小色域标准的图形设备上时，就会出现<strong>失真</strong>的情况，比如饱和度高的图片变得比较平淡。</p><h2 id="2-RGB-的计算机表示"><a href="#2-RGB-的计算机表示" class="headerlink" title="2. RGB 的计算机表示"></a>2. RGB 的计算机表示</h2><h3 id="2-1-数值表示"><a href="#2-1-数值表示" class="headerlink" title="2.1. 数值表示"></a>2.1. 数值表示</h3><p>最后也最重要的，计算机怎么表示颜色？因为计算机没法像人那样区分红绿蓝，所以只能通过三个数值来描述颜色及其强弱。常用的数值有浮点数、百分数以及整数：</p><table><thead><tr><th>数值类型</th><th>🌰</th><th>解释</th></tr></thead><tbody><tr><td>浮点数</td><td>(1.0,1.0,1.0)</td><td>每个分量取值 [0.0, 1.0]，最终混合。常用在一些浮点系统中，比如 OpenGL，线性运算也一般使用浮点数格式</td></tr><tr><td>百分数</td><td>(100%,100%,100%)</td><td>类似浮点数表示，只不过替换成了百分比格式</td></tr><tr><td>8bit 整数</td><td>(255,255,255)</td><td>使用 8bit 整数[0, 255] 描述分量强弱，最大是 255，这是计算机中比较常见的表现方式。 除了 8 bit, 还有 12bit、16bit、32bit 的表示。理论上bit位越多（bit 位数也叫色彩深度），能表达的颜色就越细腻，但其实超过 8bit人眼就很难分辨了</td></tr></tbody></table><h3 id="2-2-常见RGB像素格式"><a href="#2-2-常见RGB像素格式" class="headerlink" title="2.2. 常见RGB像素格式"></a>2.2. 常见RGB像素格式</h3><p>下面是一些目前比较常用的 RGB 像素格式，也就是 bit 位进行表示。</p><h4 id="2-2-1-RGB444"><a href="#2-2-1-RGB444" class="headerlink" title="2.2.1. RGB444"></a>2.2.1. RGB444</h4><p>RGB 三个分量每个分量占 4bit，一个像素点占 12 bit。这种格式因为图像质量比较差，目前已经不推荐使用。</p><h4 id="2-2-2-RGB565"><a href="#2-2-2-RGB565" class="headerlink" title="2.2.2. RGB565"></a>2.2.2. RGB565</h4><p>一个像素点用 16bit 表示，其中 R&#x3D;5、G&#x3D;6、B&#x3D;5，G 位数更多是因为人眼对绿色更加敏感。常用一个字表示（short），内存中按照 RGB RGB RGB…排列：<br><img src="/img/2020/RGB_565.webp"></p><p>下面的代码演示了如何获取 RGB565 各个分量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RGB565_MASK_R 0xF800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RGB565_MASK_G 0x07E0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RGB565_MASK_B 0x001F</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ushort color = <span class="number">0xFFFF</span>; <span class="comment">// 65535</span></span><br><span class="line">    <span class="comment">// 获取对应分量</span></span><br><span class="line">    <span class="keyword">auto</span> red = (color &amp; RGB565_MASK_R) &gt;&gt; <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">auto</span> green = (color &amp; RGB565_MASK_G) &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> blue = (color &amp; RGB565_MASK_B);</span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;RGB(%d,%d,%d)&quot;</span>, red, green, blue); <span class="comment">// RGB(31,63,31)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-RGB888"><a href="#2-2-3-RGB888" class="headerlink" title="2.2.3. RGB888"></a>2.2.3. RGB888</h4><p>一个像素点用24bit表示，其中 RGB 三个分量各占 8 bit。内存中按照 BGR BGR BGR…排列：<br><img src="/img/2020/RGB_888.webp"></p><p>下面的代码演示了如何获取 RGB888 各个分量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RGB888_MASK_R 0x000000FF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RGB888_MASK_G 0x0000FF00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RGB888_MASK_B 0x00FF0000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> color = <span class="number">0x00F00FFF</span>; <span class="comment">// 15,732,735</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = (color &amp; RGB888_MASK_R);</span><br><span class="line">    <span class="keyword">auto</span> green = (color &amp; RGB888_MASK_G) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">auto</span> blue = (color &amp; RGB888_MASK_B) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;RGB(%d,%d,%d)&quot;</span>, red, green, blue); <span class="comment">// RGB(255,15,240)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-ARGB8888"><a href="#2-2-4-ARGB8888" class="headerlink" title="2.2.4. ARGB8888"></a>2.2.4. ARGB8888</h4><p>相比 RGB888 增加一个透明度通道，一个像素点用 32bit(uint32_t) 表示，RGBA 各占 8bit。内存中按照 BGRA BGRA BGRA…排列<br><img src="/img/2020/ARGB_8888.webp"></p><p>下面的代码演示了如何获取 ARGB8888 各个分量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARGB8888_MASK_A 0x000000FF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGB8888_MASK_R 0x0000FF00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGB8888_MASK_G 0x00FF0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGB8888_MASK_B 0xFF000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> color = <span class="number">0xF0E0D0C0</span>; <span class="comment">// 4,041,265,344</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> alpha = (color &amp; ARGB8888_MASK_A);</span><br><span class="line">    <span class="keyword">auto</span> red = (color &amp; ARGB8888_MASK_R) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">auto</span> green = (color &amp; ARGB8888_MASK_G) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">auto</span> blue = (color &amp; ARGB8888_MASK_B) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">LOG_I</span>(<span class="string">&quot;RGB(%d,%d,%d,%d)&quot;</span>, alpha, red, green, blue); <span class="comment">// RGB(192,208,224,240)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-PNG图片颜色通道分离"><a href="#2-3-PNG图片颜色通道分离" class="headerlink" title="2.3. PNG图片颜色通道分离"></a>2.3. PNG图片颜色通道分离</h3><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h2><p>RGB 色彩模型的主要应用场景是在电子系统中检测，表示和显示图像，简单来说就是显示设备&#x2F;屏幕。前面提到RGB三原色按比例混合可以产生各种各样的色彩，但实际上这些显示设备显示的彩色并非由加色法产生，RGB三原色子像素按照一定规则排列（并没有重叠），利用大脑强制眼睛失焦而产生感知上的彩色。</p><p>目前市面上主流的手机屏幕材质有 LCD 和 OLED，涉及到一些诸如 IPS、AMOLED等名词，这些都是在 LCD、OLED 基础上的增强。LCD 本身并不发光，所以还需要一块发光背板才能正常工作，这也是为什么LCD的黑色不够深邃的原因；而 OLED 具备自发光特性，能够单独控制每个子像素的亮度，所以理论上更加节省能源并且显示黑色更加纯正。</p><p>关于屏幕的知识可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109841385">知乎</a>上讲解，非常清晰。</p><blockquote><p>了解屏幕像素排列后，才明白为什么新买的显示要通过显示纯红、纯绿、纯蓝检测坏点</p></blockquote><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4. 参考文章"></a>4. 参考文章</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RGB_color_model">RGB_color_model</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82225495">你说的三原色究竟是哪三种颜色？</a></p><p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Grassmann%27s_law_(optics)">格拉斯曼定律</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24214731">色彩空间基础</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84897327">三原色理论与颜色匹配实验</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137639368">色域马蹄图是怎么来的？</a></p><p><a target="_blank" rel="noopener" href="https://www.zhangxiaochun.com/color-space-2/">CIE 色度图与色域</a></p>]]></content>
      
      
      <categories>
          
          <category> Audiovisual </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop 集群配置</title>
      <link href="/2019/01/11/620aacbc2544.html"/>
      <url>/2019/01/11/620aacbc2544.html</url>
      
        <content type="html"><![CDATA[<p>下半学期开了“大数据与云计算”的课程，一次实验课要求配置 Hadoop 分布式集群。配环境这东西真的不好说，运气好一气呵成，运气不好，真的要杠上两三天。所以这篇就给踩的坑做一个笔记。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hadoop 提供 <strong>单机模式</strong> 、<strong>伪分布式模式</strong> 以及 <strong>分布式模式</strong>，因为真正的生产环境都是在真正的分布式环境下，所以这里就选最后一种进行配置。</p><p>为了方便起见，所有都机器都是本地 CentOS 7 的虚拟机，也只配置一个 master 和一个 worker 节点。</p><h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><p>为了方便管理，需要修改一些主机名。<br>修改 <code>/etc/hosts</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 增加下面两行</span><br><span class="line">10.211.55.19    master</span><br><span class="line">10.211.55.23    worker</span><br></pre></td></tr></table></figure><p>master 就是当前正在配置的虚拟机的内网 IP，worker 准备从 master 里 clone 出来，后续需要再进行补充&#x2F;修改，到时就不再赘述了。</p><p>修改 <code>/etc/hostname</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 整个替换文件内容，如果是 worker 就填 worker，这一行也不能要</span><br><span class="line">master</span><br></pre></td></tr></table></figure><h2 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h2><p>Hadoop 是 Java 编写的，所以环境就只用配置 JDK 就好，其它的 CentOS 7 都自带了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install java-<span class="number">1.8</span><span class="number">.0</span>-openjdk-devel</span><br></pre></td></tr></table></figure><p>这里一定要安装带 <code>-devel</code> 后缀的 JDK，不然安装的就是 JRE 了，后续还要使用 JDK 的 JPS 工具查看进程是不是如期启动了。版本就安装 8，更高带版本会因为一些模块移除导致各种问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo export JAVA_HOME=/usr/lib/jvm/jre &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><blockquote><p>用的 zsh，其它的根据自己情况更改</p></blockquote><h2 id="安装-Hadoop"><a href="#安装-Hadoop" class="headerlink" title="安装 Hadoop"></a>安装 Hadoop</h2><p>我们安装最新的 Hadoop 3.1.1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://www-eu.apache.org/dist/hadoop/common/hadoop-3.1.1/hadoop-3.1.1.tar.gz</span><br><span class="line">tar -zxvf hadoop-3.1.1.tar.gz</span><br><span class="line">sudo mv hadoop-3.1.1 /usr/local/hadoop</span><br></pre></td></tr></table></figure><p>然后配置一下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo export HADOOP_HOME=/usr/local/hadoop &gt;&gt; ~/.zshrc</span><br><span class="line">echo export HADOOP_COMMON_HOME=$HADOOP_HOME &gt;&gt; ~/.zshrc</span><br><span class="line">echo export HADOOP_HDFS_HOME=$HADOOP_HOME &gt;&gt; ~/.zshrc</span><br><span class="line">echo export HADOOP_YARN_HOME=$HADOOP_HOME &gt;&gt; ~/.zshrc</span><br><span class="line">echo export HADOOP_MAPRED_HOME=$HADOOP_HOME &gt;&gt; ~/.zshrc</span><br><span class="line">echo export HADOOP_INSTALL=$HADOOP_HOME &gt;&gt; ~/.zshrc</span><br><span class="line">echo export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>HADOOP_HOME 是一定要配，绝大多数博客也都说了，剩下的很少有文章提到，但是启动的时候就会提示没有配置而启动失败。</p><h2 id="配置-Hadoop"><a href="#配置-Hadoop" class="headerlink" title="配置 Hadoop"></a>配置 Hadoop</h2><p><code>etc/hadoop</code> 目录下是 Hadoop 的配置文件，暂时只需要关注 <code>hadoop-env.sh</code>、<code>core-site.xml</code>、<code>hdfs-site.xml</code>、<code>mapred-site.xml</code> 和  <code>yarn-site.xml</code> 这五个文件。</p><blockquote><p>注意现在是在 master 节点上配置</p></blockquote><h3 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a>hadoop-env.sh</h3><p>这个文件是 Hadoop 启动时的环境配置文件，不知道为什么还要把 JAVA_HOME 在这个文件里再写一遍，反正不写会启动失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo export JAVA_HOME=/usr/lib/jvm/jre &gt;&gt; $HADOOP_HOME/etc/hadoop/hadoop-env.sh</span><br></pre></td></tr></table></figure><h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><p>这个文件配置集群全局参数，如 HDFS URL、Hadoop 临时目录等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置 HDFS URL，这里 master 需要在 /etc/hosts 里配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置 Hadoop 临时目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/centos/hadoop<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里配置 WebUI 登陆的用户，当前虚拟机用户名是 centos，用户名就代表了操作权限，默认用户是 read-only 权限 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>centos<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p>这个文件配置 HDFS 参数，namenode、datanode 数据存储位置，文件副本数量等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件副本数量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- namenode 数据存储位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/centos/hadoop/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- datanode 数据存储位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/centos/hadoop/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><p>Mapreduce 配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用的框架，计算任务会由 yarn 提供计算资源解决 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><p>配置 yarn （资源管理）参数，如 ResourceManager、NodeManager 通信端口，WebUI 端口等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置子节点"><a href="#配置子节点" class="headerlink" title="配置子节点"></a>配置子节点</h2><p>到这里主节点就配置完成了，通过 clone 虚拟机完成子节点的创建，然后简单修改 <code>/etc/hosts</code> 文件就可以了。</p><p>然后再修改 <strong>主节点</strong> 上的 <code>$HADOOP_HOME/etc/hadoop/workers</code>，没有就创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop@worker</span><br><span class="line"># 一排一个子节点...</span><br></pre></td></tr></table></figure><p>这里的 <code>Hadoop</code> 是子节点的用户名，<code>worker</code> 之前在 <code>/etc/hosts</code> 里配置了。</p><blockquote><p>网上文章一般都是只填 worker，而不填前面的用户名<br>这是因为一般情况下所有节点都应该配置成一样，比如用户名、目录等，方便管理减少配置成本。但是有时候主节点和子节点的用户名不一样，比如主节点用户名叫 centos，那么在主节点执行 <code>ssh worker</code> 等价于执行 <code>ssh centos@worker</code>。当然为了避免麻烦，使用统一的配置才是正解。</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><strong>第一次启动</strong> 之前在主节点上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HADOOP_HOME/bin/hdfs namenode -format</span></span><br></pre></td></tr></table></figure><p>在 <strong>主节点上</strong> 依次执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 HDFS</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HADOOP_HOME/sbin/start-dfs.sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 yarn</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HADOOP_HOME/sbin/start-yarn.sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 historyserver</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HADOOP_HOME/bin/mapred --daemon start historyserver</span></span><br></pre></td></tr></table></figure><p>判断有没有启动成功可以 <code>jps</code> 查看 Java 进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10848 JobHistoryServer</span><br><span class="line">10289 SecondaryNameNode</span><br><span class="line">10515 ResourceManager</span><br><span class="line">10061 NameNode</span><br><span class="line">10910 Jps</span><br></pre></td></tr></table></figure><p>在 <strong>子节点</strong> 上执行 <code>jps</code> 会看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4626 DataNode</span><br><span class="line">4859 NodeManager</span><br><span class="line">4950 Jps</span><br></pre></td></tr></table></figure><p>如果想关闭的话，在主节点上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HADOOP_HOME/sbin/stop-dfs.sh</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HADOOP_HOME/sbin/stop-yarn.sh</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HADOOP_HOME/bin/mapred --daemon stop historyserver</span></span><br></pre></td></tr></table></figure><h2 id="Web-UI"><a href="#Web-UI" class="headerlink" title="Web UI"></a>Web UI</h2><p>启动完 hadoop 之后，访问 <a href="http://10.211.55.19:9870：">http://10.211.55.19:9870：</a><br><img src="https://i.loli.net/2019/01/24/5c4996d4d71a0.png" alt="NameNode"></p><p>访问 <a href="http://10.211.55.19:8088：">http://10.211.55.19:8088：</a><br><img src="https://i.loli.net/2019/01/24/5c4996d4e313d.png" alt="ResourceManager"></p><p>访问 <a href="http://10.211.55.19:19888：">http://10.211.55.19:19888：</a><br><img src="https://i.loli.net/2019/01/24/5c4996d4daf7d.png" alt="MapReduce JobHistory Server"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a target="_blank" rel="noopener" href="http://hadoop.apache.org/docs/r3.1.1/hadoop-project-dist/hadoop-common/SingleCluster.html">Hadoop r3.1.1 docs</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25472769">集群配置详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git】实用操作</title>
      <link href="/2018/12/16/77d26d45a1ce.html"/>
      <url>/2018/12/16/77d26d45a1ce.html</url>
      
        <content type="html"><![CDATA[<p>平常用 Git 就 add、commit、push，遇到一些少用的就很麻烦，不是查文档就是搜 Google。简单记下，未雨绸缪。</p><span id="more"></span><h2 id="暂存更改"><a href="#暂存更改" class="headerlink" title="暂存更改"></a>暂存更改</h2><p>有时候对工作空间进行了修改，但是又需要 pull 远端更新，强行 pull 会提示失败</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更改压栈</span></span><br><span class="line">git stash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">弹出</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>可以多次 stash <code>git stash list</code> 进行查看</p><h2 id="fetch-指定分支"><a href="#fetch-指定分支" class="headerlink" title="fetch 指定分支"></a>fetch 指定分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin remote-branch:local-branch</span><br></pre></td></tr></table></figure><h2 id="clone-指定-tag"><a href="#clone-指定-tag" class="headerlink" title="clone 指定 tag"></a>clone 指定 tag</h2><p>clone 的时候只想 clone 一个指定版本的提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch &lt;tag&gt; &lt;repo&gt;</span><br></pre></td></tr></table></figure><p>这里 tag 也可以是分支名</p><h2 id="合并代码-rebase"><a href="#合并代码-rebase" class="headerlink" title="合并代码 rebase"></a>合并代码 rebase</h2><p>rebase 和 merge 合并方式有些不同，rebase 会将被合并分支作为基础， commit 记录变为线性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase branch</span><br></pre></td></tr></table></figure><h2 id="回滚单个文件"><a href="#回滚单个文件" class="headerlink" title="回滚单个文件"></a>回滚单个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到指定版本</span></span><br><span class="line">git reset &lt;commit-id&gt; &lt;file&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新工作空间</span></span><br><span class="line">git checkout &lt;file&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交</span></span><br><span class="line">git commit -m &lt;msg&gt;</span><br></pre></td></tr></table></figure><p>对于文件夹也适用</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter】UI 刷新</title>
      <link href="/2018/12/02/88f7bae7638d.html"/>
      <url>/2018/12/02/88f7bae7638d.html</url>
      
        <content type="html"><![CDATA[<p>Flutter 在 Framework 上打设计大量借鉴 React，做到通过声明的方式编写 UI 代码，让开发者围绕 Widget 进行开发。但仅仅这样是不够的，我们知道 Flutter 相比于 React 还多了关于测量、布局以及绘制的逻辑，而这些都是在前端开发中很难触碰到的，既然 Flutter 提供了这样的机会，理解其中的原理就显得尤为必要了。<br>这篇文章主要分析 Flutter UI 更新背后的逻辑。</p><span id="more"></span><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>在 <a target="_blank" rel="noopener" href="https://yahdude.github.io/Blog/post/c988c12393bdb4dc3972fbc32ca87cf6">这篇文章</a> 中分析了 <code>runApp</code> 的启动流程，也知道了这里是触发界面绘制的入口之一。还有一个比较常见的触发界面刷新的入口是 <code>State#setState</code> 方法，这里主要就分析 <code>setState</code> 内部逻辑：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State#setState</span></span><br><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">is</span> Future) &#123;</span><br><span class="line">        <span class="keyword">throw</span> FlutterError(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _element.markNeedsBuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Element#markNeedsBuild</span></span><br><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (dirty)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setState</code> 的工作就是更新状态位，同时向 <code>BuildOwner</code> 说明自己需要被重建。这个 <code>BuildOwner</code> 控制视图树的更新，封装了 diff 算法。</p><h2 id="BuildOwner"><a href="#BuildOwner" class="headerlink" title="BuildOwner"></a>BuildOwner</h2><p><code>setState</code> 在简单状态位后就将剩下的工作交给了 <code>BuildOwner</code>，看下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleBuildFor(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element._inDirtyList) &#123;</span><br><span class="line">        _dirtyElementsNeedsResorting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != <span class="keyword">null</span>) &#123;</span><br><span class="line">        _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">        onBuildScheduled();     <span class="comment">// 重点是这行</span></span><br><span class="line">    &#125;</span><br><span class="line">    _dirtyElements.add(element);</span><br><span class="line">    element._inDirtyList = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里逻辑也非常简单的，将 <code>element</code> 添加到 <code>_dirtyelements</code> 中以等待重建，然后调用 <code>onBuildScheduled</code>，那这个 <code>onBuildScheduled</code> 属性又是在什么时候赋值的呢？<br><code>WidgetsBinding</code> 在初始化时对 <code>BuildOwner#onBuildScheduled</code> 进行了赋值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> WidgetsBinding &#123;</span><br><span class="line"> <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       buildOwner.onBuildScheduled = _handleBuildScheduled;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 所以调用 <code>BuildOwner#onBuildScheduled</code> 实际是调用的 <code>WidgetsBinding#_handleBuildScheduled</code>。接着函数调用往下看：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WidgetsBinding</span></span><br><span class="line"><span class="keyword">void</span> _handleBuildScheduled() &#123;</span><br><span class="line">    ensureVisualUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SchedulerBinding</span></span><br><span class="line"><span class="keyword">void</span> ensureVisualUpdate() &#123;</span><br><span class="line">    <span class="keyword">switch</span> (schedulerPhase) &#123;</span><br><span class="line">        <span class="keyword">case</span> SchedulerPhase.idle:</span><br><span class="line">        <span class="keyword">case</span> SchedulerPhase.postFrameCallbacks:</span><br><span class="line">            scheduleFrame();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> SchedulerPhase.transientCallbacks:</span><br><span class="line">        <span class="keyword">case</span> SchedulerPhase.midFrameMicrotasks:</span><br><span class="line">        <span class="keyword">case</span> SchedulerPhase.persistentCallbacks:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_hasScheduledFrame || !_framesEnabled)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ui.<span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">    _hasScheduledFrame = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终会调用到 <code>ui.window.scheduleFrame</code>，事实上调用流程到这里也就结束，不过最重要的也是这里，看下它的注释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Requests that, at the next appropriate opportunity, the [onBeginFrame]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">and [onDrawFrame] callbacks be invoked.</span></span></span><br><span class="line"><span class="keyword">void</span> scheduleFrame() native <span class="string">&#x27;Window_scheduleFrame&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这是一个 native 方法，大概意思是 <strong>通知引擎</strong> 在合适的时候驱动界面刷新，具体是通过 <code>onBeginFrame</code> 和 <code>onDrawFrame</code> 完成的。</p><blockquote><p>目前 Flutter&#x2F;Dart 在调用 C++ 代码方面还没有官方的文档，但随着迭代后期肯定会有相应的工具出现</p></blockquote><h2 id="SchedulerBinding"><a href="#SchedulerBinding" class="headerlink" title="SchedulerBinding"></a>SchedulerBinding</h2><p>上一节知道了界面的更新最后会通过 <code>ui.window.onBeginFrame</code> 和 <code>ui.window.onDrawFrame</code> 触发，而这两个函数的赋值是在 <code>SchedulerBinding</code> 的初始化函数中完成的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> SchedulerBinding &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ui.<span class="built_in">window</span>.onBeginFrame = _handleBeginFrame;</span><br><span class="line">        ui.<span class="built_in">window</span>.onDrawFrame = _handleDrawFrame;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着往下看会发现最终调用的是 <code>handleBeginFrame</code> 和 <code>handleDrawFrame</code>，这样就又回到了<a target="_blank" rel="noopener" href="https://yahdude.github.io/Blog/post/c988c12393bdb4dc3972fbc32ca87cf6">这篇文章</a>，即会调用 <code>WidgetsBinding#drawFrame</code> 方法</p><blockquote><p>至于为什么是 <code>WidgetsBinding#drawFrame</code> 需要理解 Dart 的 mixin</p></blockquote><h2 id="drawFrame"><a href="#drawFrame" class="headerlink" title="drawFrame"></a>drawFrame</h2><p>先看 <code>WidgetsBinding</code> 中的实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buildOwner.buildScope(renderViewElement);</span><br><span class="line">    <span class="keyword">super</span>.drawFrame();</span><br><span class="line">    buildOwner.finalizeTree();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又回到了 <code>BuildOwner</code>，看看 <code>buildScope</code> 方法里头在更新界面方面所做的工作：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [VoidCallback callback]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span> &amp;&amp; _dirtyElements.isEmpty)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _scheduledFlushDirtyElements = <span class="keyword">true</span>;        <span class="comment">// 表示正在处理 dirty 列表/构建控件</span></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">        _dirtyElements.sort(<span class="built_in">Element</span>._sort);         <span class="comment">// 进行排序，depth 小、dirty 的排在前面</span></span><br><span class="line">        _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">        <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; dirtyCount) &#123;</span><br><span class="line">            _dirtyElements[index].rebuild();        <span class="comment">// 按序重建</span></span><br><span class="line">            index += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 下面是为防止在构建过程中有新的 dirty Element 插入</span></span><br><span class="line">            <span class="keyword">if</span> (dirtyCount &lt; _dirtyElements.length || _dirtyElementsNeedsResorting) &#123;</span><br><span class="line">                _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">                _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">                dirtyCount = _dirtyElements.length;</span><br><span class="line">                <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; _dirtyElements[index - <span class="number">1</span>].dirty) &#123;</span><br><span class="line">                    index -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">Element</span> element <span class="keyword">in</span> _dirtyElements) &#123;</span><br><span class="line">            element._inDirtyList = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _dirtyElements.clear();</span><br><span class="line">        _scheduledFlushDirtyElements = <span class="keyword">false</span>;</span><br><span class="line">        _dirtyElementsNeedsResorting = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析 <code>RendererBinding#drawFrame</code> 之前先分析 <code>BuildOwner#finalizeTree</code> ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> finalizeTree() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lockState(() &#123;</span><br><span class="line">        _inactiveElements._unmountAll(); <span class="comment">// this unregisters the GlobalKeys</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是将 <code>_inactiveElements</code> 进行清理，也就是说使用 <code>GlobalKeys</code> 缓存的控件只能被下一帧使用，然后就会被清理。</p><h3 id="Element-rebuild"><a href="#Element-rebuild" class="headerlink" title="Element#rebuild"></a>Element#rebuild</h3><p>上面如果点进 <code>Element.rebuild</code> 后发现代码实现和重建更新没啥关系，因为能够根据状态重建更新的只能是 <strong>容器组件</strong> 或 <strong>根节点</strong>，根节点的重建更新是由 <code>runApp</code> 触发的，容器组件的更新是由 <code>setState</code> 触发，所以下面看 <code>ComponentElement</code> (它是 <code>StatefulElement</code> 的父类) 中的实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Element#rebuild</span></span><br><span class="line"><span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active || !_dirty)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    performRebuild();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ComponentElement#performRebuild</span></span><br><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Widget built = build();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    _child = updateChild(_child, built, slot);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Element#updateChild</span></span><br><span class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">            deactivateChild(child);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.widget == newWidget) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">                updateSlotForChild(child, newSlot);</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;    <span class="comment">// 对 runtimeType 和 key 进行比较，合理使用 key 也能提高性能（列表）</span></span><br><span class="line">            <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">                updateSlotForChild(child, newSlot);</span><br><span class="line">            child.update(newWidget);</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        deactivateChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inflateWidget(newWidget, newSlot);   <span class="comment">// GlobalKey 的处理在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 大致的更新逻辑就是这样，简单总结下：</p><ol><li>newWidget &#x3D;&#x3D; null，即 widget.build() &#x3D;&#x3D; null 时返回 null；如果 child &#x3D;&#x3D; null 则删除子树；流程结束</li><li>child &#x3D;&#x3D; null（一般是 runApp 触发），递归地重建子树；结束流程</li><li>child !&#x3D; null &amp;&amp; widget 没变化；不做更新；结束流程</li><li>child !&#x3D; null &amp;&amp; widget 发生变化可以更新；结束流程</li><li>child !&#x3D; null &amp;&amp; widget 发生变化不可更新；卸载子树；递归重建子树；结束流程</li></ol><p> <img src="http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuG8pk3BJ53JoKil3CrFIKqiKR6qLyafpSZGLIZ9IynGqAbEBDRaKW02aAZaZCoT5GH6R2YYmUjgxuyNUlK_NJdYsOA8rM3WrBoKp3SRYWl086uRXgFoS50W7GodKQ8Hbc0RebLGMf2eeGar1YAYfnUGf85HbfrP25I44i7lpsUpzpteNAPI3bLdZSWPcW40ah5usJ7gwTzBBzjwdktU11RaSW0GmIW00"></p><!--@startumlstartif (newWidget == null) then (yes)    if (child != null) then (yes)        :卸载子树;    endif    endendifif (child != null) then (yes)    if (newWidget == oldWidget) then (yes)        end    endif    if (newWidget.type != oldWidget.type &&\n newWidget.key != oldWidget.key) then (yes)        :替换 widget;        end    endif    :卸载子树;endif:递归重建;end@enduml--><p>源码中使用表格进行表述：</p><table><thead><tr><th align="center"></th><th align="left"><strong>newWidget &#x3D;&#x3D; null</strong></th><th align="left"><strong>newWidget !&#x3D; null</strong></th></tr></thead><tbody><tr><td align="center"><strong>child &#x3D;&#x3D; null</strong></td><td align="left">Returns null.</td><td align="left">Returns new [Element].</td></tr><tr><td align="center"><strong>child !&#x3D; null</strong></td><td align="left">Old child is removed, returns null.</td><td align="left">Old child updated if possible, returns child or new [Element].</td></tr></tbody></table><h2 id="PipelineOwner"><a href="#PipelineOwner" class="headerlink" title="PipelineOwner"></a>PipelineOwner</h2><p>回到 <code>PipelineOwner#drawFrame</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    pipelineOwner.flushLayout();</span><br><span class="line">    pipelineOwner.flushCompositingBits();</span><br><span class="line">    pipelineOwner.flushPaint();</span><br><span class="line">    renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">    pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就没啥废话好讲了，直接看代码吧！！！</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">    <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">        _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">        <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123; <span class="comment">// 根据 depth 排序</span></span><br><span class="line">            <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">                node._layoutWithoutResize();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RenderObject</span></span><br><span class="line"><span class="keyword">void</span> _layoutWithoutResize() &#123;</span><br><span class="line">    performLayout();    <span class="comment">// 这是个空方法，子类自己实现具体布局逻辑</span></span><br><span class="line">    markNeedsSemanticsUpdate();</span><br><span class="line">    _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">    markNeedsPaint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsPaint)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">        <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">            owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">            owner.requestVisualUpdate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">        <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">        parent.markNeedsPaint();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">            owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个新的概念：<strong>重绘边界</strong> ， <code>flushLayout</code> 会尝试将布局边界添加到重绘列表中，如果没找到就会将根结点加入，也就是说设置布局边界可以避免全量重绘。同理，还有一个 <strong>布局边界</strong>，也能起到减少布局的开销。</p><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p><code>setState</code> 会将 <code>Element</code> 设置位 dirty，然后通知引擎需要重新布局等，之后的操作和启动第一帧上屏就是一样的了。看到这里也能理解为什么第一帧上屏和常规的界面更新会有不一样的地方了，因为常规更新只会触发状态位更新而不会立即更新，直到下一次 VSync 信号到来之时才能开始刷新。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c0fc3cb5188251da07e09b3">https://juejin.im/post/5c0fc3cb5188251da07e09b3</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BuildOwner </tag>
            
            <tag> PipelineOwner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter】runApp 流程</title>
      <link href="/2018/11/30/ca8772f26bcb.html"/>
      <url>/2018/11/30/ca8772f26bcb.html</url>
      
        <content type="html"><![CDATA[<p>不管是使用 Flutter 开发完整应用还是作为区块嵌入某个页面，都需要调用 <code>runApp</code> ，而我们需要做的只是传入一个 Widget 实例，那么 <code>runApp</code> 背后所做的工作就很有趣了，比如触发视图的构建、更新以及绘制等，下面我们就粗略地看一下这个函数到底做了啥。</p><span id="more"></span><h2 id="🧐-runApp-声明"><a href="#🧐-runApp-声明" class="headerlink" title="🧐 runApp 声明"></a>🧐 runApp 声明</h2><p>先看一下 <code>runApp</code> 的函数声明：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">    WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">        ..attachRootWidget(app)</span><br><span class="line">        ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WidgetsFlutterBinding</code> 使用了 <a target="_blank" rel="noopener" href="https://yahdude.github.io/Blog/post/1e4790f7473c20aa35d72cf542d39ab4">mixin</a>，将负责点击事件、绘制的 <strong>XXXBinding</strong> 组合起来，这个类也使用了单例模式，即 <code>ensureInitialized</code>。</p><p>调用 <code>attachRootWidget</code> 将会触发 Widget、Element、RenderObject 的构建<br>调用 <code>scheduleWarmUpFrame</code> 会触发视图的第一帧上屏，同时因为是第一帧，也会伴随着一些初始化操作，所以这个函数相对一般的绘制耗时较长</p><h2 id="🤓-attachRootWidget"><a href="#🤓-attachRootWidget" class="headerlink" title="🤓 attachRootWidget"></a>🤓 attachRootWidget</h2><p>从 <code>runApp</code> 声明了解到 <code>WidgetFlutterBinding</code> 真正启动 Flutter 应用的入口，接着看 <code>attachRootWidget</code> 函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">        container: renderView,</span><br><span class="line">        debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>,</span><br><span class="line">        child: rootWidget</span><br><span class="line">    ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RenderObjectToWidgetAdapter</code> 继承于 <code>RenderObjectWidget</code> ，只是起到一个 <strong>桥接</strong> 的作用，正如它的类名一样，而起到桥接作用的正是 <code>attachToRenderTree</code> 函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [RenderObjectToWidgetElement&lt;T&gt; element]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">        owner.lockState(() &#123;</span><br><span class="line">            element = createElement();</span><br><span class="line">            <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">            element.assignOwner(owner);</span><br><span class="line">        &#125;);</span><br><span class="line">        owner.buildScope(element, () &#123;    <span class="comment">// 刚刚初始化</span></span><br><span class="line">            element.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">        element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用第一次启动时，传入的 <code>element</code> 为 <code>null</code> ，所以这里分析的是第一个分支。首先会创建 <code>RenderObjectToWidgetElement</code> 实例，然后调用 <code>assignOwner</code> 进行赋值（这个 buildOwner 非常重要，整个 Widget 树中的节点都会持有同一个实例），最后会调用 <code>mount</code> 挂载成为 ElementTree 的根结点。</p><p>在看 <code>RenderObjectToWidgetElement#mount</code> 之前，先看下它的继承链：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span></span><br><span class="line">└── RenderObjectElement</span><br><span class="line">    └── RootRenderObjectElement</span><br><span class="line">        └── RenderObjectToWidgetElement</span><br></pre></td></tr></table></figure><p>先看 <code>RenderObjectToWidgetElement.mount</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _rebuild();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _rebuild() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _child = updateChild(_child, widget.child, _rootChildSlot);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">        <span class="keyword">final</span> Widget error = ErrorWidget.builder(details);</span><br><span class="line">        _child = updateChild(<span class="keyword">null</span>, error, _rootChildSlot);  <span class="comment">// 这个就是运行异常时看到的 error 屏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>updateChild</code>方法创建 child，这里会进行一个 <strong>递归调用</strong> 完成整个树构建&#x2F;更新。</p><p>然后是 <code>RootRenderObjectElement.mount</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="comment">// Root elements should never have parents.</span></span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(newSlot == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是做了简单的参数检查。</p><blockquote><p>有些文章把 <code>assert</code>  语句去掉了，其实有一些是不能省略的，使用 <code>assert</code> 做一些工作是为了提升性能，因为在开发阶段完成检查后，生产环境就可以避免这些操作而提高性能了</p></blockquote><p>接着看 <code>RenderObjectElement.mount</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    attachRenderObject(newSlot);    <span class="comment">// 挂载 RenderObject 节点到🌲上</span></span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类类名有 <strong>RenderObject</strong> 字眼，恰好 <code>mount</code> 方法里创建了 <code>RenderObject</code> 实例。</p><p>最后就是 <code>Element</code> 基类了，这个类的 <code>mount</code> 方法很简单，就是针对树这种数据结构完成子节点的挂载。</p><p>所以，<code>attachRootWidget</code> 会完成 Widget、Element、RenderObject 树🌲的创建，这里要注意的是只是完成的和创建，并没有的进行测量、布局等，这些都是在下一个函数调用中进行的。</p><h2 id="😎-scheduleWarmUpFrame"><a href="#😎-scheduleWarmUpFrame" class="headerlink" title="😎 scheduleWarmUpFrame"></a>😎 scheduleWarmUpFrame</h2><p>完成了三颗🌲的构建，接下里的就是的完成 Flutter 的上屏，即绘制、渲染。</p><p>直接看 <code>scheduleWarmFrame</code> 的函数定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleWarmUpFrame() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    handleBeginFrame(<span class="keyword">null</span>);</span><br><span class="line">    handleDrawFrame();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lockEvents(() <span class="keyword">async</span> &#123;   <span class="comment">// 在第一帧渲染完成之前，所有的事件，如点击事件都不会进行分发</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码做了一定程度精简。</p><p>在开始分析这个函数之前，先了解下一些 <strong>Callbacks</strong> ，上面函数声明在 <code>SchedulerBinding</code> 里，这个 mixin 主要负责一些任务调度，这些任务都以 <strong>Callback</strong> 的形式存在，有四种任务类型：</p><ul><li>Transient callbacks： 由 <code>Window.onBeginFrame</code> 触发，目的是同步应用状态和显示，比如动画</li><li>Persistent callbacks： 由 <code>Window.onDrawFrame</code> 触发，更新显示，渲染任务</li><li>Post-frame callbacks： 在 Persistent callbacks 执行完后执行，有且只执行一次</li><li>Non-rendering tasks： 普通任务，它们会在两帧之间按照优先级顺序被执行</li></ul><p>那么 <code>Window.onXXXFrame</code> 又是什么？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> SchedulerBinding&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ui.<span class="built_in">window</span>.onBeginFrame = _handleBeginFrame;</span><br><span class="line">        ui.<span class="built_in">window</span>.onDrawFrame = _handleDrawFrame;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _handleBeginFrame(<span class="built_in">Duration</span> rawTimeStamp) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        handleBeginFrame(rawTimeStamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _handleDrawFrame() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        handleDrawFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是 <code>ScheduleBinding</code> 的方法，知道这些了我们接着前面继续分析：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> handleBeginFrame(<span class="built_in">Duration</span> rawTimeStamp) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt; callbacks = _transientCallbacks;</span><br><span class="line">        _transientCallbacks = &lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt;&#123;&#125;;</span><br><span class="line">        callbacks.forEach((<span class="built_in">int</span> id, _FrameCallbackEntry callbackEntry) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_removedIds.contains(id))</span><br><span class="line">                _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);</span><br><span class="line">        &#125;);</span><br><span class="line">        _removedIds.clear();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> handleDrawFrame() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (FrameCallback callback <span class="keyword">in</span> _persistentCallbacks)</span><br><span class="line">            _invokeFrameCallback(callback, _currentFrameTimeStamp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks = <span class="built_in">List</span>&lt;FrameCallback&gt;.from(_postFrameCallbacks);</span><br><span class="line">        _postFrameCallbacks.clear();</span><br><span class="line">        <span class="keyword">for</span> (FrameCallback callback <span class="keyword">in</span> localPostFrameCallbacks)</span><br><span class="line">            _invokeFrameCallback(callback, _currentFrameTimeStamp);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>scheduleWramUpFrame</code> 最终会执行这些回调，渲染、绘制将由这些回调&#x2F;任务来完成，那么这些回调又是在哪里注册的呢？</p><p>因为负责渲染的回调&#x2F;任务属于 <strong>persistent callback</strong> ，所以可以到 <code>RendererBinding</code> 中找下 <code>addPersistentFrameCallback</code> 的调用，果然在初始化的时候进行了注册：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> RendererBinding <span class="keyword">on</span> BindingBase, SchedulerBinding,... &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        initRenderView();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _handlePersistentFrameCallback(<span class="built_in">Duration</span> timeStamp) &#123;</span><br><span class="line">        drawFrame();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@protected</span></span><br><span class="line">    <span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">        <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>); <span class="comment">// renderView 是整个 RenderObject 树的根节点</span></span><br><span class="line">        pipelineOwner.flushLayout();   <span class="comment">//  布局</span></span><br><span class="line">        pipelineOwner.flushCompositingBits();   <span class="comment">// 更新状态，是否需要重绘等</span></span><br><span class="line">        pipelineOwner.flushPaint(); <span class="comment">// 对需要绘制的节点进行绘制</span></span><br><span class="line">        renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">        pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><p>到这里，从启动到第一帧上屏就算是完了，整个流程非常清晰。在分析的过程中，我们忽略了 <code>BuildOwner</code> 和 <code>PipelineOwner</code> ，这两个类贯穿树的构建和绘制，不过这篇文章对它们进行深入分析并不合适，之后会通过分析界面更新来分析它们的作用。</p><p>还有一点值得提起的是，除了 Widget、Element、RenderObject 树🌲之后，还有一颗 Layer 🌲。Flutter 会根据这颗树构建一个 <code>Scene</code>，最后渲染并上屏。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Dart】什么是 Mixins？</title>
      <link href="/2018/11/17/7622bdf9a5d8.html"/>
      <url>/2018/11/17/7622bdf9a5d8.html</url>
      
        <content type="html"><![CDATA[<p>Dart 中提供 mixin 来完成 <strong>代码的复用</strong>，比如我们可以将某种行为封装成一个 mixin，然后添加到需要该项行为的类中。但是似乎抽象类&#x2F;接口也能完成，它们面向的场景还是有些许差别的。</p><span id="more"></span><p>因为已经有非常棒的文章解释 mixin，这里就偷个懒直接丢原文链接了。</p><p><a target="_blank" rel="noopener" href="https://medium.com/flutter-community/dart-what-are-mixins-3a72344011f3">Dart: What are mixins?</a></p><p>通读这篇文章，理解 mixin 也就没什么困难了。。。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Mixin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter】Widget、Element、RenderObject 理解</title>
      <link href="/2018/11/06/df42019cc465.html"/>
      <url>/2018/11/06/df42019cc465.html</url>
      
        <content type="html"><![CDATA[<p>使用 Flutter 开发时，接触最多的就是 Widget，但是 Widget 并不会最终显示在屏幕上。Flutter 大量借鉴 React ，React 中有 Component、Virtual DOM 和 tag，Flutter 中对应地有 Widget、Element 以及 RenderObject，所以这篇文章就简单理解下这三者在视图渲染中的作用。</p><span id="more"></span><h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>先看看源码注释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Describes the configuration <span class="keyword">for</span> an [<span class="built_in">Element</span>].</span><br><span class="line">Widgets are the central <span class="class"><span class="keyword">class</span> <span class="title">hierarchy</span> <span class="title">in</span> <span class="title">the</span> <span class="title">Flutter</span> <span class="title">framework</span>. <span class="title">A</span> <span class="title">widget</span> <span class="title">is</span> <span class="title">an</span> <span class="title">immutable</span> <span class="title">description</span> <span class="title">of</span> <span class="title">part</span> <span class="title">of</span> <span class="title">a</span> <span class="title">user</span> <span class="title">interface</span>. <span class="title">Widgets</span> <span class="title">can</span> <span class="title">be</span> <span class="title">inflated</span> <span class="title">into</span> <span class="title">elements</span>, <span class="title">which</span> <span class="title">manage</span> <span class="title">the</span> <span class="title">underlying</span> <span class="title">render</span> <span class="title">tree</span>.</span></span><br></pre></td></tr></table></figure><p>大概的意思就是 Widget 只是起到配置的作用的，并且是 imutable 的，所以从 Widget 到屏幕上的像素中间还会经过几次转换。可以把 Widget 当成 Android 开发中的布局文件或 iOS 开发中的 Storyboard。</p><p>我们再看下 Widget 的声明：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Widget(&#123; <span class="keyword">this</span>.key &#125;);</span><br><span class="line">  <span class="keyword">final</span> Key key;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">Element</span> createElement();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉注释，核心代码十行不到。Widget 只是配置，在真正渲染界面的时候会转换成 Element，也即 <code>createElement</code> 方法；同时一个 Widget 可以在 Widget 树中多次出现，那么相应的，<code>createElement</code> 也会被调用多次。</p><h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><p>再看看 Widget 的派生类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget</span><br><span class="line">    ├── ProxyWidget</span><br><span class="line">    ├── StatelessWidget</span><br><span class="line">    ├── StatefulWidget</span><br><span class="line">    └── RenderObjectWidget</span><br></pre></td></tr></table></figure><p><strong>ProxyWidget</strong><br>起组装作用。<br>如类名一样，这个类使用了代理模式，它不会自己构建 Widget ，而是直接返回子 Widget 。</p><p><strong>StatelessWidget</strong><br>起组装作用。<br>这个 Widget 不需要处理内部数据&#x2F;状态，所以当配置相同时，会有相同构建产物。</p><p><strong>StatefulWidget</strong><br>起组装作用。<br>当 Widget 需要管理内部数据&#x2F;状态时，就使用这个。即使配置相同，它当构建产物也可能因为内部数据&#x2F;状态不同而不同。</p><p><strong>RenderObjectWidget</strong><br>Widget 只是配置，所以有些 Widget ，比如 ProxyWidget ，和视图基本没有关系，也即和视图显示相关的 Widget 叫做 RenderObjectWidget。</p><p>同时这个类多了一个 <code>RenderObject createRenderObject(BuildContext context)</code> 方法，预示从这个类开始和视图显示有点关系了。</p><h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">An instantiation of a [Widget] at a particular location <span class="keyword">in</span> the tree.</span><br><span class="line"></span><br><span class="line">Widgets describe how to configure a subtree but the same widget can be used to configure multiple subtrees simultaneously because widgets are immutable. An [<span class="built_in">Element</span>] represents the use of a widget to configure a specific location <span class="keyword">in</span> the tree. Over time, the widget associated <span class="keyword">with</span> a given element can change, <span class="keyword">for</span> example, <span class="keyword">if</span> the parent widget rebuilds and creates a <span class="keyword">new</span> widget <span class="keyword">for</span> <span class="keyword">this</span> location.</span><br></pre></td></tr></table></figure><p>大概意思是：Element 是 Widget 在视图中的体现，同时 Element 也管理着视图树的构建、更新等。Widget 是 immutable，而 Element 是 mutable，当 Widget 配置有变化时，Element Tree 会采用一种 <strong>diff 算法</strong> 进行增量更新而不是整个重建。</p><p>再看看它的派生类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span></span><br><span class="line">    ├── ComponentElement</span><br><span class="line">    │   ├── ProxyElement</span><br><span class="line">    │   ├── StatelessElement</span><br><span class="line">    │   └── StatefulElement</span><br><span class="line">    └── RenderObjectElement</span><br></pre></td></tr></table></figure><p>这里和之前的 Widget 是一一对应的，并且这里出现了 <strong>component</strong> 字眼，清楚这个继承关系能够加深 Flutter Framework 层设计的理解。</p><h2 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h2><p>还是先看源码注释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">An object <span class="keyword">in</span> the render tree.</span><br><span class="line"></span><br><span class="line">The [RenderObject] <span class="class"><span class="keyword">class</span> <span class="title">hierarchy</span> <span class="title">is</span> <span class="title">the</span> <span class="title">core</span> <span class="title">of</span> <span class="title">the</span> <span class="title">rendering</span> <span class="title">library</span>&#x27;<span class="title">s</span> <span class="title">reason</span> <span class="title">for</span> <span class="title">being</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">[<span class="title">RenderObject</span>]<span class="title">s</span> <span class="title">have</span> <span class="title">a</span> [<span class="title">parent</span>], <span class="title">and</span> <span class="title">have</span> <span class="title">a</span> <span class="title">slot</span> <span class="title">called</span> [<span class="title">parentData</span>] <span class="title">in</span> <span class="title">which</span> <span class="title">the</span> <span class="title">parent</span> [<span class="title">RenderObject</span>] <span class="title">can</span> <span class="title">store</span> <span class="title">child</span>-<span class="title">specific</span> <span class="title">data</span>, <span class="title">for</span> <span class="title">example</span>,<span class="title">the</span> <span class="title">child</span> <span class="title">position</span>. <span class="title">The</span> [<span class="title">RenderObject</span>] <span class="title">class</span> <span class="title">also</span> <span class="keyword">implements</span> <span class="title">the</span> <span class="title">basic</span> <span class="title">layout</span> <span class="title">and</span> <span class="title">paint</span> <span class="title">protocols</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">The</span> [<span class="title">RenderObject</span>] <span class="title">class</span>, <span class="title">however</span>, <span class="title">does</span> <span class="title">not</span> <span class="title">define</span> <span class="title">a</span> <span class="title">child</span> <span class="title">model</span>. <span class="title">It</span> <span class="title">also</span> <span class="title">doesn</span>&#x27;<span class="title">t</span> <span class="title">define</span> <span class="title">a</span> <span class="title">coordinate</span> <span class="title">system</span> <span class="title">or</span> <span class="title">a</span> <span class="title">specific</span> <span class="title">layout</span> <span class="title">protocol</span>.</span></span><br></pre></td></tr></table></figure><p>RenderObject 就是负责最后的视图渲染了，视图的测量、布局和绘制都是由它来完成的。不过 RenderObject 本身只是定义了标准，具体的由子类实现，比如一般情况下有线性布局、Flex 布局等，这些都是由 RenderObject 的派生类来实现的。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这里简单总结下，Flutter 的视图体系中由三棵树，Widget Tree、Element Tree 以及 RenderObject Tree，Widget Tree 可以产生 Element Tree，并且节点是一一对应的，Element Tree 调用 Widget Tree 创建 RenderObject Tree，但并不是每个 Widget、Element 节点都会有一个 RenderObject 节点与之对应。后续视图的状态、更新等都是由 Element Tree 来进行管控的，而视图显示到屏幕上则是由 RenderObject Tree 负责。</p><p>&gt; Flutter 只是一个跨平台 UI 框架，很多系统相关的东西还是由平台提供，所以 Framework 层非常的薄，只有一个加上注释才 4000+ 行的文件</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Widget </tag>
            
            <tag> Element </tag>
            
            <tag> RenderObject </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter】BLoC——Flutter 中的 MVP</title>
      <link href="/2018/10/31/8cdc42df8a16.html"/>
      <url>/2018/10/31/8cdc42df8a16.html</url>
      
        <content type="html"><![CDATA[<p>写过 Android 的应该都会比较熟悉 MVP 模式，在 Flutter 框架下有着相似的 BLoC（Business Logic Component） 模式，不准确地说，BLoC 就是 MVP 在 Flutter 中的变种。</p><span id="more"></span><h2 id="StatelessWidget-vs-StatefulWidget"><a href="#StatelessWidget-vs-StatefulWidget" class="headerlink" title="StatelessWidget vs StatefulWidget"></a>StatelessWidget vs StatefulWidget</h2><p>在正式开始讲 BLoC 前，先在此回顾下 <a target="_blank" rel="noopener" href="https://flutter.io/tutorials/interactive/#stateful-stateless">Widget</a>。</p><p>Widget 在 Flutter 整个绘制过程中，只充当配置的角色，基本不会涉及到的绘制相关的 API，所以在应用运行过程中时刻有大量的 Widget 产生并销毁。但是很多情况下，我们并不想 Widget 的某些状态&#x2F;数据也一并销毁，比如输入框中已经输入的文本，这时候就有了 Widget 的两个子类——StatelessWidget 和 StatefulWidget。</p><p>所以如果我们想要保存一些状态或者实例变量的话，就需要使用 StatefulWidget。</p><h2 id="Stream-amp-Sink"><a href="#Stream-amp-Sink" class="headerlink" title="Stream &amp; Sink"></a>Stream &amp; Sink</h2><p>在 <a target="_blank" rel="noopener" href="https://yahdude.github.io/Blog/post/c773f50199233831a2379fde98a7b3eb/">这篇文章</a> 中已经学习了如何通过 <code>async*</code> 和 <code>yield</code> 来创建一个 Stream，这种方式我们只能对 Stream  下游进行监听，也即上游数据源已经确定了，但是在实际应用中，上游数据应该可以来自程序的不同部分。</p><p>Dart 提供了 <code>StreamController&lt;T&gt;</code> 这个模板类来帮助开发者创建 Stream 同时向里头添加数据的能力，可以简单理解为：</p><p><img src="https://i.loli.net/2018/11/07/5be2945f8ffa3.png"></p><p>关于它的一些 API 就不多细说了，官方文档里讲得已经非常清楚。</p><h2 id="BLoC"><a href="#BLoC" class="headerlink" title="BLoC"></a>BLoC</h2><p>BLoC 的目的也是将视图和逻辑进行分离，让视图层专注于数据的展示，逻辑层管理状态并处理业务逻辑，这和 MVP 一毛一样。</p><p>这里以 Flutter 新建工程为例进行 BLoC 的讲解，先看默认实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;You have pushed the button this many times:&#x27;</span>),</span><br><span class="line">            Text(<span class="string">&#x27;<span class="subst">$_counter</span>&#x27;</span>),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示当前 FAB 点击次数，FAB 点击后会触发 <code>_incrementCounter</code> 进一步调用 <code>setState</code> 更新 UI，逻辑比较简单。</p><p>再看看使用 BLoC 后的代码实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  _HomePageBLoC _bloc;</span><br><span class="line">  _HomePageState() : _bloc = <span class="keyword">new</span> _HomePageBLoC();</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;You have pushed the button this many times:&#x27;</span>),</span><br><span class="line">            <span class="keyword">new</span> StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">              initialData: <span class="number">0</span>,</span><br><span class="line">              stream: _bloc.count,</span><br><span class="line">              builder: (context, snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> Text(<span class="string">&#x27;<span class="subst">$&#123;snapshot.data&#125;</span>&#x27;</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _bloc.incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageBLoC</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _countController = <span class="keyword">new</span> StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> count =&gt; _countController.stream;</span><br><span class="line">  <span class="keyword">void</span> incrementCounter() &#123;</span><br><span class="line">    _countController.sink.add(++_count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次添加了 <code>_HomePageBLoC</code> 作为逻辑层，实现中使用 <code>StreamController&lt;int&gt;</code> 来管理点击次数。视图层中，我们需要监听逻辑层中的数据并更新 UI，不过 Flutter 给我们提供了 <code>StreamBuilder&lt;T&gt;</code> 来简化操作。</p><p>代码已经非常简单了，就不在赘述。不过要注意这里使用了 <code>StatefulWidget</code> ， 这是为了在 UI 重建的时候 bloc 实例不会丢失。</p><h2 id="Scoped-Model"><a href="#Scoped-Model" class="headerlink" title="Scoped Model"></a>Scoped Model</h2><p>有时候可能会有多个页面共享数据，Flutter 提供 <a target="_blank" rel="noopener" href="https://docs.flutter.io/flutter/widgets/InheritedWidget-class.html"><code>InheritedWidget</code></a> 帮助我们实现这一目的。InheritedWidget 可以将状态&#x2F;数据向它的子树，当 InheritedWidget 的状态&#x2F;数据发生变化，<strong>依赖</strong>了这个 InheritedWidget 的子树会进行重建。</p><p>我们对默认的 Flutter 初始工程进行改造，让两个页面都能显示点击次数，下面看下代码实现：</p><h3 id="InhertiedWidget-实现"><a href="#InhertiedWidget-实现" class="headerlink" title="InhertiedWidget 实现"></a>InhertiedWidget 实现</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterBLoC</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 因为有多个界面对 Stream 进行监听，所以需要使用多播流</span></span><br><span class="line">  <span class="keyword">var</span> _countController = <span class="keyword">new</span> StreamController&lt;<span class="built_in">int</span>&gt;.broadcast();</span><br><span class="line"></span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> count =&gt; _countController.stream;</span><br><span class="line">  <span class="comment">// 第二个界面监听 Stream 时，Stream 里头是没有数据的，但是实际上点击次数是有的，所以需要提供一个方法来获取最近的一次数据</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> lastCount =&gt; _count;</span><br><span class="line">  <span class="keyword">void</span> incrementCounter() &#123;</span><br><span class="line">    _countController.sink.add(++_count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterHolder</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要向下传递的状态/数据</span></span><br><span class="line">  <span class="keyword">final</span> CounterBLoC bloc;</span><br><span class="line"></span><br><span class="line">  CounterHolder(&#123;<span class="keyword">this</span>.bloc, Key key, Widget child&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line">  <span class="comment">// 如果返回值为 true，则通知子树进行重建；返回 false 则不会重建</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(CounterHolder oldWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.bloc != <span class="keyword">this</span>.bloc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个方法有两点作用：</span></span><br><span class="line">  <span class="comment">// 1、简化获取 CounterHolder 的方式</span></span><br><span class="line">  <span class="comment">// 2、做更加精细的控制，比如异常等</span></span><br><span class="line">  <span class="comment">// 在实践中，更推荐的方式是通过这个方法将数据暴漏出去，在这个例子中就是 CounterBLoC 实例。Flutter 中已有的例子有 Theme，Theme.of(ctx) 的返回值是 ThemeData</span></span><br><span class="line">  <span class="keyword">static</span> CounterHolder of(BuildContext ctx) &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.inheritFromWidgetOfExactType(CounterHolder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的地方都在代码中注释了。</p><h3 id="第一个页面实现"><a href="#第一个页面实现" class="headerlink" title="第一个页面实现"></a>第一个页面实现</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 向上查询 CounterHolder 然后拿到 bloc 实例，此时 HomePage 就显式依赖了 CounterHolder</span></span><br><span class="line">    <span class="keyword">var</span> bloc = CounterHolder.of(context).bloc;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      body: <span class="keyword">new</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;You have pushed the button this many times:&#x27;</span>),</span><br><span class="line">            <span class="keyword">new</span> StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">              initialData: bloc.lastCount,</span><br><span class="line">              stream: bloc.count,</span><br><span class="line">              builder: (context, snapshot) =&gt; <span class="keyword">new</span> Text(<span class="string">&#x27;<span class="subst">$&#123;snapshot.data&#125;</span>&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> FlatButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="comment">// 跳转到第二个页面</span></span><br><span class="line">                  Navigator.of(context)</span><br><span class="line">                      .push(<span class="keyword">new</span> MaterialPageRoute(builder: (ctx) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SecondPage();</span><br><span class="line">                  &#125;));</span><br><span class="line">                &#125;,</span><br><span class="line">                child: <span class="keyword">new</span> Text(<span class="string">&#x27;Go second&#x27;</span>))</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: bloc.incrementCounter, <span class="comment">// 点击次数增加</span></span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二个页面实现"><a href="#第二个页面实现" class="headerlink" title="第二个页面实现"></a>第二个页面实现</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">SecondPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 向上查询 CounterHolder 然后拿到 bloc 实例，此时 HomePage 就显式依赖了 CounterHolder</span></span><br><span class="line">    <span class="keyword">var</span> bloc = CounterHolder.of(context).bloc;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      body: <span class="keyword">new</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          initialData: bloc.lastCount,  <span class="comment">// 拿到最近一次数据</span></span><br><span class="line">          stream: bloc.count,</span><br><span class="line">          builder: (ctx, snapshot) =&gt; <span class="keyword">new</span> Text(<span class="string">&#x27;<span class="subst">$&#123;snapshot.data&#125;</span>&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        onPressed: bloc.incrementCounter, <span class="comment">// 点击次数增加</span></span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-CounterHolder-包裹"><a href="#使用-CounterHolder-包裹" class="headerlink" title="使用 CounterHolder 包裹"></a>使用 CounterHolder 包裹</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CounterHolder(</span><br><span class="line">        bloc: <span class="keyword">new</span> CounterBLoC(),</span><br><span class="line">        child: <span class="keyword">new</span> MaterialApp(</span><br><span class="line">          title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">          theme: ThemeData(</span><br><span class="line">            primarySwatch: Colors.blue,</span><br><span class="line">          ),</span><br><span class="line">          home: HomePage(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里整个将 MaterialApp 包裹住，那么 CounterHolder 可以向应用里任何地方传递数据。</p><h3 id="从-InheritedWidget-源码"><a href="#从-InheritedWidget-源码" class="headerlink" title="从 InheritedWidget 源码"></a>从 InheritedWidget 源码</h3><p>要理解 InheredWidget 的实现原理得先理解 Flutter Framework 层的中 Widget、Element 和 RenderObject 的联系与区别，如果不知道可以先看看<a target="_blank" rel="noopener" href="https://yahdude.github.io/Blog/post/964b4fb995963e7c4ea05b6fee8e0627">这篇文章</a>。<br>先看看 InhertiedWidget 源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritedWidget</span> <span class="keyword">extends</span> <span class="title">ProxyWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> InheritedWidget(&#123; Key key, Widget child &#125;)</span><br><span class="line">    : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line">  <span class="comment">// 划重点</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  InheritedElement createElement() =&gt; InheritedElement(<span class="keyword">this</span>);</span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(<span class="keyword">covariant</span> InheritedWidget oldWidget);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ProxyWidget(&#123; Key key, <span class="meta">@required</span> <span class="keyword">this</span>.child &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码唯一有用的就是注释的那个函数，我们知道 Widget 在 Flutter 只是充当着一个配置的角色，最后会 Widget 会转化成 Element，同时 Element 会持 Widget 实例。但是知道这个事实似乎还是没什么用，我们暂且将目光先转向 BuildContext，也就是我们调用 <code>inheritFromWidgetOfExactType</code> 方法的对象。BuildContext 是一个抽象类&#x2F;接口，但巧的是 Element 实现了这个接口，所以看代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">InheritedWidget inheritFromWidgetOfExactType(<span class="built_in">Type</span> targetType, &#123; <span class="built_in">Object</span> aspect &#125;) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">  <span class="keyword">final</span> InheritedElement ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets[targetType];</span><br><span class="line">  <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(ancestor <span class="keyword">is</span> InheritedElement);</span><br><span class="line">    <span class="keyword">return</span> inheritFromElement(ancestor, aspect: aspect);</span><br><span class="line">  &#125;</span><br><span class="line">  _hadUnsatisfiedDependencies = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">InheritedWidget inheritFromElement(InheritedElement ancestor, &#123; <span class="built_in">Object</span> aspect &#125;) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(ancestor != <span class="keyword">null</span>);</span><br><span class="line">  _dependencies ??= HashSet&lt;InheritedElement&gt;();</span><br><span class="line">  _dependencies.add(ancestor);</span><br><span class="line">  ancestor.updateDependencies(<span class="keyword">this</span>, aspect);</span><br><span class="line">  <span class="keyword">return</span> ancestor.widget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看到 <code>_inheritedWidgets</code> 这个成员变量，它的类型是 <code>Map&lt;Type, InheritedElement&gt;</code>，<code>Element</code> 对它的赋值操作在 <code>_updateInheritance</code> 方法里：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_active);</span><br><span class="line">  _inheritedWidgets = _parent?._inheritedWidgets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接拿来主义，<code>InheritedElement</code> 对这个方法进行了重写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_active);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt; incomingWidgets = _parent?._inheritedWidgets;</span><br><span class="line">  <span class="keyword">if</span> (incomingWidgets != <span class="keyword">null</span>)</span><br><span class="line">    _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;.from(incomingWidgets);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;();</span><br><span class="line">  _inheritedWidgets[widget.runtimeType] = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到重点了，这里的 <code>_inheritedWidgets</code> 除了从父节点取值外，还把自己放进去了。所以子节点访问父节点并不是往上递归，而是直接保存下来，空间换时间。<br>还能得到一个结论：<code>BuildContext#inheritFromWidgetOfExactType</code> 只能访问最近的一个目标节点，因为 <code>_inheritedWidgets</code> 是一个字典。<br>子节点访问父节点的原理就清楚了，还有一个问题就是如何做到通知子节点重建？<br>注意最开始 <code>Element#inheritFromElement</code> 方法的这行代码： <code>ancestor.updateDependencies(this, aspect)</code>，这个时候已经知道了 <code>ancestor</code> 的类型是 <code>InheritedElement</code> ，那么看代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> updateDependencies(<span class="built_in">Element</span> dependent, <span class="built_in">Object</span> aspect) &#123;</span><br><span class="line">  setDependencies(dependent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> setDependencies(<span class="built_in">Element</span> dependent, <span class="built_in">Object</span> value) &#123;</span><br><span class="line">  _dependents[dependent] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InheritedElement</code> 把依赖它的节点给保存下来了，即简单的监听者模式，所以在后续状态&#x2F;数据更新的时候就遍历 <code>_dependents</code> 进行通知。</p><h2 id="关于-Redux"><a href="#关于-Redux" class="headerlink" title="关于 Redux"></a>关于 Redux</h2><p>因为 Flutter 从 React 中借鉴了非常多，所以 React 中 redux 在 Flutter 中也有相应的实现，不过使用上会比 BLoC 繁琐一些，相比之下也不够直观。所以在非必要的情况下，首选 BLoC 吧。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://medium.com/flutter-io/build-reactive-mobile-apps-in-flutter-companion-article-13950959e381">build reactive mobile apps in flutter</a></p><p><a target="_blank" rel="noopener" href="https://www.dartlang.org/articles/libraries/creating-streams#using-a-streamcontroller">using a streamcontroller</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[概念理解] 并行VS并发、同步VS异步、阻塞VS非阻塞</title>
      <link href="/2018/09/30/ee44cdfa24d0.html"/>
      <url>/2018/09/30/ee44cdfa24d0.html</url>
      
        <content type="html"><![CDATA[<p>之前老是遇到并行并发、同步异步、阻塞非阻塞等概念的困扰，特别是在学 Nginx 的时候，异步非阻塞，迷。。。。</p><span id="more"></span><h2 id="并发并行"><a href="#并发并行" class="headerlink" title="并发并行"></a>并发并行</h2><p>理解它们之间的区别，知道有单核多核 CPU 就差不多了。</p><p>对于 <strong>并发</strong> ，在只有一个 CPU 资源时，系统处理多任务的方式是以时间片轮转的方式来执行任务，也即任务轮流获得 CPU 资源进而被执行，同一时刻只有一个任务被执行。</p><p>而当拥有多个 CPU 资源时，多任务会被分配给不同的 CPU 单元，也即同一时刻会有多个任务 <strong>并行</strong> 执行。</p><p><img src="https://techdifferences.com/wp-content/uploads/2017/12/Untitled.jpg"></p><h2 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h2><p>同步异步的概念是从 <strong>消息传递方式</strong> 的角度来定义的。</p><p>在代码中比较典型的体现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> calculateSync();</span><br><span class="line"></span><br><span class="line">calculateAsync(<span class="keyword">new</span> <span class="title class_">Callback</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRet</span><span class="params">(<span class="type">int</span> ret)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以在这里，前者就是同步的调用，后者是异步的。</p><p>前者在调用之后，直到拿到结果才返回；后者在调用后立即返回，结果通过回调的方式回传。<br>当然，异步的回传结果的方式不止这一种，除了回调函数，还有通知和状态检查。</p><h2 id="阻塞非阻塞"><a href="#阻塞非阻塞" class="headerlink" title="阻塞非阻塞"></a>阻塞非阻塞</h2><p>阻塞非阻塞是从 <strong>等待结果的过程</strong> 的角度来定义的。</p><p>对于 <strong>阻塞</strong> ，当前线程&#x2F;进程会被操作系统挂起，当条件满足后会通过中断的方式唤醒；<strong>非阻塞</strong> 则不会导致当前线程&#x2F;进程被挂起，但是需要自己的通过不断轮询条件是否被满足，效率比较低。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33290787/article/details/51790605">https://blog.csdn.net/qq_33290787/article/details/51790605</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473">https://www.zhihu.com/question/19732473</a><br><a target="_blank" rel="noopener" href="https://github.com/calidion/calidion.github.io/issues/40">https://github.com/calidion/calidion.github.io/issues/40</a></p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[Android 踩坑] 明文传输</title>
      <link href="/2018/09/29/a9adff2e5352.html"/>
      <url>/2018/09/29/a9adff2e5352.html</url>
      
        <content type="html"><![CDATA[<p>昨天晚上 Glide 加载图片突然出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception: IOException java.io.IOException: Cleartext HTTP traffic to * not permitted</span><br></pre></td></tr></table></figure><p>明确指出不允许明文传输，测试机器是 Android P 的模拟器。</p><span id="more"></span><p>这个问题是 Android P 在安全方面的一个变更，所以也是坑了一大波人，即 SO 上有答案。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>去年开始 Google 和 Apple 都在 HTTPS 方面加紧推进，但是并没有强制，只是在一些方面设一些小坑。Android P 之前明文传输还是默认支持的，但是在 Android P 及更高的版本上明文传输默认被禁止，所以如果不加配置就运行在 Android P 设备上就会出现异常。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>方案一比较简单，<code>AndroidManifest.xml</code> 添加 <strong>一行</strong> 配置就行了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:usesCleartextTraffic</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>比较推荐这种，灵活性更高。<br>首先提供一个配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">&quot;true&quot;</span>&gt;</span>your.domain<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">domain-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后把这个配置文件在 <code>AndroidManifest.xml</code> 中声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:networkSecurityConfig</span>=<span class="string">&quot;@xml/network_security_config&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个配置文件可以提供更细粒度的域名配置、证书配置等，具体的可以看<a target="_blank" rel="noopener" href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter】 Dart 面向对象</title>
      <link href="/2018/09/25/6e57b15ba6da.html"/>
      <url>/2018/09/25/6e57b15ba6da.html</url>
      
        <content type="html"><![CDATA[<p> Dart 是一门纯粹的面向对象的语言，即任何变量或实例都是 <code>Object</code> 的实例。同时 Dart 不支持多继承，但是支持 <strong>Mixin</strong> 特性，即一个类的定义在 <strong>不被继承</strong> 的情况被其它类复用。</p><span id="more"></span><blockquote><p>在 Dart 2.X 中，<code>new</code> 关键字可以省略</p></blockquote><h2 id="运行时类型"><a href="#运行时类型" class="headerlink" title="运行时类型"></a>运行时类型</h2><p>很多时候都需要获取某个实例的类型，可以通过访问实例的 <code>runtimeType</code> 变量获取变量类型（<code>Type</code>）:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">&quot;this is a String&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(str.runtimeType);</span><br><span class="line">  <span class="built_in">print</span>(str.runtimeType.runtimeType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* String</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> <span class="emphasis">_Type</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> */</span></span></span></span></span><br></pre></td></tr></table></figure><blockquote><p><code>Type</code> 是一个抽象类， <code>_Type</code> 应该是它的具体实现了</p></blockquote><h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><p>下面是实例变量的声明方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    [<span class="keyword">final</span>] <span class="keyword">var</span> value [ = <span class="number">233</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例变量可以手动设置默认值，如果没有设置则默认为 <code>null</code>。一般情况下会为每个实例变量添加 <code>setter</code> 和 <code>getter</code>；当有 <code>final</code> 修饰时，则没有 <code>setter</code>；当变量是私有的时候，则 <code>setter</code>、<code>getter</code> 都没有。</p><p>通过 <code>static</code> 修饰的变量属于这个类，方法也是如此</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>和其它面向对象语言一样，Dart 也是通过声明一个以类名作为方法名，不设置返回值的方法作为一个构造器：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">    <span class="keyword">var</span> y;</span><br><span class="line">    Point(<span class="built_in">int</span> x, <span class="built_in">int</span> y)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果构造器参数用来对实例变量初始化，则可以直接使用构造器参数为实例变量赋值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">    <span class="keyword">var</span> y;</span><br><span class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用 <strong>初始化列表</strong> ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">    <span class="keyword">var</span> y;</span><br><span class="line">    Point(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; coordinates)</span><br><span class="line">        : x = coordinates[<span class="number">0</span>],</span><br><span class="line">          y = coordinates[<span class="number">1</span>] &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像在 C++ 中，实例变量的初始化是推荐在初始化列表中进行而不是在构造器方法体内进行赋值，列表初始化始终存在，没有显式声明则会赋值默认值，也即会多出一次赋值操作。不过 Dart 这边的情况怎么样，暂时还没做探索</p><p>像 Java 一样，如果没有声明任何构造器，那么编译器会提供一个 <strong>无参构造器</strong></p><p>这里要注意的是：</p><ul><li>普通构造器不能定义多个</li></ul><h3 id="命名构造器"><a href="#命名构造器" class="headerlink" title="命名构造器"></a>命名构造器</h3><p>命名构造器的声明形式如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="built_in">num</span> x, y;</span><br><span class="line">    Point.orgin()&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Point.fromMap(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">num</span>&gt; map)&#123;</span><br><span class="line">        x = map[<span class="string">&quot;x&quot;</span>];</span><br><span class="line">        y = map[<span class="string">&quot;y&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  p = <span class="keyword">new</span> Point.origin();</span><br></pre></td></tr></table></figure><p>命名构造器和普通构造器只是在类名后面加上了 “.name”。命名构造器主要作用有：</p><ul><li>让调用方更清楚这个构造器的作用&#x2F;适用场景</li><li>提供多构造器能力</li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>和 Java 一样，有些构造器有时只是单纯的调用其他构造器，所以可以在初始化列表里面调用其他构造器：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="built_in">num</span> x, y;</span><br><span class="line">    Point():<span class="keyword">this</span>.origin();</span><br><span class="line">    Point.orgin()&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两点需要注意：</p><ul><li>重定向不能使用初始化列表进行参数初始化</li><li>使用了重定向的构造器不能有方法体</li></ul><h3 id="常量构造器"><a href="#常量构造器" class="headerlink" title="常量构造器"></a>常量构造器</h3><p>有时候希望创建不可修改的实例，Dart 提供常量构造器来创建编译期不可修改的实例:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">num</span> a;</span><br><span class="line">    <span class="keyword">const</span> Point(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在使用常量构造器的时候使用 <code>const</code> 修饰同时参数也一样，得到的实例会是一样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ConstPoint(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// const a = ConstPoint(1);</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ConstPoint(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// const a = ConstPoint(1);</span></span><br><span class="line"><span class="built_in">print</span>(identical(a, b));<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里需要注意几点：</p><ul><li>声明常量构造器的类，所有实例变量都必须适用 <code>final</code> 修饰</li><li>常量构造器和普通构造器不能同时存在</li><li>常量构造器不能重定向到非常量构造器（VSCode 没有错误提示，但是编译期报错）</li><li>常量构造器不能有方法体</li></ul><h3 id="工厂构造器"><a href="#工厂构造器" class="headerlink" title="工厂构造器"></a>工厂构造器</h3><p>可以通过对象池来理解工厂构造器，也即工厂构造器不一定会创建新实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> _cache = Cache&lt;Point&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _using = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">factory</span> Point()&#123;</span><br><span class="line">        <span class="keyword">var</span>  p = _cache.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = Point.origin();</span><br><span class="line">            _cache.add(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    Point.origin()&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> recycle()&#123;</span><br><span class="line">        _using = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意两点：</p><ul><li>工厂构造器不能和普通构造器同时存在</li><li>工厂构造器无法访问 <code>this</code></li></ul><p>通过工厂构造器，我们可以实现 Dart 中的单例模式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> _instance = Singleton._internal();</span><br><span class="line">    Singleton._internal();</span><br><span class="line">    <span class="keyword">factory</span> Singleton()&#123;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">final</span> b;</span><br><span class="line">  <span class="keyword">var</span> _a;</span><br><span class="line">  SuperClass(<span class="keyword">this</span>.b);</span><br><span class="line">  <span class="keyword">void</span> method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>abstract</code> 关键字声明一个抽象类，没有具体实现的方法都是抽象方法。<br>子类中通过 <code>extends</code> 声明父类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  SubClass(b) : <span class="keyword">super</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> method() &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>extends</code> 可以继承父类中的实现，同时要求实现抽象方法。<br>这里在初始化列表中调用了父类构造器，如果不显式调用父类构造器，则会尝试隐式调用父类空构造器，但是这里的例子中父类并没有空构造器，编译期会报错。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Dart 没有将 <code>interface</code> 作为一个关键字使用，而是将接口含义隐藏在类里面：每个类都会隐式声明一个接口，这个接口包含该类和该类的父类、实现的接口的所有实例成员。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">implements</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  SubClass(b) &#123;&#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">get</span> b =&gt; <span class="keyword">null</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">var</span> _a2;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> method() &#123;&#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> method2() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>和其它语言一样，Dart 也原生提供枚举类型的支持：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color&#123; red, green, blue &#125;</span><br></pre></td></tr></table></figure><p>同时枚举类型会为枚举值提供一个 <strong>基于0</strong> 的索引。</p><h2 id="Mixins（找不到一个好的翻译"><a href="#Mixins（找不到一个好的翻译" class="headerlink" title="Mixins（找不到一个好的翻译"></a>Mixins（找不到一个好的翻译</h2><p>在文章的开头提到 Dart 提供在 <strong>不被继承</strong> 的情况下进行类定义的复用，也即 <strong>Mixins</strong>。还是具体看代码吧：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pilot</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> fly() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fly&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> play() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I can not play&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> fly() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I can not fly&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> play() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;play&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiuBeePerson</span> <span class="title">with</span> <span class="title">Musician</span>, <span class="title">Pilot</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  NiuBeePerson().play();</span><br><span class="line">  NiuBeePerson().fly();</span><br><span class="line">  <span class="built_in">print</span>(NiuBeePerson <span class="keyword">is</span> Pilot);</span><br><span class="line">  <span class="built_in">print</span>(NiuBeePerson <span class="keyword">is</span> Musician);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码后可以得出一下结论：</p><ul><li>后声明的类可以覆盖前面的类的实例变量、函数</li><li>被 mixin 的类中有命名相同、类型不同的实例变量&#x2F;方法会导致编译错误</li><li>mixins 的类实际上被当成了被 mixin 的子类</li></ul><blockquote><p>在写这篇文章的时候，对 Dart 访问控制理解不是很OK，如果看到有类似“私有”对字眼，可以忽略，不会影响</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#classes">https://www.dartlang.org/guides/language/language-tour#classes</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter】Dart 事件循环</title>
      <link href="/2018/09/24/c4cbc1a5e76f.html"/>
      <url>/2018/09/24/c4cbc1a5e76f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于 Dart VM version: 2.1.0-dev.4.0.flutter-4eb879133a (Tue Sep 18 19:20:33 2018 +0000) on “macos_x64”</p></blockquote><p>Dart 和 JS 类似，也是单线程的设计，所以内部存在一个<strong>事件循环</strong>。</p><p>基于单线程，我们可以得出这样的结论：<strong>Dart 的函数一旦执行，便不会被打断，直到函数执行完成才会执行其他 Dart 代码</strong>。</p><span id="more"></span><h2 id="事件循环和队列"><a href="#事件循环和队列" class="headerlink" title="事件循环和队列"></a>事件循环和队列</h2><p>和 Android 的消息机制非常类似，会有一个消息队列，然后有一个循环♻️不断的从队列里面取消息进行处理&#x2F;执行。</p><p><img src="https://webdev.dartlang.org/articles/performance/images/event-loop-example.png"></p><h2 id="Dart-中事件循环实现"><a href="#Dart-中事件循环实现" class="headerlink" title="Dart 中事件循环实现"></a>Dart 中事件循环实现</h2><p>Dart 事件循环实现了两条队列：<strong>event queue</strong>、<strong>microtask queue</strong> 。</p><ul><li><strong>event queue</strong>：包含所有外部的事件，包含不局限于I&#x2F;O、鼠标、绘制、isolate 消息传递，这些消息产生于 Dart 代码或者系统，例如使用 <code>Future</code>。</li><li><strong>microtask queue</strong>：这个队列的作用类似 Android 的 <code>sendMessageAtFront</code> 方法，也即该队列的事件总是会被优先处理，但是由它的名字可知，这个队列里面的事件处理绝不能是耗时计算等，否则会导致 event queue  中事件无法及时处理导致 UI 卡顿。这个队列里的消息一般都来自 Dart 代码（<code>scheduleMicroyask()</code>）。</li></ul><p><img src="https://webdev.dartlang.org/articles/performance/images/both-queues.png"></p><h2 id="关于使用-Future-几点有趣的事实"><a href="#关于使用-Future-几点有趣的事实" class="headerlink" title="关于使用 Future 几点有趣的事实"></a>关于使用 Future 几点有趣的事实</h2><ul><li><p>使用 <code>Future#then</code> 设置的回调函数会在 <code>Future</code> 变成 complete 状态后立即执行而<strong>不是</strong>将这个回调插入队列</p></li><li><p>如果 <code>Future</code> 在 <code>Future#then</code> 调用之前已经是 complete 状态，那么这个回调会被插入 microtask queue。实现这样例子有：<code>Future.value(2333)</code> 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  Future.value(<span class="string">&quot;value&quot;</span>).then(<span class="built_in">print</span>);</span><br><span class="line">  scheduleMicrotask(() =&gt; <span class="built_in">print</span>(<span class="string">&quot;micro&quot;</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* main</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> value</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* micro</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Future#sync</code> 时，传入 sync 等函数立即执行（不插入任何队列），后续操作会被添加到 microtask queue。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  Future.<span class="keyword">sync</span>(() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sync&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2333</span>;</span><br><span class="line">  &#125;).then(<span class="built_in">print</span>);</span><br><span class="line">  scheduleMicrotask(() =&gt; <span class="built_in">print</span>(<span class="string">&quot;micro&quot;</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* sync</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> main</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 2333</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> micro</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>9001、9002 bug 的问题，会导致 microtask 表现会有异常，不想说话</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://webdev.dartlang.org/articles/performance/event-loop">https://webdev.dartlang.org/articles/performance/event-loop</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter】Dart 异步编程</title>
      <link href="/2018/09/24/e0c7abbf2bb1.html"/>
      <url>/2018/09/24/e0c7abbf2bb1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于 Dart VM version: 2.1.0-dev.4.0.flutter-4eb879133a (Tue Sep 18 19:20:33 2018 +0000) on “macos_x64”</p></blockquote><p>Dart 基础库提供了大量返回值类型为 <code>Future</code>  和 <code>Stream</code> 的函数，这些函数都是异步函数，当调用这些函数的时候，函数在完成一些“基础配置“后就会立马返回，而不是等待函数执行完成。</p><span id="more"></span><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>在 JS 世界里，有 <code>Promise</code> ，Dart 中相应实现为 <code>Future</code> 。在语意上，<code>Future</code> 表示将来某个时间开始并完成的事情的结果，这和 <code>Promise</code> 含义相近。</p><p>下面是一个简单🌰：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">new</span> Future(() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">  &#125;).then((s) &#123;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 输出</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> main</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* success</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br></pre></td></tr></table></figure><p>所以可以知道 Future 在创建后立马返回，而不是执行里面的方法体。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Future 异常处理有两种方式，一种是通过 <code>then</code> 函数的<strong>可选命名参数</strong>：<code>onError</code>；第二种是通过 <code>catchError</code> 方法。不过更加完善的异常处理一般是两个方式配合使用，看🌰：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">new</span> Future(() &#123;</span><br><span class="line">    <span class="keyword">throw</span> Exception(<span class="string">&quot;the first exception&quot;</span>);</span><br><span class="line">  &#125;).then((_) =&gt; <span class="number">12</span>, onError: (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;onError callback: <span class="subst">$&#123;e&#125;</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;).then((s) &#123;</span><br><span class="line">    <span class="keyword">throw</span> Exception(<span class="string">&quot;the second exception:<span class="subst">$&#123;s&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;).catchError((e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;catch <span class="subst">$&#123;e&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 输出</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> onError</span></span> callback: Exception: the <span class="language-markdown"><span class="strong">first exception</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*</span></span></span> catch Exception: the <span class="language-markdown"><span class="strong"><span class="emphasis">second exception:123</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br></pre></td></tr></table></figure><p>从结果上看，<code>onError</code> 和 <code>catchError</code> 都可以接受到之前发生的错误，但是这两个处理的使用场景还是有细微的 差别。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p><code>Stream</code> 表示一系列数据或事件，比如点击时间和通知等。</p><p>这里直接看例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  Directory(<span class="string">&quot;/usr/local&quot;</span>).list(recursive: <span class="keyword">false</span>, followLinks: <span class="keyword">false</span>).listen(</span><br><span class="line">      (entity) &#123;</span><br><span class="line">    <span class="built_in">print</span>(entity.path);</span><br><span class="line">  &#125;, onDone: () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;onDone&quot;</span>);</span><br><span class="line">  &#125;, onError: (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;onError: <span class="subst">$&#123;e&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;, cancelOnError: <span class="keyword">false</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果中，会先输出 “main”。</p><p><code>Stream</code> 在调用 <code>listen</code> 方法之后会建立一个<strong>订阅关系</strong>，然后发送数据。</p><p><code>Stream</code> 也分为两种：”Single-subscription” 和 “broadcast”，前者表示只能有一个监听者，即只能调用 <code>listen</code> 调用一次；后者表示一种多播模式，可以调用多次 <code>listen</code> 与多个监听者建立订阅关系。</p><h2 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h2><p>前面 <code>Future</code> 在处理单次简单的异步任务时表现优异，但是当面对多次异步需求，比如两次网络请求，第二次请求依赖第一次请求的返回结果（当然这只是最简单的场景），就会出现类似<strong>回调地狱</strong>的问题。<code>async</code>  和 <code>await</code> 就是应对这样在问题语法层面的一种方式，它们使得<strong>异步调用</strong>变得像同步调用那样顺畅。</p><blockquote><p>和 JS 一样，await 只能在 async 函数内部使用</p></blockquote><h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><p>async 函数和普通函数的声明方式基本没差别，你只需要在方法体之前加上 <code>async</code> 关键字就OK 了，比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Future&lt;<span class="built_in">int</span>&gt;] getInt() <span class="keyword">async</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了增加了修饰符，也将返回值类型使用 <code>Future</code> 进行了包装，但是奇妙的是你并不需要自己将返回值进行包装，Dart 会帮你，如果你想自己手动包装也没问题。</p><h3 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h3><p>我们先看看怎么调用 async 函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  getInt().then(<span class="built_in">print</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 输出</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> main</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 2333</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br></pre></td></tr></table></figure><p>假如想要 “main” 在 “2333” 之后输出，那么可以改成这样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  getInt().then((i)&#123;</span><br><span class="line">    <span class="built_in">print</span>(i);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题得到了解决，但是面对更复杂的场景时，回调地狱还是会发生，这个时候再做做修改：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="keyword">await</span> getInt();</span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 main 函数变成了 async 函数，同时第2行使用了 <code>await</code> 关键字。通过这样的改造，本来是异步的 <code>getInt()</code> 变成了同步的，整个调用流程看起来也更加流畅了。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; _getUserInfo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;_getUserInfo1&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">3000</span>), () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;耗时操作&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;耗时操作完成&quot;</span>;</span><br><span class="line">  &#125;).then((r) =&gt; <span class="built_in">print</span>(r));</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;我是用户&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _loadUserInfo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;_loadUserInfo1&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">await</span> <span class="string">&quot;something&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(s);</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">await</span> _getUserInfo());</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;_loadUserInfo2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main1&quot;</span>);</span><br><span class="line">  _loadUserInfo();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 输出结果</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> main1</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* _loadUserInfo1</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> main2</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* something</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> <span class="emphasis">_getUserInfo1</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> * 耗时操作</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> * 耗时操作完成</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> * 我是用户</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> * _</span>loadUserInfo2</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span></span><br></pre></td></tr></table></figure><p>这里可以看到 <code>async </code> 函数会一直执行直到 <code>await</code> 或 <code>return</code>，然后立即返回。</p><h2 id="sync-amp-async-amp-yield-amp-yield"><a href="#sync-amp-async-amp-yield-amp-yield" class="headerlink" title="sync* &amp; async* &amp; yield &amp; yield*"></a>sync* &amp; async* &amp; yield &amp; yield*</h2><p>在学习 Future、async、await 之后，接着聊聊 <strong>Generator</strong> （毕竟是想要取代 JS 的语言）。</p><p>关于 Generator，可以理解成一系列等待计算的序列。Dart 通过 sync*、async* 等关键字帮助开发者快速实现自己的生成器。</p><blockquote><p>这里我们可以将 async* 看作 async 的加强版，即你可以在 async* 函数里面使用 await</p></blockquote><h3 id="同步-Genrator"><a href="#同步-Genrator" class="headerlink" title="同步 Genrator"></a>同步 Genrator</h3><p>同步 generator 函数返回值是 <code>Iterable</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span> naturalsTo(n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就实现了一个简单 Generator，调用 <code>naturalsTo</code> 后会得到一个 Iterable，但是<strong>方法体</strong>并不会立即执行。调用这个 Iterable 的 iterator 的 <code>moveNext()</code>，方法体会执行到 <code>yield</code> 语句（包含该语句）为止，并能通过 <code>iterator.current</code> 拿到 yield 表达式的返回值。</p><h3 id="异步-Genrator"><a href="#异步-Genrator" class="headerlink" title="异步 Genrator"></a>异步 Genrator</h3><p>异步 generator 函数返回值是 <code>Stream</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream asynchronousNaturalsTo(n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，调用 <code>asynchronousNaturalsTo</code> 立即得到一个 <code>Stream</code> ，<strong>方法体</strong>也是直到调用 <code>listen</code> 之后才会执行。当执行到 <code>yield</code> 时，计算得到的结果会推给 listener，同时继续执行止步到下一句 <code>yield</code> 之前。</p><h3 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h3><p>上面的描述还是比较抽象，看起来同步异步 Generator 似乎并没有差别，我们看下下面代码的运行结果来具体感受一下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) <span class="keyword">async</span> &#123;</span><br><span class="line">  n2Sync(<span class="number">3</span>).first;</span><br><span class="line">  n2Async(<span class="number">3</span>).first;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Iterable</span> n2Sync(n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;n2Sync before:<span class="subst">$&#123;k&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> k++;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;n2Sync after:<span class="subst">$&#123;k&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stream n2Async(n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;n2async before:<span class="subst">$&#123;k&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> k++;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;n2async after:<span class="subst">$&#123;k&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 输出</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2Sync before:0</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* main</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2async before:0</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* n2async after:1</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2async before:1</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span></span><br></pre></td></tr></table></figure><p>当调用变成这样时：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) <span class="keyword">async</span> &#123;</span><br><span class="line">  n2Sync(<span class="number">3</span>).forEach(<span class="built_in">print</span>);</span><br><span class="line">  n2Async(<span class="number">3</span>).forEach(<span class="built_in">print</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 输出</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2Sync before:0</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 0</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2Sync after:1</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* n2Sync before:1</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 1</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* n2Sync after:2</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2Sync before:2</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 2</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2Sync after:3</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* main</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2async before:0</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 0</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2async after:1</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* n2async before:1</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 1</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* n2async after:2</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2async before:2</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 2</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> n2async after:3</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span></span><br></pre></td></tr></table></figure><p>⚠️注意看 “main” 的输出位置，这样大概就能理解同步异步生成器的区别了。</p><h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p>假如存在递归调用，则可以这样写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span> naturalsDownFrom(n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">yield</span> n;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> i <span class="keyword">in</span> naturalsDownFrom(n<span class="number">-1</span>)) &#123; <span class="keyword">yield</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 2 1</span></span><br></pre></td></tr></table></figure><p>不过我们可以通过 <code>yield*</code> 简化上述代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span> naturalsDownFrom(n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* naturalsDownFrom(n<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>异步 Generator 同理</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support">https://www.dartlang.org/guides/language/language-tour#asynchrony-support</a></p><p><a target="_blank" rel="noopener" href="https://www.dartlang.org/articles/language/await-async">https://www.dartlang.org/articles/language/await-async</a></p><p><a target="_blank" rel="noopener" href="https://www.dartlang.org/articles/language/beyond-async">https://www.dartlang.org/articles/language/beyond-async</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter】Dart 函数</title>
      <link href="/2018/09/24/749cd7055b9d.html"/>
      <url>/2018/09/24/749cd7055b9d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于 Dart VM version: 2.1.0-dev.4.0.flutter-4eb879133a (Tue Sep 18 19:20:33 2018 +0000) on “macos_x64”</p></blockquote><p>函数在 Dart 中有专门的 <code>Function</code> 对应，也就是说定义一个函数其实是定义了一个变量，而这个变量类型是 <code>Function</code> ，需要执行这个函数时就和普通的函数调用一样。</p><blockquote><p>当然这个变量不可写</p></blockquote><span id="more"></span><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数定义的一般形式是这样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[type] funname([type] p0, [[type] pn], [[type] pp0 [= <span class="string">&#x27;default&#x27;</span>] [, [type] pp1]])&#123;</span><br><span class="line">    [<span class="keyword">return</span> expr]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[type] funname([type] p0, [[type] pn], [&#123;type] pp0 [= <span class="string">&#x27;default&#x27;</span>] [, [type] pp1&#125;])&#123;</span><br><span class="line">    [<span class="keyword">return</span> expr]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前者表示有 <strong>可选位置参数</strong> 的函数定义，后者表示有 <strong>可选命名参数</strong> 的函数定义。</p><p>同时，函数返回值和参数类型可以省略，省略时表示 <code>dynamic</code> 类型。</p><p>函数都有返回值，没有 <code>return</code> 语句是返回值为 <code>void</code></p><p>另外，当函数体只有一条语句时，可以缩写为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; statement</span><br></pre></td></tr></table></figure><p>比如：<code>var add = (int a, int b) =&gt; a + b;</code></p><blockquote><p>需要注意的是，<strong>可选位置参数</strong>和<strong>可选命名参数</strong>不可同时存在函数声明里</p></blockquote><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>像上一节中的函数定义是定义的<strong>命名函数</strong>，但是也有很多情况下我们不需要为一个函数取一个名字，即匿名函数。</p><p>比如下面这种情况：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].forEach(([<span class="built_in">int</span> ]a)=&gt;<span class="built_in">print</span>(a)); <span class="comment">// 参数类型同样可以省略</span></span><br></pre></td></tr></table></figure><h2 id="闭包支持"><a href="#闭包支持" class="headerlink" title="闭包支持"></a>闭包支持</h2><p>Dart 完整支持闭包，而不是像 Java 那样需要被访问的外部变量使用 <code>final</code> 修饰，下面是一个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">    <span class="keyword">var</span> f = makeF();</span><br><span class="line">    <span class="built_in">print</span>(f().hashCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span> makeF()&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> Name();</span><br><span class="line">    <span class="built_in">print</span>(a.hashCode);</span><br><span class="line">    <span class="keyword">return</span> () =&gt; a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>()</span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两次输出值是一样的。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#functions">https://www.dartlang.org/guides/language/language-tour#functions</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建带参的 ViewModel 实例</title>
      <link href="/2018/08/18/3cf906a16cdd.html"/>
      <url>/2018/08/18/3cf906a16cdd.html</url>
      
        <content type="html"><![CDATA[<p>Android Jet Pack 的 <code>ViewModel</code> 为开发者在处理配置变更时数据保存带来了一定便捷性，但是如果定义的 <code>ViewModel</code> 子类构造器有参数，那么还要提供一个对应的 <code>ViewModelProvider.Factory</code> 实现。</p><span id="more"></span><p>那么问题来了，这都是一些样板代码，枯燥无意义，所以更加优雅的方式还是通过工具自动创建。</p><h2 id="工具实现"><a href="#工具实现" class="headerlink" title="工具实现"></a>工具实现</h2><p>不废话了，直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VMFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Constructor&lt;?&gt;&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">viewModel</span><span class="params">(Fragment frag, Class&lt;T&gt; vmClazz, <span class="keyword">final</span> Object... params)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewModelProviders.of(frag, factory(vmClazz, params)).get(vmClazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">viewModel</span><span class="params">(FragmentActivity activity, Class&lt;T&gt; vmClazz, <span class="keyword">final</span> Object... params)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewModelProviders.of(activity, factory(vmClazz, params)).get(vmClazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; ViewModelProvider.Factory <span class="title function_">factory</span><span class="params">(Class&lt;T&gt; vmClazz, <span class="keyword">final</span> Object... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (params == <span class="literal">null</span> || params.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>.NewInstanceFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (ViewModelProvider.Factory) Proxy.newProxyInstance(vmClazz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ViewModelProvider.Factory.class&#125;, (obj, method, objs) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getDeclaringClass() == Object.class</span><br><span class="line">                        || Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N &amp;&amp; method.isDefault()</span><br><span class="line">                        || !method.getName().equals(<span class="string">&quot;create&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(obj, objs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">keyBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(objs[<span class="number">0</span>].getClass().getCanonicalName());</span><br><span class="line">                Class&lt;?&gt;[] paramTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[params.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">                    paramTypes[i] = params[i].getClass();</span><br><span class="line">                    keyBuilder.append(paramTypes[i].getCanonicalName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyBuilder.toString();</span><br><span class="line">                Constructor&lt;?&gt; constructor = cacheMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (constructor != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> constructor.newInstance(params);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor: vmClazz.getDeclaredConstructors()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (areAssignableFrom(declaredConstructor.getParameterTypes(), paramTypes)) &#123;</span><br><span class="line">                        cacheMap.put(key, declaredConstructor);</span><br><span class="line">                        <span class="keyword">if</span> (!declaredConstructor.isAccessible()) &#123;</span><br><span class="line">                            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> declaredConstructor.newInstance(params);</span><br><span class="line">                            declaredConstructor.setAccessible(<span class="literal">false</span>);</span><br><span class="line">                            <span class="keyword">return</span> instance;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> declaredConstructor.newInstance(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cacheMap.remove(key);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot create an instance of &quot;</span> + vmClazz.getCanonicalName() + <span class="string">&quot; with params: &quot;</span> + Arrays.asList(paramTypes).toString());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">areAssignableFrom</span><span class="params">(Class&lt;?&gt;[] constructorParameterTypes, Class&lt;?&gt;[] paramTypes)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (constructorParameterTypes.length == paramTypes.length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paramTypes.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!constructorParameterTypes[i].isAssignableFrom(paramTypes[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再简单 BB 几句。</p><p>可以看到 <code>factory</code> 方法里主要用到了 <strong>动态代理</strong>，其实也可以直接创建匿名内部类，我们不纠结这个问题。</p><p>通过 <code>vmClazz.getDeclaredConstructors()</code> 拿到所有构造器，然后通过传入的参数逐个进行匹配直到找到目标构造器。然后将目标构造器丢到缓存里，毕竟找到一个构造器执行了挺多的反射操作。</p><p>通过构造器匹配的方式，调用 <code>ViewModel</code> 哪个构造器完全取决于你传什么参数。即使构造器是 <code>private</code> 修饰，也能完成实例创建，其实如果了解 <code>ViewModel</code> 创建及保存原理，用 <code>private</code> 修饰其实应该是一个最佳实践。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>移动设备上的 <strong>反射</strong> 还是挺扎眼的，始终逃不过性能这道坎，所以也做了一个简单的性能测试。<br>在我的 一加3 Android 8.1.0 上对比通过 <code>ViewModelProvider.Factory</code> 实例和动态代理对象的创建 <code>ViewModel</code> 耗时，后者耗时大概是前者的 <strong>2.5</strong> 倍，当然这只是 <strong>初次执行</strong> 的情况，当动态代理方式有缓存之后，两者耗时基本一致了。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>不管怎么样，实例创建还是通过反射来完成的（虽然 <code>ViewModelProvider.NewInstanceFactory</code> 也是通过反射），肯定存在性能损耗，所以后续优化可以从访问修饰符上入手，目前的想法是通过 <strong>注解处理器</strong> 创建一个辅助类，收集所有 <code>ViewModel</code>，在编译时根据访问修饰符选择 <code>new</code> 还是 <code>Constrctor#newInstance</code>。</p><p>完整代码在 <a target="_blank" rel="noopener" href="https://github.com/dashMrl/AutoVM">这里</a>，里面也有之前实践过程中写的编译时创建 <code>ViewModelProvider.Factory</code> 实现类的注解处理器。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ViewModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 实现 Java 匿名内部类</title>
      <link href="/2018/08/18/bba0f678aef8.html"/>
      <url>/2018/08/18/bba0f678aef8.html</url>
      
        <content type="html"><![CDATA[<p>突然想对之前写的 JSBridge 用 TS 重构一下，顺便简化一下整体结构。TS 的强类型是有了，但是还是存在着不足，导致相比其他强类型语言，稍微显得有点蹩脚。</p><span id="more"></span><p>比如创建一个抽象类的匿名内部类对象，就没法像 Java 那样，幸好基于 JS 本身的一些特点还是达到这个效果，看代码；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SuperClazz</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params"><span class="keyword">readonly</span> msg: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">hello</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用的地方我们通过 <strong>自执行函数</strong> 来创建子类对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;asd&#x27;</span>;</span><br><span class="line">(<span class="function">(<span class="params">msgParam: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">class</span> <span class="title class_">SubClazz</span> <span class="keyword">extends</span> <span class="title class_ inherited__">SuperClazz</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">            <span class="variable language_">super</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">hello</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(msgParam);</span><br><span class="line">&#125;)(msg);</span><br></pre></td></tr></table></figure><p><br>当时被这个问题卡了一小会，想到这个后马上就小本本记下来了。然后联想到其实 Java 也是可以在函数里面定义类的，只是因为一般都用匿名内部类的语法，所以一般也很难想到在函数体内定义一个类。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 项目集成 React Native</title>
      <link href="/2018/04/07/87987735ef23.html"/>
      <url>/2018/04/07/87987735ef23.html</url>
      
        <content type="html"><![CDATA[<p>如果不是一个从零开始的项目，那么更多情况下是需要把 React Native 作为一个功能模块嵌入到现有应用中，这篇文章简单记录一下怎么集成 RN 到现有 Android 项目中，以及一些坑点。</p><span id="more"></span><blockquote><p>OS：macOS 10.13.4</p><p>node：v9.10.1</p><p>npm：5.8.0</p><p>AS：3.1.0</p></blockquote><h2 id="创建-npm-工程"><a href="#创建-npm-工程" class="headerlink" title="创建 npm 工程"></a>创建 npm 工程</h2><p>按照传统 React Native 的代码使用 npm 进行“构建”，并且 Android 项目中一些依赖也来自于这个工程。</p><p>找一个你喜欢的位置，执行一下命令初始化一个 npm 项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> rn &amp;&amp; <span class="built_in">cd</span> rn</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm init -y</span></span><br></pre></td></tr></table></figure><p>然后需要安装 react 和 react-native ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install --save react react-native</span></span><br></pre></td></tr></table></figure><p>接着创建一个入口文件和一些必要目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> index.android.js</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> app</span></span><br></pre></td></tr></table></figure><p>完成以上操作后，会得到一个如下的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── app</span><br><span class="line">├── index.android.js</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><p>再向 index.android.js 中填入如下内容：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">AppRegistry</span>,</span><br><span class="line">  <span class="title class_">StyleSheet</span>,</span><br><span class="line">  <span class="title class_">Text</span>,</span><br><span class="line">  <span class="title class_">View</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.hello&#125;</span>&gt;</span>Hello    RN!!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> styles = <span class="title class_">StyleSheet</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">container</span>: &#123;</span><br><span class="line">    <span class="attr">flex</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">justifyContent</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">hello</span>: &#123;</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">    <span class="attr">margin</span>: <span class="number">10</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">AppRegistry</span>.<span class="title function_">registerComponent</span>(<span class="string">&#x27;HelloRN&#x27;</span>, <span class="function">() =&gt;</span> <span class="title class_">HelloWorld</span>);</span><br></pre></td></tr></table></figure><p>以上代码在屏幕正中央显示 “HelloRN” 。</p><p>最后修改一下 <strong>package.json</strong> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rn&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node node_modules/react-native/local-cli/cli.js start&quot;</span><span class="punctuation">,</span> <span class="comment">// 启动开发服务器</span></span><br><span class="line">    <span class="attr">&quot;bundle-android&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node node_modules/react-native/local-cli/cli.js bundle --platform android --dev false --entry-file index.android.js --bundle-output ../rndemo/src/release/assets/index.android.bundle --assets-dest ../rndemo/src/release/res/&quot;</span><span class="punctuation">,</span><span class="comment">// 打包 JS</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^16.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react-native&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.55.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>具体的路径根据实际情况修改。</p><h2 id="创建-Android-工程"><a href="#创建-Android-工程" class="headerlink" title="创建 Android 工程"></a>创建 Android 工程</h2><p>在和 rn 同级目录创建一个工程，然后修改根目录的 build.gradle 如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        maven&#123;</span><br><span class="line">            url <span class="string">&quot;$rootDir/rn/node_modules/react-native/android&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很容易猜到，在 <code>$rootDir/rn/node_modules/react-native/android</code> 中肯定有一些 jar 包。</p><p>然后在 app module 的build.gradle 文件里添加：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  implementation <span class="string">&quot;com.facebook.react:react-native:+&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加权网络权限"><a href="#添加权网络权限" class="headerlink" title="添加权网络权限"></a>添加权网络权限</h3><p>在 <code>AndroidManifest.xml</code> 文件里添加网络权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加开发者菜单"><a href="#添加开发者菜单" class="headerlink" title="添加开发者菜单"></a>添加开发者菜单</h3><p>这个一般用于开发时，可以直接从本地服务器自动拉取最新 JavaScript 代码，还是建议加上。正式发版时，还是需要去掉这个，所以还需要简单配置下。</p><p>在 src 目录下创建一个 debug 目录，然后创建一个 <code>AndroidManifest.xml</code> 文件并填入以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.dashmrl.rndemo&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.facebook.react.devsupport.DevSettingsActivity&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样在正式打包的时候就可以去掉这个 DevSettingsActivity 了。</p><h3 id="添加-DrawOverlays-权限"><a href="#添加-DrawOverlays-权限" class="headerlink" title="添加 DrawOverlays 权限"></a>添加 DrawOverlays 权限</h3><p>开发时，错误信息会显示在红底悬浮窗中，在 Android M 及以上的系统中需要用户授权才能显示，所以为了便于debug，需要开启这一权限。在 Activity 中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bunlde savedStateInstance)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Settings.canDrawOverlays(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,</span><br><span class="line">                                       Uri.parse(<span class="string">&quot;package:&quot;</span> + getPackageName()));</span><br><span class="line">            startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode == OVERLAY_PERMISSION_REQ_CODE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Settings.canDrawOverlays(<span class="built_in">this</span>)) &#123;</span><br><span class="line">                <span class="comment">// SYSTEM_ALERT_WINDOW permission not granted...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是大概的流程，具体的看场景。</p><h3 id="添加-RN-的宿主-Activity"><a href="#添加-RN-的宿主-Activity" class="headerlink" title="添加 RN 的宿主 Activity"></a>添加 RN 的宿主 Activity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">DefaultHardwareBackBtnHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ReactRootView mReactRootView;</span><br><span class="line">    <span class="keyword">private</span> ReactInstanceManager mReactInstanceManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mReactRootView = <span class="keyword">new</span> <span class="title class_">ReactRootView</span>(<span class="built_in">this</span>);</span><br><span class="line">        mReactInstanceManager = ReactInstanceManager.builder()</span><br><span class="line">                .setApplication(getApplication())</span><br><span class="line">                .setUseDeveloperSupport(BuildConfig.DEBUG)</span><br><span class="line">                .setJSMainModulePath(<span class="string">&quot;index.android&quot;</span>)<span class="comment">// 开发服务器 js bundle 所在目录</span></span><br><span class="line">                .setBundleAssetName(<span class="string">&quot;index.android.bundle&quot;</span>)</span><br><span class="line">                .addPackage(<span class="keyword">new</span> <span class="title class_">MainReactPackage</span>())</span><br><span class="line">                .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的 HelloRN 必须对应“index.android.js”中的</span></span><br><span class="line">        <span class="comment">// “AppRegistry.registerComponent()”的第一个参数</span></span><br><span class="line">        mReactRootView.startReactApplication(mReactInstanceManager, <span class="string">&quot;HelloRN&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        setContentView(mReactRootView);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onHostPause(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onHostResume(<span class="built_in">this</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onHostDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//一般情况下，需要先将返回键事件交由 JS 处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBackPressed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onBackPressed();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onBackPressed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当 JS 不想处理返回键事件的时候，就会调用这个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeDefaultOnBackPressed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onBackPressed();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  默认情况下，抖一抖手机显示配置对话框，但是模拟器无法抖一抖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onKeyUp</span><span class="params">(<span class="type">int</span> keyCode, KeyEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; mReactInstanceManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.showDevOptionsDialog();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onKeyUp(keyCode, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个 Activity 注册就好了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">&quot;.HelloActivity&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第4行避免出现工具栏，现在一般也都会使用这个主题。</p><h2 id="开车"><a href="#开车" class="headerlink" title="开车"></a>开车</h2><p>完成上面的配置就可以运行了。</p><h3 id="启动开发服务器"><a href="#启动开发服务器" class="headerlink" title="启动开发服务器"></a>启动开发服务器</h3><p>进入 rn 目录，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm start</span></span><br></pre></td></tr></table></figure><p>然后会看到如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">rn@1.0.0 start /Volumes/Files/Projects/Android/Android_Demos/rn</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node node_modules/react-native/local-cli/cli.js start</span></span><br><span class="line"></span><br><span class="line">Scanning folders for symlinks in /Volumes/Files/Projects/Android/Android_Demos/rn/node_modules (14ms)</span><br><span class="line">┌──────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                                                              │</span><br><span class="line">│  Running Metro Bundler on port 8081.                                         │</span><br><span class="line">│                                                                              │</span><br><span class="line">│  Keep Metro running while developing on any JS projects. Feel free to        │</span><br><span class="line">│  close this tab and run your own Metro instance if you prefer.               │</span><br><span class="line">│                                                                              │</span><br><span class="line">│  https://github.com/facebook/react-native                                    │</span><br><span class="line">│                                                                              │</span><br><span class="line">└──────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">Looking for JS files in</span><br><span class="line">   /Volumes/Files/Projects/Android/Android_Demos/rn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Metro Bundler ready.</span><br><span class="line"></span><br><span class="line">Loading dependency graph, done.</span><br></pre></td></tr></table></figure><h3 id="运行-Android-应用"><a href="#运行-Android-应用" class="headerlink" title="运行 Android 应用"></a>运行 Android 应用</h3><p>启动开发服务器后，就可以和正常开发 Android 应用时一样启动应用了。</p><p>运行后可以看到终端里有如下的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BUNDLE  [android, dev] ./index.android.js ▓▓▓▓▓▓▓▓▓▓▓▓▓░░░ 86.3% (446/480)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://i.loli.net/2018/04/07/5ac8c2ed70558.png"></p><p>这时候使用 cmd + M 键呼出菜单，就可以进行一些调试的配置了。</p><h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><p>当显示 Perf Monitor 时就会造成开发热更新失败，所以只能先关闭这个，只在真正性能调优的时候开启。</p><h2 id="打包-App"><a href="#打包-App" class="headerlink" title="打包 App"></a>打包 App</h2><p>最终还是要打包成一个 App，需要先将 JS 打包，然后再 build 应用。</p><p>进入 rn 目录，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm run bundle-android</span></span><br></pre></td></tr></table></figure><p>assets、res 目录要提前创建好，然后文件就会输出到相应目录下去。</p><blockquote><p> release 文件夹这里专门用来放 JS bundle ，不需要添加到版本控制系统里面去</p></blockquote><p>然后走正常的 Android 打包流程就好了。</p><p><a target="_blank" rel="noopener" href="https://github.com/dashMrl/Android_Demos/tree/7dad68a388008cb3e1800532ac23b2dc9d88955b">Demo 地址</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.51/integration-with-existing-apps.html">https://reactnative.cn/docs/0.51/integration-with-existing-apps.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> React Native </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitLab Flow</title>
      <link href="/2018/03/31/5cdee86432b5.html"/>
      <url>/2018/03/31/5cdee86432b5.html</url>
      
        <content type="html"><![CDATA[<p>GitLab Flow 在 Git Flow 和 GitHub Flow 中进行了一个折衷，避免了 Git Flow 的复杂性，又使得 GitHub Flow 不便于发版审核的问题。</p><span id="more"></span><blockquote><p>GitLab 比较鸡贼，提出好几种分支管理模式，还不能满足你需求？</p></blockquote><h2 id="使用-production-分支"><a href="#使用-production-分支" class="headerlink" title="使用 production 分支"></a>使用 production 分支</h2><p><img src="https://about.gitlab.com/images/git_flow/production_branch.png"></p><p>GitHub Flow 认为每一次的合并操作都会产生一个可发布的版本，但是这只适合诸如 SaaS 类应用；并且还无法处理无法精确控制发布时间或只能在规定时间里merge的问题。</p><p>这种情况下，可以开一个 production 分支来反应部署的代码。每次部署都要把 master 分支合并到 production，大概的部署时间能在 commit 记录中反映出来，如果使用脚本进行自动部署，那么时间会更加精确。</p><h2 id="使用-environment-分支"><a href="#使用-environment-分支" class="headerlink" title="使用 environment 分支"></a>使用 environment 分支</h2><p><img src="https://about.gitlab.com/images/git_flow/environment_branches.png"></p><p>在这种分支管理模式下，master 分支作为代码上游，通过将 master 合并到 pre-productiopn 部署 pre-production 环境，同理将 pre-production 合并到 production 部署 production 环境。这种下行的方式保证所有代码在所有环境中都测试通过。如果要 cherry-pick 一个 hotfix，这个通常发生在 feature 分支上，在合并到主分支后，不要删除 feature 分支。当 master 分支上代码通过测试后（通常是CI），就可以合并到其他分支了。</p><h2 id="使用-release-分支"><a href="#使用-release-分支" class="headerlink" title="使用 release 分支"></a>使用 release 分支</h2><p><img src="https://about.gitlab.com/images/git_flow/release_branches.png"></p><p>只有当你需要将软件发布出去时（比如app），你才需要使用 release 分支。在这种情况下，每一个分支包含一个小版本号（例如 2-3-stable）。stable 分支会从 master 分支创建并且尽可能晚地创建，尽可能晚地创建可以减少后续修复 bug 所花时间（因为需要将 hotfix 代码合并到多个 stable 分支上）。</p><p>当一个 release 分支创建之后，只有非常严重的 bug 才能把代码直接合并到 release 分支，一般情况下都是先把代码合并到 master，然后通过 cherry-pick 合并到 release 分支。注意不要忘了把修复代码合并到其它有问题的分支中去。</p><p>这种模式也叫 <strong>上游优先</strong> ，Google 和 RedHat 也有在实践这一模式。每当一个修复被合并时，一个新的 release 分支就会被创建并且打上 tag。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相对于 GitHub Flow ，通过增加一些分支创建策略，来实现更加复杂的功能， 本质上也没有太多的提高。所以采用怎样的分支策略，还是要考虑具体情况和需求。</p><blockquote><p>参考链接：</p><p><a target="_blank" rel="noopener" href="https://about.gitlab.com/2014/09/29/gitlab-flow/">https://about.gitlab.com/2014/09/29/gitlab-flow/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitLab Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Flow</title>
      <link href="/2018/03/31/094d58c2150c.html"/>
      <url>/2018/03/31/094d58c2150c.html</url>
      
        <content type="html"><![CDATA[<p>在 <a target="_blank" rel="noopener" href="http://xinsbackyard.tech/posts/9144d7b5.html">这篇</a> 文章中，Git Flow 整体管理看起来非常规范，但是一个很明显的问题就是太复杂并需要长期维护两个分支，分支太多，导致需要频繁的进行分支切换，这些过程中难免不会出问题；特别是现在的大型工程都采用持续集成&#x2F;交付进行管理，这样就需要有一个分支能够保证上面的代码都是随时都可以发布的。</p><span id="more"></span><p>GitHub Flow 就是对 Git Flow 的一种精简，并且非常适用于持续集成。</p><h2 id="理解-GitHub-Flow"><a href="#理解-GitHub-Flow" class="headerlink" title="理解 GitHub Flow"></a>理解 GitHub Flow</h2><p><img src="https://i.loli.net/2018/03/31/5abef3132dff2.jpg"></p><p>GitHub Flow 相对于 Git Flow，它只保留了一个 master 分支，任何功能的添加都需要创建一个新分支，并且这些新的分支在被其他成员审阅之前是不会被合并到 maste 分支上的。显然，master 分支总是处于一个可发布的状态，同时这种模式非常适合不断有新功能添加的项目。</p><p>如果有多个人（团队）进行开发，GitHub Flow 推荐使用 pull request 的方式来进行合作。</p><h2 id="管理流程"><a href="#管理流程" class="headerlink" title="管理流程"></a>管理流程</h2><p>Git Flow 的管理流程也非常简单，大致的分为下面的几个步骤：</p><ul><li>创建功能分支</li><li>提交功能分支</li><li>请求一个 pull request（GitLab 中叫做 merge request）</li><li>讨论并进行代码审查</li><li>发布并进行测试</li><li>合并到 master ，如果 pull request 中使用了特定的关键字，如 <code>Close #32</code> ，那么相关 issue 会被自动关闭</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这种模式的好处是可以快速的进行功能添加，非常灵活迅速，很适合一些开源项目。但是对于大多数的商业项目，例如 iOS App，每次上架新版都需要审核    ，但是审核的这段时间开发不能停止，这就导致线上的版本于 master 分支相比，不总是同步。所以为了解决这个问题，还是需要开一个 production 分支来追踪线上版本，进行 bug 修复更改小版本号以及合并回主分支。</p><blockquote><p>参考链接：</p><p><a target="_blank" rel="noopener" href="https://help.github.com/articles/github-flow/">https://help.github.com/articles/github-flow/</a></p><p><a target="_blank" rel="noopener" href="https://guides.github.com/introduction/flow/">https://guides.github.com/introduction/flow/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Flow（译）</title>
      <link href="/2018/03/31/1c3de7f319e2.html"/>
      <url>/2018/03/31/1c3de7f319e2.html</url>
      
        <content type="html"><![CDATA[<p>在这篇文章中，我将会向大家讲解我大约一年前引入一些项目（公司或者私有的）里并且被事实证明为非常成功的开发模式。我早就想写一些关于这方面的东西，但是直到现在才找到时间来完整地完成这些东西。这里我不会讨论任何项目细节方面的东西，仅仅讨论分支策略和发版管理。</p><span id="more"></span><p><img src="http://nvie.com/img/git-model@2x.png"></p><h2 id="为什么选择-Git"><a href="#为什么选择-Git" class="headerlink" title="为什么选择 Git"></a>为什么选择 Git</h2><p>网上有各种关于 Git 和其他版本控制系统的优缺点比较，当然也有很多意见不一致的地方。作为一名开发者，我更偏向于使用 Git。Git 确实改变了开发者对于分支管理的思考方式。在传统的 CVS&#x2F;Subversio 的世界中，分支合并和创建通常被认为有一点吓人（通常是冲突）并且你一段时间内只会做一次。</p><p>但是使用 Git，这些操纵将会变得非常简单，并且它们会成为你日常工作流中核心的一部分。例如，在 CVS&#x2F;Subversion 的文档中，分支的创建和合并被安排在最后三章作为高级功能；与此同时，所有的 Git 文档里面，这些都是在前三章中的基础部分进行讲解的。</p><p>由于 Git 的简便性和可复现性，分支创建与合并再也不令人望而生畏。版本控制系统本就应该只辅助完成分支的创建于合并。</p><p>关于工具的讨论就到这里，让我们接着看开发模式。接下来我要讲解的开发模式，不过是一套流程，为了更好地管理开发进展，每个团队成员都必须遵守它。</p><h2 id="去中心化和中心化"><a href="#去中心化和中心化" class="headerlink" title="去中心化和中心化"></a>去中心化和中心化</h2><p>我们使用一个中心仓库来配合分支管理模型。需要注意的是，这个中心仓库仅仅是被看作中心仓库，毕竟 Git 是去中心化版本控制系统，这里只是为了便于理解。我们通常把这个中心仓库叫做 <strong>origin</strong> ，大多数 Git 用户应该非常熟悉这个名字。</p><p><img src="http://nvie.com/img/centr-decentr@2x.png"> 每个开发者从这个仓库拉取或向它提交代码。除了这个中心化的 <strong>pull-push</strong> 关系外，每位开发者还会从其它的子团队拉取代码。例如，在向中心仓库提交之前，这种模式对于那种有几个团队一起开发一个功能的时候非常有效。在上面的图示中，有由 Alice 与 Bob、Alice 与 David 以及 Clair 与 David 组成的子团队。</p><h2 id="主要分支"><a href="#主要分支" class="headerlink" title="主要分支"></a>主要分支</h2><p><img src="http://nvie.com/img/main-branches@2x.png"></p><p>一个比较核心的问题，这个开发模式受现有开发模式的启发。中心仓库保持两个永久的分支：</p><ul><li>master</li><li>develop</li></ul><p>origin 的 master 分支，大部分 Git 用户都不会陌生。与 master 分支共存的还有一个 develop 分支。</p><p>我们认为 origin&#x2F;master 分支上的代码总是对应着一个预发布状态的代码。</p><p>origin&#x2F;master 分支存放着下一个版本的更改。有些人把这个分支叫做 ”integration branch“。所有的 nightly 自动化构建都是从这个分支产生的。</p><p>当 develop 分支的代码达到一个稳定状态并且可以发布时，所有的更改都应该被合并到 master 分支上，并且打上版本号的 tag。关于这个过程更加详细的信息将会在下面讲解。</p><p>因此，每次变更合并到 master 分支，都代表着一个生产环境发布。这一点上我们会非常谨慎，所以我们可以使用 Git hook 脚本来使得当变更提交到 master 上时，代码会自动构建并发布到我们的生产服务器上。</p><h2 id="支撑分支"><a href="#支撑分支" class="headerlink" title="支撑分支"></a>支撑分支</h2><p>在 master 和 develop 分支之外，我们的开发模式使用一些支撑分支来辅助多个团队并行开发，追踪功能变更，准备版本发布以及快速修复线上问题。不像 <strong>主要分支</strong> ，这些分支通常有一个有限的生命周期，因为它们最后都会被移除。</p><p>这些不同的分支是：</p><ul><li>Feature branches</li><li>Release branches</li><li>Hotfix branches</li></ul><p>这些分支有它们各自的目的，并且有一套严格的规则来限制它们从哪些分支产生，以及最终合并到哪些分支。我们马上就会讨论这些规则。</p><p>毫无疑问，这些分支在技术的角度来讲是比较“特殊的”。它们根据使用方式来进行分类，当然它们也还是普通的分支。</p><h3 id="Feature-braches"><a href="#Feature-braches" class="headerlink" title="Feature braches"></a>Feature braches</h3><p><img src="http://nvie.com/img/fb@2x.png"></p><ul><li><p>可能产生于：</p><p>develop</p></li><li><p>必须合并到：</p><p>develop</p></li><li><p>命名要求：</p><p>除了 master、develop、release-* 、hotfix-*</p></li></ul><p>feature 分支通常用来为下一个或者接下来的版本开发新的功能。一个功能分支最终被合并到哪一个release版本是未知的。只要这个功能还在开发，功能分支就会一直存在，但是最终还是会被合并到develop分支或者抛弃并删除。</p><p>功能分支通常指存在于开发者的仓库中，并不会提交到 origin 中去。</p><h4 id="创建-feature-分支"><a href="#创建-feature-分支" class="headerlink" title="创建 feature 分支"></a>创建 feature 分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b feature-hello develop</span></span><br></pre></td></tr></table></figure><p>将会从 develop 分支创建 feature-hello 分支。</p><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout feature-hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge feature-hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d feature-hello</span></span><br></pre></td></tr></table></figure><p>这里会先将 develop 分支合并到 feature 分支，最后再合并回 develop 分支，这样可以避免在 develop 分支上解决冲突，避免 develop 分支被污染，最后删除 feature 分支。</p><h3 id="Release-branches"><a href="#Release-branches" class="headerlink" title="Release branches"></a>Release branches</h3><ul><li><p>可能产生于：</p><p>develop</p></li><li><p>必须合并到：</p><p>develop 和 master</p></li><li><p>命名要求：</p><p>release-*</p></li></ul><p>release 分支为一个生产发布做准备。这里允许做一些小的 bug 修复并准备一些发布所需的元数据（如 版本号、构建日期等）。通过在 release 上做这些工作，develop 可以继续为下一次大版本发布做准备。</p><p>当 develop 分支达到一个比较理想的发布状态时，就可以创建 release 分支了。这时还需要保证所有的功能都开发完毕并且合并到了 develop 分支。下一个版本的功能分支必须在这次的 release 分支创建之后才能创建。</p><p>release 分支在创建之后就会拥有一个版本号，但是这个时候还不能确定我的下一个 release 版本号是多少，因为这个还会受一系列因素的影响，比如代码提交次数等。</p><h4 id="创建-release-分支"><a href="#创建-release-分支" class="headerlink" title="创建 release 分支"></a>创建 release 分支</h4><p>release 分支从 develop 分支产生。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">版本号依实际情况变化</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b release-1.2 develop</span></span><br></pre></td></tr></table></figure><p>这个新分支会一直存在直到正式发布。在此之前，小的 bug 修复可以提交到这个分支。这个分支上禁止添加新功能。release 分支最后必须合并到 develop 和 master 分支。</p><h4 id="结束-release-分支"><a href="#结束-release-分支" class="headerlink" title="结束 release 分支"></a>结束 release 分支</h4><p>当 release 分支的代码到达可以真正发布的状态时，需要做一些处理工作。首先， release 分支必须合并到 master 分支，然后 master 分支上的 commit 必须打上 tag 用于历史版本的查询。最后，release 分支上的变化必须合并到 develop 分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge release-1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge release-1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d release-1.2</span></span><br></pre></td></tr></table></figure><h3 id="Hotfix-branches"><a href="#Hotfix-branches" class="headerlink" title="Hotfix branches"></a>Hotfix branches</h3><p><img src="http://nvie.com/img/hotfix-branches@2x.png"></p><ul><li><p>可能产生于：</p><p>master</p></li><li><p>必须合并到：</p><p>develop 和 master</p></li><li><p>命名要求：</p><p>hotfix-*</p></li></ul><p>hotfix 分支和 release 分支很像，它们都准备了一次新的版本发布，尽管 hotfix 是预料之外的。当线上版本出现非预期的问题时，就会创建 hotfix 分支，并且标记上版本信息。</p><p>利用 hotfix 分支可以做到一个成员继续开发，而另一个成员进行 bug 修复。</p><h4 id="创建-hotfix-分支"><a href="#创建-hotfix-分支" class="headerlink" title="创建 hotfix 分支"></a>创建 hotfix 分支</h4><p>从 master 分支创建 hotfix 分支，例如当前 master 版本号为 1.2，那么 hotfix 版本号就应该为 1.2.1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b hotfix-1.2.1 master</span></span><br></pre></td></tr></table></figure><h4 id="结束-hotfix-分支"><a href="#结束-hotfix-分支" class="headerlink" title="结束 hotfix 分支"></a>结束 hotfix 分支</h4><p>当完成 bug 修复后，hotfix 分支需要被合并到 master 和 develop 分支。这部分操作和 release 分支很像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.2.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.2.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.2.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix-1.2.1</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里并没有引入什么新的东西到分支模型，文章开头的图示被证明对我们的项目非常有帮助。它展现了一个易于理解的精致思维模型，并且使得团队成员能够理解整个项目的分支管理和发布过程。</p><blockquote><p>原文链接: <a target="_blank" rel="noopener" href="http://nvie.com/posts/a-successful-git-branching-model/?spm=a2c4e.11153940.blogcont68655.9.9277436ekX25Dp">http://nvie.com/posts/a-successful-git-branching-model/?spm=a2c4e.11153940.blogcont68655.9.9277436ekX25Dp</a><br>参考链接：<br><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/68655">https://yq.aliyun.com/articles/68655</a></p><p><a target="_blank" rel="noopener" href="http://nvie.com/posts/a-successful-git-branching-model/?spm=a2c4e.11153940.blogcont68655.9.9277436ekX25Dp">http://nvie.com/posts/a-successful-git-branching-model/?spm=a2c4e.11153940.blogcont68655.9.9277436ekX25Dp</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins-持续集成搭建</title>
      <link href="/2018/02/15/4d65d8dc7aa3.html"/>
      <url>/2018/02/15/4d65d8dc7aa3.html</url>
      
        <content type="html"><![CDATA[<p>平时做开发，关注得比较多的是具体的开发工作，等开发完成进行部署的时候，需要做一系列繁琐的工作，例如上传到测试平台等，这些事情的价值实在是没有多少，而且保不准哪时候就会出叉子；而且这次发版的一些信息也是相对闭塞的，基本上只有参与开发的人员可以得知。所以这些工作的自动化显得尤为必要，而 Jenkins 就是这样的一种工具，当然还有很多其他的，不过它比较流行且开源免费，非常适合团队自建。</p><span id="more"></span><blockquote><p>这里以 Gitlab、Android 为例来讲解，宿主机为 CentOS，所以关于 GItLab 的安装也就不说明了。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了避免在自己机器上配置不必要的环境，造成污染，这里使用 Docker 的来进行安装。关于 Docker 的使用，不是本文的重点。</p><p>选一个你喜欢的目录，创建一个 build_jenkins.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image rm jenkins:android -f</span><br><span class="line">docker build -t jenkins:android .</span><br></pre></td></tr></table></figure><p>接着创建一个 dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> jenkins/jenkins:<span class="number">2.107</span>-alpine</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer <span class="string">&quot;xinliugm@gmail.com&quot;</span></span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; apk upgrade \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="keyword">USER</span> jenkins</span><br><span class="line"><span class="keyword">ENV</span> ANDROID_HOME=/docker-android-home \</span><br><span class="line"> GRADLE_USER_HOME=/docker-gradle-home</span><br></pre></td></tr></table></figure><p>这里只需要关注最后两行，这里指定了两个环境变量，等会我们会创建相应的目录用于保存 SDK 和 gradle ，通过 Volumn 挂载到 Docker 容器上。</p><p>然后再创建一个 run_jenkins.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    --rm -u root -d -p 8080:8080 -p 50000:50000 \</span><br><span class="line">    -v /path2/docker-jenkins-home:/var/jenkins_home  \</span><br><span class="line">    -v /path2/docker-android-home:/docker-android-home \</span><br><span class="line">    -v /path2/docker-gradle-home:/docker-gradle-home \</span><br><span class="line">    jenkins:android</span><br></pre></td></tr></table></figure><p>接着几个目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir docker-jenkins-home docker-android-home docker-gradle-home</span><br></pre></td></tr></table></figure><p>最后创建一个 .dockerignore ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run_jenkins.sh</span><br><span class="line">build_jenkins.sh</span><br><span class="line">docker-gradle-home/</span><br><span class="line">docker-android-home/</span><br><span class="line">docker-jenkins-home/</span><br></pre></td></tr></table></figure><p>到这里，准备工作应该是已经做完了，不过因为这里是以 Android 为例，所以还要安装 AndroidSDK 到 docker-android-home，执行命令 <code>wget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip -O sdk.zip &amp;&amp; unzip sdk.zip -d ./docker-android-home </code>  ，更多的请查看 <a target="_blank" rel="noopener" href="http://xinsbackyard.tech/posts/cffbd71.html">Android SDK Manager 命令行工具使用</a> 。</p><h2 id="初次启动-Jenkins"><a href="#初次启动-Jenkins" class="headerlink" title="初次启动 Jenkins"></a>初次启动 Jenkins</h2><p>上一步已经把基本的配置完成了，接着尝试启动 Jenkins。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>执行  <code>./build_jenkins.sh</code> ，可能需要等几分钟，等执行完之后，执行 <code>docker images</code> 就可以看到我们构建好的镜像了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">jenkins             android             ba16d690f728        5 seconds ago       226MB</span><br><span class="line">jenkins/jenkins     2.107-alpine        e4a40fbe78e6        12 hours ago        223MB</span><br></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>执行 <code>./run_jenkins.sh</code> ，终端输出一段 id 后容器就在后台开始运行了，不过首次启动 jenkins 为了便于解决可能出现的坑，可以去掉脚本中的 <code>-d</code> 参数。</p><h3 id="访问-Jenkins"><a href="#访问-Jenkins" class="headerlink" title="访问 Jenkins"></a>访问 Jenkins</h3><p>打开浏览器访问 <code>http://localhost:8080</code> ，可以看到下面的界面：</p><p><img src="https://i.loli.net/2018/02/15/5a852df08d3cb.jpg"></p><p>按照提示，填入初始密码，点击 Continue 会让我们安装插件，选择推荐安装，安装好后会让你注册一个管理员账户：</p><p><img src="https://i.loli.net/2018/02/15/5a85353ca25f6.png"></p><p>这里邮件地址到后面还会有用，填的时候稍微认真点。点击 Save and Finish 后就进入到了 Jenkins 的主页了：</p><p><img src="https://i.loli.net/2018/02/15/5a85361cbc560.png"></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>到这里我们已经成功搭建并启动了 Jenkins，正式开始创建项目之前，除了默认安装的插件外，还有一些其他的插件需要安装。</p><p>点击 <code>Manage Jenkins</code> ，然后点击 <code>Manage Plugins</code> ，接着选中 <code>Available</code> Tab，在搜索框中输入 “Gitlab”，选中 “GitLab”、“GitLab Authentication” 以及 “GItLab Hook” 这三个插件，然后点击 <strong>install without restart</strong> 。</p><h2 id="SSH-公钥"><a href="#SSH-公钥" class="headerlink" title="SSH 公钥"></a>SSH 公钥</h2><p>为了使得每一个新建项目不用重复配置密钥啥的，我们创建一个全局的密钥用来访问 GItLab 上所有的仓库。</p><h3 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h3><p>首先需要生成 Jenkins 服务器的密钥，所以就要进入 docker 容器执行命令。</p><p>执行 <code>docker ps</code> 查看 jenkins 容器的 id，然后执行 <code>docker exec -it &lt;id&gt; /bin/bash</code> 就进入了容器分配的一个 shell，先执行 <code>su jenkins</code> 切换到 jenkins 用户， 最后就是执行生成密钥的命令了。</p><h3 id="部署密钥至-GitLab"><a href="#部署密钥至-GitLab" class="headerlink" title="部署密钥至 GitLab"></a>部署密钥至 GitLab</h3><p>使用管理员账户登录 GitLab，然后点击右上角的小扳手进入 <strong>Admin Area</strong> ，然后选择 <strong>Deploy Keys</strong> ，接下来添加进去就好了。</p><blockquote><p>也可以把SSH 公钥添加到自己的账户中，不过权限可能会有问题。</p></blockquote><h2 id="创建-Job"><a href="#创建-Job" class="headerlink" title="创建 Job"></a>创建 Job</h2><p>插件、密钥准备好后，就可以开始创建一个持续集成的项目了。</p><h3 id="配置-GitLab-仓库"><a href="#配置-GitLab-仓库" class="headerlink" title="配置 GitLab 仓库"></a>配置 GitLab 仓库</h3><p>我们前面配置好了 GitLab 上的公钥，不过还不能直接访问所有的项目，所以还要设置一下。进入到你项目的仓库面板，然后进入 <strong>Settings</strong> 界面，选中 <strong>Deploy Keys</strong> ，将上一节中添加的公钥添加（<strong>ENABLE</strong>）到你的项目中就可以了。</p><h3 id="创建-Jenkin-Job"><a href="#创建-Jenkin-Job" class="headerlink" title="创建 Jenkin Job"></a>创建 Jenkin Job</h3><p>点击 <strong>New Item</strong> ，随便输入个名字，选中 <strong>Freestyle Project</strong> ，点击 <strong>OK</strong> 就创建了一个坑位。</p><p><img src="https://i.loli.net/2018/02/16/5a86c657ea17d.png"></p><h3 id="配置-Job"><a href="#配置-Job" class="headerlink" title="配置 Job"></a>配置 Job</h3><p>上一步只是创建了一个坑位，接下来还需要配置源代码地址、触发器等。</p><h3 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h3><p>最重要的是源代码在哪里。选中 <strong>Source Code Managment</strong> ，选中 <strong>Git</strong> 单选按钮🔘。</p><p><img src="https://i.loli.net/2018/02/16/5a86cc53e12f4.png"></p><p><strong>Credential</strong> 选择 jenkins，这是 Jenkins 自带的，默认使用 <code>.ssh/id_rsa</code> 作为私钥，下面的代码分支看自己情况。</p><blockquote><p>这里 Jenkins 会自动尝试连接这个仓库，如果连接失败就提示错误，根据提示进行纠正就好了。</p></blockquote><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>然后选中 <strong>Build Trigger</strong> 选项卡，选中 <strong>Build when a change is pushed to GitLab.</strong> 。</p><p><img src="https://i.loli.net/2018/02/16/5a86ce82b6875.png"></p><p>提示信息里面指出，我们还需要设置 GitLab 仓库 WebHook，以便在提交代码到仓库的时候，GitLab 可以通知 Jenkins 开始构建。</p><p>所以接下来还需要再对 GitLab 项目进行配置，还是进入到 <strong>Settings</strong> ，然后选中 <strong>Web Hooks</strong> ，填入上一张图里面 <strong>URL</strong> 的值。</p><p><img src="https://i.loli.net/2018/02/16/5a86d004de28d.png"></p><p>这样就可以在提交代码到分支的时候进行构建了。</p><blockquote><p>因为我这里的 Jenkins 是跑的本地服务，而 GitLab 是已经上线的服务，所以触发器是无法正常工作的。</p></blockquote><h3 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h3><p>上面的算是完成基础配置，真正的构建配置还没有完成。选中 <strong>Build</strong> 选项卡，然后在 <strong>Add Build Step</strong> 下拉菜单中选中 <strong>Invoke Gradle Script</strong> 。</p><p><img src="https://i.loli.net/2018/02/16/5a86dadd835f5.png"></p><p>在 Tasks 框中填入要执行的 task 名称，就跟命令行执行 Gradle 命令差不多。</p><p>点击 <strong>Save</strong></p><blockquote><p>到这里，一个最简单的 Job 就算是创建好了</p></blockquote><h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><p>点击 <strong>Build Now</strong> 手动开始构建，然后会在下面看到出现一个构建任务，点击去可以查看更多信息，比如 <strong>Console Output</strong> 。</p><p><img src="https://i.loli.net/2018/02/16/5a86e72160612.png"></p><h3 id="镜像问题"><a href="#镜像问题" class="headerlink" title="镜像问题"></a>镜像问题</h3><p>可能你并没有看到的如上图中的输出，而是得到如下的错误输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &#x27;:app:mergeDebugResources&#x27;.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Error: java.util.concurrent.ExecutionException: java.lang.RuntimeException: No server to serve request. Check logs <span class="keyword">for</span> details.</span></span><br></pre></td></tr></table></figure><p>这是因为我们的镜像是基于 <strong>Alpine</strong> 的，缺少 aapt2 依赖的一些动态链接库，这些动态链接库本应该是包含在 glibc 里面的，但是 <strong>Alpine Linux</strong> 自带的 glibc 是精简版，所以还需要自己安装一个完整的 glibc。</p><p><a target="_blank" rel="noopener" href="https://github.com/sgerrand/alpine-pkg-glibc">GitHub</a>  上有打包好的安装包，直接拿来用就好，省得自己编译。按照 README 里面的说明，将 dockerfile 修改成如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> jenkins/jenkins:<span class="number">2.107</span>-alpine</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer <span class="string">&quot;xinliugm@gmail.com&quot;</span></span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"><span class="keyword">ENV</span> GLIBC_VERSION=<span class="number">2.27</span>-r0</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">        apk upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">        <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">        <span class="comment"># add curl for download</span></span></span><br><span class="line">        apk <span class="keyword">add</span><span class="language-bash"> curl &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">        <span class="comment"># download packages for glibc, see https://github.com/sgerrand/alpine-pkg-glibc for more info</span></span></span><br><span class="line">        curl -L -o glibc-$&#123;GLIBC_VERSION&#125;.apk \</span><br><span class="line">        <span class="string">&quot;https://github.com/sgerrand/alpine-pkg-glibc/releases/download/$&#123;GLIBC_VERSION&#125;/glibc-$&#123;GLIBC_VERSION&#125;.apk&quot;</span> &amp;&amp; \</span><br><span class="line">        curl -L -o glibc-bin-$&#123;GLIBC_VERSION&#125;.apk \</span><br><span class="line">        <span class="string">&quot;https://github.com/sgerrand/alpine-pkg-glibc/releases/download/$&#123;GLIBC_VERSION&#125;/glibc-bin-$&#123;GLIBC_VERSION&#125;.apk&quot;</span> &amp;&amp; \</span><br><span class="line">        <span class="comment"># install them</span></span><br><span class="line">        apk <span class="keyword">add</span><span class="language-bash"> --allow-untrusted glibc-<span class="variable">$&#123;GLIBC_VERSION&#125;</span>.apk glibc-bin-<span class="variable">$&#123;GLIBC_VERSION&#125;</span>.apk &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">        <span class="comment"># remove curl</span></span></span><br><span class="line">        apk del curl &amp;&amp; \</span><br><span class="line">        <span class="comment"># remove cache and downloaded files</span></span><br><span class="line">        rm -fr glibc-$&#123;GLIBC_VERSION&#125;.apk glibc-bin-$&#123;GLIBC_VERSION&#125;.apk /var/cache/apk/*</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> ANDROID_HOME=/docker-android-home \</span><br><span class="line"> GRADLE_USER_HOME=/docker-gradle-home</span><br><span class="line"><span class="keyword">USER</span> jenkins</span><br></pre></td></tr></table></figure><p>如果没什么问题就能够正常编译了。</p><blockquote><p>后续配置等有时间了再来补充吧</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
            <tag> Gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOSP (Android 9.0.0)源码下载</title>
      <link href="/2018/01/30/73f50b0ecf8a.html"/>
      <url>/2018/01/30/73f50b0ecf8a.html</url>
      
        <content type="html"><![CDATA[<p>现在学习 Android 不像早些年，会写个 App 就能找到饭碗，如今不看看 Framework 源码有种分分钟掉队的感觉。虽然现在有一些比较优秀的站点提供源码阅读，但是毕竟在浏览器里面阅读，还是会遇到很多限制，最好还是自己下载一份。说道下载问题就来了，AOSP 的仓库被墙了，所以直接不能直接下载，或者说直接下载网速会很慢，还好国内有一些镜像服务可以避免这一问题。</p><span id="more"></span><blockquote><p>之前用 Ubuntu 直接挂个 SS 就能以 2M&#x2F;s 速度同步源码，但是最近在 Mac 就死活没得办法了。这里我们使用 <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">清华</a> 的源，不过它给的帮助文档似乎并不能直接照搬。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>准备一块至少 100G 空闲的磁盘作为下载盘（大一点准没错，强烈建议下载到移动硬盘里）。然后 AOSP 编译环境要求 <strong>大小写敏感（Case-Sensitive）</strong> ，所以先格式化：</p><p><img src="https://i.loli.net/2018/08/18/5b77070486e19.png"></p><p>然后在这个磁盘（分区）上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> AOSP &amp;&amp; <span class="built_in">cd</span> AOSP</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> android-9.0.0_r1</span></span><br></pre></td></tr></table></figure><p>我们这次下载的是 Android 9.0.0 的源码，所以目录就命名成这样，你也可以选择你喜欢的名字！</p><h2 id="下载-repo-工具"><a href="#下载-repo-工具" class="headerlink" title="下载 repo 工具"></a>下载 repo 工具</h2><p>整个 AOSP 还是非常巨大的，所以就会把整个项目拆分成许多的版本管理仓库，这么多仓库需要通过工具来进行管理，也就是这里要下载的 repo 工具。执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> AOSP</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> a+x repo <span class="comment"># 添加可执行权限</span></span></span><br></pre></td></tr></table></figure><p>因为不太喜欢入侵性太强的配置，就不按照官网的配置来弄了，等会直接通过相对路径来引用 <code>repo</code> 。</p><p>这个时候 <code>repo</code> 还是从 Google 的站点进行下载，所以还要简单修改一下。使用文本编辑器打开 repo，然后将开头的 <code>REPO_URL</code> 字段值替换成  <code>https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/</code> 。</p><h2 id="初始化-repo"><a href="#初始化-repo" class="headerlink" title="初始化 repo"></a>初始化 repo</h2><p>默认情况下，通过 repo 同步的将会是整个 AOSP 源码，即各种版本的源码都有，这里我们通过 <code>-b</code> 来指定 Android 9.0.0 分支。<a target="_blank" rel="noopener" href="https://source.android.com/setup/build-numbers#source-code-tags-and-builds">其他可选分支</a> 。</p><p>然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> android-9.0.0_r1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">../repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r1</span></span><br></pre></td></tr></table></figure><p>终端可能会输出一两句警告信息，忽略就好了。</p><h2 id="开始下载"><a href="#开始下载" class="headerlink" title="开始下载"></a>开始下载</h2><p>初始化工作已经完成，可以直接开始下载源码了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> android-9.0.0_r1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">../repo <span class="built_in">sync</span></span></span><br></pre></td></tr></table></figure><p>一般来讲，接下来的几小时至一整晚的时间内可以不鸟它了，但是下载可能会因为某些问题而中断，所以还要时不时瞄一眼，所以我们写个重试的脚本 <code>sync.sh</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">time=1</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    ../repo sync</span><br><span class="line">    if [ $? == 0 ]</span><br><span class="line">    then</span><br><span class="line">        break</span><br><span class="line">    else</span><br><span class="line">        time=`expr $time + 1`</span><br><span class="line">        echo &#x27;sync failed retry!!&#x27;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line">echo &#x27;tried &#x27;$&#123;time&#125;&#x27; times&#x27;</span><br></pre></td></tr></table></figure><p><code>$?</code> 中保存的是上一条名命令的执行结果状态，<strong>0</strong> 表示成功，<strong>not 0</strong> 表示失败，所以直接简单粗暴地开个死循环，每次执行 <code>../repo sync</code> 之后判断状态，然后决定是否要重试。不过这并不能完美解决我们的问题，因为有时失败后需要删除一个 <code>*.lock</code> 文件，否则还会在相同的地方失败；并且这个脚本一旦开启只有下载成功才会终止，<code>Ctrl+C</code> 也不能终止，只能杀死进程。<br>如果网络条件不是很好的话，建议挂晚上下载。</p><h2 id="导入-AS"><a href="#导入-AS" class="headerlink" title="导入 AS"></a>导入 AS</h2><p>源码下载下来后，因为我们只是想阅读源码，所以不用按照官网的上的指引直接执行 <code>make</code> ，那样会导致编译整个工程，等不起。</p><p>执行下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> android-9.0.0_r1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make idegen</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">development/tools/idegen/idegen.sh</span></span><br></pre></td></tr></table></figure><p>执行第一条命令会有如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">============================================</span><br><span class="line">PLATFORM_VERSION_CODENAME=REL</span><br><span class="line">PLATFORM_VERSION=9</span><br><span class="line">TARGET_PRODUCT=aosp_arm</span><br><span class="line">TARGET_BUILD_VARIANT=eng</span><br><span class="line">TARGET_BUILD_TYPE=release</span><br><span class="line">TARGET_ARCH=arm</span><br><span class="line">TARGET_ARCH_VARIANT=armv7-a-neon</span><br><span class="line">TARGET_CPU_VARIANT=generic</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_2ND_ARCH=x86</span><br><span class="line">HOST_OS=darwin</span><br><span class="line">HOST_OS_EXTRA=Darwin-18.0.0-x86_64-10.14</span><br><span class="line">HOST_BUILD_TYPE=release</span><br><span class="line">BUILD_ID=PPR1.180610.009</span><br><span class="line">OUT_DIR=out</span><br><span class="line">============================================</span><br><span class="line">[1/1] out/soong/.minibootstrap/minibp out/soong/.bootstrap/build.ninja</span><br><span class="line">[55/56] glob prebuilts/ndk/stl.bp</span><br><span class="line">[77/77] out/soong/.bootstrap/bin/soong_build out/soong/build.ninja</span><br><span class="line">out/build-aosp_arm-cleanspec.ninja is missing, regenerating...</span><br><span class="line">out/build-aosp_arm.ninja is missing, regenerating...</span><br><span class="line">[2/934] including art/Android.mk ...</span><br><span class="line">art/build/Android.common.mk:50: warning: unsupported HOST_ARCH=x86_64</span><br><span class="line">[564/934] including system/sepolicy/Android.mk ...</span><br><span class="line">system/sepolicy/Android.mk:79: warning: BOARD_SEPOLICY_VERS not specified, assuming current platform version</span><br><span class="line">[934/934] including tools/tradefederation/core/Android.mk ...</span><br><span class="line">art/build/Android.gtest.mk:121: warning: overriding commands for target `Uncompressed&#x27;</span><br><span class="line">art/build/Android.gtest.mk:101: warning: ignoring old commands for target `Uncompressed&#x27;</span><br><span class="line">[ 99% 919/920] glob tools/tradefederation/core/python-lib/tradefed_py/*.py</span><br><span class="line"><span class="meta prompt_">[100% </span><span class="language-bash">38/38] Install: out/host/darwin-x86/framework/idegen.jar</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里输出了一些配置信息，然后后面做了一些预处理，这里有个新词 <strong>ninja</strong> ，这是一个新的构建工具，关于它和 Makefile 的区别，可以看 <a target="_blank" rel="noopener" href="http://note.qidong.name/2017/08/android-ninja/">这里</a> 。</p></blockquote><p>执行第二条命令会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Read excludes: 77ms</span><br><span class="line">Traversed tree: 146534ms</span><br></pre></td></tr></table></figure><p>执行完之后，会在工程根目录产生 <code>android.ipr</code> 、<code>android.iml</code> 文件，然后就可以使用 AS 打开 <code>android.ipr</code> 文件来导入工程了。</p><p>如果 macOS 出现了下面的错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">internal error: Could not find a supported mac sdk: [&quot;10.10&quot; &quot;10.11&quot; &quot;10.12&quot; &quot;10.13&quot; &quot;10.14&quot;]</span><br><span class="line">internal error: Could not find a supported mac sdk: [&quot;10.10&quot; &quot;10.11&quot; &quot;10.12&quot; &quot;10.13&quot; &quot;10.14&quot;]</span><br></pre></td></tr></table></figure><p>其实只是编译工具里没有明确支持说明 macOS 版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">macOS 10.15 上有如下输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DriverKit19.0.sdk MacOSX.sdk        MacOSX10.15.sdk</span></span><br></pre></td></tr></table></figure><p>查看 build&#x2F;soong&#x2F;cc&#x2F;config&#x2F;x86_darwin_host.go#darwinSupportedSdkVersions 定义发现没有 10.15:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">darwinSupportedSdkVersions = []<span class="type">string</span>&#123;</span><br><span class="line">                <span class="string">&quot;10.10&quot;</span>,</span><br><span class="line">                <span class="string">&quot;10.11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;10.12&quot;</span>,</span><br><span class="line">                <span class="string">&quot;10.13&quot;</span>,</span><br><span class="line">                <span class="string">&quot;10.14&quot;</span>,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在后面加上 10.15 就可以了。</p><blockquote><p>如果并不是想看整个 AOSP 的代码，可以在执行这两条命令之前把自己想要排除的目录或者文件添加到 <code>development/tools/idegen/excluded-paths</code> 中，比如我就把 packages 文件夹忽略了，更多的信息可以看一下 <code>development/tools/idegen/README</code> 文件。<br>编译环境方面，一般来讲新版本 AOSP 和最新的 Mac&#x2F;Linux 系统版本都不会出现环境问题，但是在出现新系统编译旧 AOSP 代码就极有可能出现一些环境错误，比如需要安装 JDK6。这个时候莫要慌，如果不介意在电脑上装一些环境可以按照错误来配置，介意的话，可以装个 Ubuntu 虚拟机来编译，或者更轻量的 Docker</p></blockquote><blockquote><p>如果是 <strong>4.4</strong> 的源码，可以使用我构建好的镜像进行编译: <code>docker run --rm -v /path/to/aosp/source:/android-4.4 dashmrl/aosp-builder-4.4</code></p></blockquote><h2 id="AS-阅读体验"><a href="#AS-阅读体验" class="headerlink" title="AS 阅读体验"></a>AS 阅读体验</h2><blockquote><p>AS 首次打开这么一个工程真的非常耗时，主要是在做一些 index 操作，我的 MBP15 花了 20min 才完成，所以没有下定决定看源码之前，就不要打开这个工程了，然后也不要轻易关闭这个工程QAQ…</p></blockquote><blockquote><p>还有可能会遇到 OOM 的问题，可以看看 <a target="_blank" rel="noopener" href="http://www.2net.co.uk/blog/jack-server.html">这里</a></p></blockquote><p>工程导入后还会遇上一些其他问题，如果发现 IDE 提示文件行数太大、大小写，可以配置一下 IDE 属性，选择 Help 顶部菜单，然后选择 Edit Custom Properties，然后填入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 不够就 100000</span><br><span class="line">idea.max.intellisense.filesize=10000</span><br><span class="line">idea.case.sensitive.fs=true</span><br></pre></td></tr></table></figure><p>这时候还有可能会出现点击某个类，但是跳转到类 SDK 代码里，而不是 AOSP 的代码，所以这里在配置一下 SDK。<br>选择 File-&gt;Project Structure，然后选中 Module：<br><img src="https://i.loli.net/2018/08/18/5b77070b4509e.png"><br>选择对应 Module SDK，这里 Android P 就选 28，然后按照图中删除其余的包，保存。</p><p>这时候有一些类或方法还是红的不能跳转，大部分原因是因为有 <code>@hide</code> 　注释，不过影响也不大。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 免密登录</title>
      <link href="/2018/01/27/c9f65d0de6f6.html"/>
      <url>/2018/01/27/c9f65d0de6f6.html</url>
      
        <content type="html"><![CDATA[<p>今天重装 CentOS 后发现按照之前的步骤来配置 SSH 后一直提示 <code>Permission denied</code> ，第一反应反应就是 <code>/etc/ssh/sshd_config</code> 配置出错，但是仔细检查一遍之后并没有发现什么错误。后来网上找到原因是权限问题，赶快记笔记，防止以后再遇上这个坑而不知道。</p><span id="more"></span><blockquote><p>索性把配置 SSH 服务端的流程都过一遍，这里以 CentOS 为例，其它发行版只是包管理器的差别。</p></blockquote><h2 id="安装-openssh"><a href="#安装-openssh" class="headerlink" title="安装 openssh"></a>安装 openssh</h2><p>这一步一般情况下不需要，以为几乎全部的 Linux 发行版都自带的 SSH。当然，如果机器上没有安装，可以手动安装。</p><p>在服务器上执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install -y vim openssh net-tools</span></span><br></pre></td></tr></table></figure><p>这里除了安装 openssh 之外还安装 vim 用来修改配置文件以及 net-tools 获取服务器的公网&#x2F;内网 IP。</p><h2 id="创建-SSH-密钥"><a href="#创建-SSH-密钥" class="headerlink" title="创建 SSH 密钥"></a>创建 SSH 密钥</h2><p>要实现免密登录，我们需要把自己机器（这里使用的是MacOS，其它平台一样）产生的 SSH 公钥部署到服务器上。回到客户端，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;your identification&quot;</span></span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/dashmrl/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /Users/dashmrl/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /Users/dashmrl/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:FswSkdc/aU/axbfdudyclEbzuAXW1+hiYDeWsOJtplw 2333</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|      oo .       |</span><br><span class="line">|      .+. o      |</span><br><span class="line">|      ..+  + o +.|</span><br><span class="line">|       ...+ X =oB|</span><br><span class="line">|       .S+ = X.+@|</span><br><span class="line">|       .. E + =*=|</span><br><span class="line">|       . = . .+++|</span><br><span class="line">|        o     .+o|</span><br><span class="line">|                 |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>选择默认的路径和文件保存密钥对，提示输入 passphrase 时，可以直接回车不设置，但 <strong>更好的实践方式</strong> 还是设置一个密码来提高安全性。执行完后会在 <code>~/.ssh</code> 目录下生成两个文件：<code>id_rsa</code> 、 <code>id_rsa.pub</code> ，第二个文件就是我们需要部署到服务器上的公钥。</p><blockquote><p> 使用 GitHub 应该都会经过这一步骤</p></blockquote><h2 id="部署本机-SSH-公钥"><a href="#部署本机-SSH-公钥" class="headerlink" title="部署本机 SSH 公钥"></a>部署本机 SSH 公钥</h2><p>SSH 服务端有了，客户端密钥也有了，还需要把公钥部署到服务器上才可以实现 SSH 秘钥登录。先登录服务器，执行 <code>ifconfig</code> 获取到 IP 地址，然后在 <strong>客户端</strong> 执行 <code>ssh &lt;servername&gt;@&lt;ip&gt;</code> 进行登录，这时候是可以通过 &lt;servername&gt; 的密码进行登录的。</p><p>登录后，执行 <code>sudo vim /etc/ssh/sshd_config</code> 打开 SSH 服务端配置文件，搜索 <code>PubkeyAuthentication</code> ，修改值为 <code>yes</code> ，搜索 <code>PasswordAuthentication</code> ，修改值为 <code>no</code> ，最后搜索 <code>PermitRootLogin</code> 并修改为 <code>no</code> ，然后保存。实现的效果是不允许使用密码登录，不予许使用 root 用户进行登录，只可以使用 <strong>公钥</strong> 的方式进行登录。</p><p>在配置文件中还可以看到 <code>AuthorizedKeysFile    .ssh/authorized_keys</code> 这样的键值对，这里指明了保存公钥的文件路劲。那么接着执行 <code>mkdir ~/.ssh &amp;&amp; touch ~/.ssh/authorized_keys</code> 来创建保存公钥的文件，然后打开它 <code>vim ~/.ssh/authorized_keys</code> ，把客户端生成公钥粘贴进去，保存即可。</p><p>然后执行 <code>sudo service sshd restart</code> 重启 SSH 服务。</p><p>核心的步骤到这里就都完成了。</p><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>完成到上一步理论上免密登录的基础就打好了，但是这时登录会提示 <code>Permission denied XXX</code> ，这其实是 <code>.ssh</code> 目录的权限问题， 所以造成了 SSH 不认可这个目录及里面的文件。所以还需要修改权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 700 ~/.ssh &amp;&amp; <span class="built_in">chmod</span> 0600 ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure><p>完成后就可以开心的使用 SSH 公钥进行服务器登录了。</p><blockquote><p>踩了一个坑，对 SSH 的了解更多，然后也发现自己在 Linux 权限方面的不足</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 下 Terminal + zsh 配置</title>
      <link href="/2018/01/25/cf2d04ac09ae.html"/>
      <url>/2018/01/25/cf2d04ac09ae.html</url>
      
        <content type="html"><![CDATA[<p>之前一直用 Ubuntu 自带的 Bash，没有去配置什么插件，感觉用着也还行，现在换到 MacOS 的 Terminal 下，发现它默认配置真的没有 Ubuntu 的好看，为了能更加快乐的使用终端，还是决定去捣鼓一番。</p><span id="more"></span><p>MacOS 自带应用不像 Linux 那样，想删就能删除，又不喜欢安装两个功能相同的应用，就直接使用自带的 Terminal。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://i.loli.net/2018/01/25/5a69ac7d978af.png"></p><p>​</p><h2 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h2><p>MacOS 自带了 zsh，可能不是最新版本，不过没影响，其它平台使用各自的包管理器进行安装就👌了。</p><p>先看看系统都提供哪些 shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/shells</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">List of acceptable shells <span class="keyword">for</span> chpass(1).</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ftpd will not allow <span class="built_in">users</span> to connect <span class="built_in">who</span> are not using</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">one of these shells.</span></span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p>这里看到 zsh 已经安装了，接着替换系统默认的 shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chsh -s /bin/zsh</span></span><br></pre></td></tr></table></figure><p>可能会要求输入密码，输入就好了，重启终端就可以看到效果了。</p><h2 id="安装-Oh-my-zsh"><a href="#安装-Oh-my-zsh" class="headerlink" title="安装 Oh my zsh"></a>安装 Oh my zsh</h2><p>简单替换 zsh 虽然能用，但是还是有点丑，通过 <a target="_blank" rel="noopener" href="http://ohmyz.sh/">oh my zsh</a> 来配置。</p><p>安装也很简单（也叫不上安装）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>执行完后会在用户目录下创建一些默认配置文件，同时也会看到命令提示符发生了变化。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>通过 <a target="_blank" rel="noopener" href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes">主题</a> 让它再更好看点。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>这里选用 <code>agnoster</code> 主题的变种 <a target="_blank" rel="noopener" href="https://github.com/zakaziko99/agnosterzak-ohmyzsh-theme">agnosterzak</a> ，因为有一些特殊字符显示问题，需要先安装 <code>Powerline compatible</code> 字体：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://github.com/powerline/fonts/raw/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf -o Meslo_LG_M_Regular_for_Powerline.ttf &amp;&amp; open Meslo_LG_M_Regular_for_Powerline.ttf</span></span><br></pre></td></tr></table></figure><p>这里只安装一个字体就行了。</p><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p>效果图中有色块，所以配色就显得尤为重要，没选好就可能极其辣眼睛，这个 <a target="_blank" rel="noopener" href="https://github.com/mbadolato/iTerm2-Color-Schemes">仓库</a> 有很多配色，根据自己的喜好选一种就好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://github.com/mbadolato/iTerm2-Color-Schemes/raw/master/terminal/Solarized%20Dark%20Higher%20Contrast.terminal -o Solarized_Dark_Higher_Contrast.terminal</span></span><br></pre></td></tr></table></figure><p>下载好后进入 Terminal 的 Preference（偏好设置）进行导入并设为默认就 👌 了。</p><p><img src="https://i.loli.net/2018/01/25/5a69b2abb611d.png"></p><p>然后把字体改为之前安装好的。</p><h3 id="zsh-主题"><a href="#zsh-主题" class="headerlink" title="zsh 主题"></a>zsh 主题</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/themes &amp;&amp; curl http://raw.github.com/zakaziko99/agnosterzak-ohmyzsh-theme/master/agnosterzak.zsh-theme -o <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/themes/agnosterzak.zsh-theme</span></span><br></pre></td></tr></table></figure><p>然后修改 .zshrc 文件，将变量 ZSH_THEME 设为 agnosterzak：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set name of the theme to load. Optionally, <span class="keyword">if</span> you <span class="built_in">set</span> this to <span class="string">&quot;random&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it<span class="string">&#x27;ll load a random theme each time that oh-my-zsh is loaded.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">See https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</span></span></span><br><span class="line">ZSH_THEME=&quot;agnosterzak&quot;</span><br></pre></td></tr></table></figure><p>重启终端，就能看到和文章开头差不多的效果了。</p><h2 id="其它定制"><a href="#其它定制" class="headerlink" title="其它定制"></a>其它定制</h2><p>到现在效果已经挺棒的了，不过还是根据自己的情况作了一些定制化。主要还是改主题，因为我也不是很喜欢安装太多插件。</p><p><strong>隐藏电量</strong></p><p>这个是第一眼看上去就觉得没有太多价值的信息，所以应该要去掉。</p><p>修改 agnosterzak.zsh-theme 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/themes/agnosterzak.zsh-theme</span></span><br></pre></td></tr></table></figure><p>滑到底部然后把电池相关的配置注释掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Main prompt</span></span></span><br><span class="line">build_prompt() &#123;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo -n &quot;\n&quot;</span><br><span class="line">   prompt_status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> prompt_battery</span></span><br><span class="line">   prompt_time</span><br><span class="line">   prompt_virtualenv</span><br><span class="line">   prompt_dir</span><br><span class="line">   prompt_git</span><br><span class="line">   prompt_hg</span><br><span class="line">   prompt_end</span><br><span class="line">   CURRENT_BG=&#x27;NONE&#x27;</span><br><span class="line">   echo -n &quot;\n&quot;</span><br><span class="line">   prompt_context</span><br><span class="line">   prompt_end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缩短当前工作空间路径</strong></p><p>很多情况下，完整路径是没有太多作用，所以只保留最具价值的部分——当前目录名，修改 agnosterzak.zsh-theme 文件，找到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Dir: current working directory</span></span><br><span class="line">prompt_dir() &#123;</span><br><span class="line">  prompt_segment cyan white &quot;%&#123;$fg_bold[white]%&#125;%~%&#123;$fg_no_bold[white]%&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 <code>%~</code> 改成 <code>%c</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Dir: current working directory</span></span><br><span class="line">prompt_dir() &#123;</span><br><span class="line">  prompt_segment cyan white &quot;%&#123;$fg_bold[white]%&#125;%c%&#123;$fg_no_bold[white]%&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改用户@设备名配色</strong></p><p>打开 agnosterzak.zsh-theme，找到 <code>prompt_context</code> ：然后修改成下面的样子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Context: user@hostname (<span class="built_in">who</span> am I and <span class="built_in">where</span> am I)</span></span><br><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment magenta white &quot;%&#123;$fg_bold[white]%(!.%&#123;%F&#123;white&#125;%&#125;.)%&#125;$USER@%m%&#123;$fg_no_bold[white]%&#125;&quot;</span><br><span class="line">  else</span><br><span class="line">    prompt_segment magenta white &quot;%&#123;$fg_bold[white]%(!.%&#123;%F&#123;white&#125;%&#125;.)%&#125;@$USER%&#123;$fg_no_bold[white]%&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实只是更改了第6行的配色。</p><p>改完后执行 <code>source ~/.zshrc</code> 就可以看到效果图中的终端了。</p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android SDK Manager 命令行工具使用</title>
      <link href="/2018/01/16/53150f26f1ec.html"/>
      <url>/2018/01/16/53150f26f1ec.html</url>
      
        <content type="html"><![CDATA[<p>一般情况下，我们都是通过 Android Studio 来进行 Android SDK 的管理的，更新啥的都是点点鼠标完成了，当然，我们知道 AS 只是做了一个封装。不过有时候，我们只是想安装更新，并不想启动 AS，那么这时候通过命令行就会轻量很多；在 CI 中，更加是没有 AS 的，那么这时候命令行操作成为了唯一的选择。</p><span id="more"></span><p>在 sdk 25.2.3 及以上，Android SDK 提供的了 <code>android_home/tools/bin/sdkmanager</code> 来代替原来的 <code>android</code> 。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>先进入到 <code>android_home/tools/bin/sdkmanager</code> 来看看 <code>sdkmanager</code> 提供哪些操作选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sdkmanager --<span class="built_in">help</span></span></span><br><span class="line">Usage:</span><br><span class="line">  sdkmanager [--uninstall] [&lt;common args&gt;] [--package_file=&lt;file&gt;] [&lt;packages&gt;...]</span><br><span class="line">  sdkmanager --update [&lt;common args&gt;]</span><br><span class="line">  sdkmanager --list [&lt;common args&gt;]</span><br><span class="line">  sdkmanager --licenses [&lt;common args&gt;]</span><br><span class="line">  sdkmanager --version</span><br></pre></td></tr></table></figure><p>这里看到 sdkmanager 只提供的几个操作，所以学习成本还是很少的，下面挨个学个遍。</p><h2 id="显示-package"><a href="#显示-package" class="headerlink" title="显示 package"></a>显示 package</h2><p>执行 <code>./sdkmanager --list</code> 就能显示 <strong>已安装</strong> 和 <strong>可安装</strong> 的包。<br><img src="https://i.loli.net/2018/01/26/5a6a0fd31ef55.png"></p><h2 id="安装-package"><a href="#安装-package" class="headerlink" title="安装 package"></a>安装 package</h2><p>执行 <code>./sdkmanager &lt;packages&gt;</code> 就能安装指定的包了，其中 <packages> 替换成你要安装的包，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sdkmanager <span class="string">&quot;build-tools;27.0.3&quot;</span> <span class="string">&quot;tools&quot;</span></span></span><br></pre></td></tr></table></figure><p>这里包名就是 <code>--list</code> 输出中的 <strong>Path</strong> 。</p><p>如果要安装的包很多，手动输这么包名肯定要疯了，而且每次 安装&#x2F;更新 都要输一遍，sdk 也提供一个使用配置文件的方式来安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sdkmanager --package_file=packages.txt</span><br></pre></td></tr></table></figure><p>只需要提供一个 <code>packages.txt</code> 文件就可以简化安装多个包的命令了，这个文件里面的内容就是你所要安装的所有包名，一个包占一行，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">patcher;v4</span><br><span class="line">platforms;android-27</span><br><span class="line">build-tools;27.0.3</span><br><span class="line">platform-tools</span><br><span class="line">tools</span><br><span class="line">lldb;3.0</span><br><span class="line">cmake;3.6.4111459</span><br><span class="line">ndk-bundle</span><br><span class="line">extras;android;m2repository</span><br><span class="line">extras;google;m2repository</span><br><span class="line">extras;m2repository;com;android;support;constraint;constraint-layout-solver;1.0.2</span><br><span class="line">extras;m2repository;com;android;support;constraint;constraint-layout;1.0.2</span><br><span class="line">emulator</span><br><span class="line">system-images;android-27;google_apis;x86</span><br></pre></td></tr></table></figure><h2 id="卸载-package"><a href="#卸载-package" class="headerlink" title="卸载 package"></a>卸载 package</h2><p>执行 <code>./sdkmanager --uninstall &lt;packages&gt;</code> 可以卸载指定的 package，和安装过程类似，也支持通过配置文件来卸载。</p><h2 id="更新-package"><a href="#更新-package" class="headerlink" title="更新 package"></a>更新 package</h2><p>执行 <code>./sdkmanager --update</code> 就可以升级所有已安装的 package。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>执行 <code>./sdkmanager --licenses</code> 可以显示所有可安装包的但是没有同意的协议，并且提供一个接受的选项。<br>建议在安装之前执行一遍。</p><p>执行 <code>./sdkmanager --version</code> 显示信息，没啥好说的。</p><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>sdkmanager 每条命令都提供一些命名参数，下面直接通过表格给出：</p><table><thead><tr><th align="left">Options</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–sdk_root&#x3D;path</td><td align="left">相当于覆盖 ANDROID_HOME 的值，下载到指定的 SDK 目录 ，不过一般情况下不会使用这个</td></tr><tr><td align="left">–channel&#x3D;channel_id</td><td align="left">可选值 {0,1,2,3}，分别代表 {Stable,Beta,Dev,Cannary}</td></tr><tr><td align="left">–include_obsolete</td><td align="left">用于 <code>--list</code> 和 <code>--update</code>，是否显示一些过时的package</td></tr><tr><td align="left">–no_https</td><td align="left">强制使用 HTTP 而不是 HTTPS 进行传输</td></tr><tr><td align="left">–verbose</td><td align="left">啰嗦模式，输出详细信息</td></tr><tr><td align="left">–proxy&#x3D;{http &amp;#124; socks}</td><td align="left">指定代理模式</td></tr><tr><td align="left">–proxy_host&#x3D;{IP_address &amp;#124; DNS_address}</td><td align="left">代理服务器的 IP 地址</td></tr><tr><td align="left">–proxy_port&#x3D;port_number</td><td align="left">代理服务器端口</td></tr></tbody></table><blockquote><p>Note: 如果想要安装一个非当前平台的 package , 可以设置环境变量 <code>REPO_OS_OVERRIDE</code> 的值（{“windows”, “macosx”,”linux”}）来指定。</p></blockquote><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>最常见的操作就是安装和更新，卸载除了在某些磁盘空间极其紧张的情况下是不太可能会执行的，所以这里针对这两个操作做一些简单的配置。</p><p><code>sdkmanager</code> 有一点比较坑，就是通过配置文件指定需要安装&#x2F;更新的包，执行完后会把配置文件删除，所以最好每次拷贝一下在进行操作。<br>为了方便的操作，我们可以在 <code>ANDROID_HOME</code> 目录下添加三个文件：packages.txt、install_packages.sh、update_packages.sh 来简化操作。</p><p>直接看代码，先看 install_packages.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存当前路径</span></span><br><span class="line">cwd=`pwd`</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件</span></span><br><span class="line">package_file=packages.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sdkmanager 所在的相对路径</span></span><br><span class="line">manager_dir=tools/bin/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝一份配置文件到 sdkmanager 所在目录</span></span><br><span class="line">cp $&#123;package_file&#125; $&#123;manager_dir&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 sdkmanager 所在目录</span></span><br><span class="line">cd $&#123;manager_dir&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先签一下不平等条款</span></span><br><span class="line">./sdkmanager --licenses</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看看 sdkmanager 信息</span></span><br><span class="line">./sdkmanager --version</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逐个安装 package</span></span><br><span class="line">for p in $(cat $&#123;package_file&#125;)</span><br><span class="line">do</span><br><span class="line">    ./sdkmanager &quot;$&#123;p&#125;&quot; --verbose --no_https</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回到之前的目录</span></span><br><span class="line">cd $&#123;cwd&#125;</span><br></pre></td></tr></table></figure><p>再看 update_packages.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">cwd=`pwd`</span><br><span class="line">manager_dir=tools/bin/</span><br><span class="line">cd $&#123;manager_dir&#125;</span><br><span class="line">./sdkmanager --update --verbose --no_https</span><br><span class="line">cd $&#123;cwd&#125;</span><br></pre></td></tr></table></figure><p>这个比安装的简单多了，就不赘述了。</p><blockquote><p>最近在搭建 Jenkins 时候，因为是登录到了真实的服务器上进行操作，意外地发现被墙了，泣不成声。然后想到了国内的镜像服务，不过都失败了，最后在 <a target="_blank" rel="noopener" href="http://blog.csdn.net/lq18111292117/article/details/53447479">这里</a> 找到了答案。</p><p>访问 <a target="_blank" rel="noopener" href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> ，然后测试 dl.google.com ，把你所在地区对应的 IP 写入 <code>/etc/hosts</code> ，然后重新执行命令就好了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android SDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>撸个简单的 JSbridge</title>
      <link href="/2018/01/09/766c3d4ae9f8.html"/>
      <url>/2018/01/09/766c3d4ae9f8.html</url>
      
        <content type="html"><![CDATA[<p>这两年 Web 技术栈一直在努力地向移动端和后端延展（这里没有引战的意思），当然这也是技术发展所带来的必然结果。移动互联网早期主要以原生开发为主，但到现在，业务不断发展，版本也需要快速迭代，原生开发效率很明显难以跟上，这时候 Web 开发的优势就显现出来了。</p><span id="more"></span><p>（废话讲的差不多了）</p><h2 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h2><p>Hybrid App 中文名叫：混合App，即原生应用和 WebApp 的结合体，它兼顾了 <strong>原生应用</strong> 的体验和 <strong>WebApp</strong> 的开发效率（这里定义应该是狭义的）。<br>最常见的 Hybrid 的实现方式是通过 JSBridge 来打通 Native Code 和 JavaScript 之间的隔阂。<br>这篇文章中我们一起来简单实现一个 JSBridge。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>在 Android 上实现 Hybrid 是通过 Webview 来实现的，所以下面再简单过一下 Webview 的一些基本知识。</p><h3 id="Webview"><a href="#Webview" class="headerlink" title="Webview"></a>Webview</h3><p>通常我们会使用 <code>webview.loadUrl(url)</code> 来加载一个页面，这个方法还可以用来执行 JS 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webview.loadUrl(<span class="string">&quot;javascript:console.log\(called by Native\)&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里通过 <code>javascript</code> 这个伪协议来调用或执行 JS 代码。</p><h3 id="WebSettings"><a href="#WebSettings" class="headerlink" title="WebSettings"></a>WebSettings</h3><p>这个类主要是完成 Webview 的一些配置工作，比如允许执行 JS。要实现 JSBridge ，就必须允许执行 JS。</p><h3 id="WebviewClient"><a href="#WebviewClient" class="headerlink" title="WebviewClient"></a>WebviewClient</h3><p>这个类会收到 JS 环境中的各种事件，比如资源请求、页面加载完成、点击了一个链接等。</p><h3 id="WebChromeClient"><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a>WebChromeClient</h3><p>这个类主要用来辅助 WebView 进行一些界面上的工作，比如弹出对话框等。</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>要实现 JSBridge ，还得提供一条合适的通信通道，目前主要方式有三种：</p><ul><li>webViewClient.shouldOverrideUrlLoading(WebView,WebResourceRequest)<br>  当需要加载一个新的 url 的时候，WebView 会先询问 WebViewClient 是否需要进行拦截。利用这个回调，可以构造自己的 schema ，在 url 中携带各种动作信息和参数等。这种方式一般是在 JS 中创建一个不可见的 iframe，然后改变 iframe 的 src 属性就可以了（微信就是这么实现的）。</li><li>webChromeClient.onJSPrompt(wv,url,message,defaultValue,callback)<br>  还有另外两个类似的回调方法，不过因为使用频率都比这个方法高，一般都不会去占用。这里主要用到第三个参数： message ，通过它传递 Json 字符串，可以方便拿到各种信息，比上面的方式略简单一些（不是很喜欢这种方式）。</li><li>webView.addJavascriptInterface(object,name)<br>  这种方式应该是效率最高、调用最自然的一种，不过在 Android 4.2 之前有安全问题，如果不需要兼容4.2 及以下版本，应该是比较推荐使用这个种方式。这种方式将 Native 中的一个对象挂载到 JS 的window 上，并命名为 name，然后 JS 中就能够通过 <code>window.name.funname(params)</code> 的方式来调用 Native 中被 JavascriptInterface 注解所标记的方法了（这里可以实现 JS 同步调用 Native ）</li></ul><p>上面的只是完成了 JS 发消息到 Native ，Native 通知 JS 可以通过 <code>webview.loadUrl(url)</code> 来实现。</p><h2 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h2><ul><li>通信协议<br>  需要制定统一的消息格式，这个还算比较简单</li><li>回调<br>  Webview 渲染线程和一般的 UI 线程不是同一线程，所以需要通过回调在子线程拿到返回值</li><li>传递信息长度<br>  如果通过 <code>webViewClient.shouldOverrideUrlLoading</code> 还要注意 url 的长度，不过一般情况下是不会有这种问题的</li><li>线程<br>  Native 只能在主线程调用 JS，接收到的 JS 调用在子线程</li></ul><h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><p>撸 JSbrdige 所需要的基本知识也就这些了，还有一些小坑点在实现的过程中来说明。<br>这里以我已经完成的 <a target="_blank" rel="noopener" href="https://github.com/dashMrl/JStraw">JSBridge</a> 为例来进行说明。</p><blockquote><p>因为 JavaScript 实现比较简单，所以主要讲 Native（kotlin） 的实现，</p></blockquote><h3 id="核心类说明"><a href="#核心类说明" class="headerlink" title="核心类说明"></a>核心类说明</h3><p>JSBridge 核心还是一个通信协议，所以需要一些规范化的抽象。</p><h4 id="Request-x2F-Response"><a href="#Request-x2F-Response" class="headerlink" title="Request&#x2F;Response"></a>Request&#x2F;Response</h4><p>仿照 HTTP 协议，定义出请求响应类，这里就直接看源码就 OK 了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Native 调用 JS 或者 JS 调用 Native 的请求封装</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="meta">@SerializedName(<span class="string">&quot;handler_name&quot;</span>)</span><span class="comment">//对于不同功能，我们提供不同的 Handler 处理</span></span><br><span class="line">        <span class="keyword">val</span> handlerName: String,</span><br><span class="line">        <span class="meta">@SerializedName(<span class="string">&quot;callback_id&quot;</span>)</span><span class="comment">//在另外一段完成操作后进行回调用的</span></span><br><span class="line">        <span class="keyword">val</span> callbackId: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="meta">@SerializedName(<span class="string">&quot;params&quot;</span>)</span><span class="comment">// Handler 处理所需要的数据</span></span><br><span class="line">        <span class="keyword">val</span> params: T</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(callId: <span class="type">String</span>, callbackId: <span class="type">Int</span>, params: <span class="type">T</span>)</span></span>: Request&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Request(callId, callbackId, params)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Native 对 JS 或者 JS 对 Native 的响应的封装</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="type">out T</span>&gt;</span>(</span><br><span class="line">        <span class="meta">@SerializedName(<span class="string">&quot;status&quot;</span>)</span><span class="comment">//状态，成功、失败或取消</span></span><br><span class="line">        <span class="keyword">val</span> status: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="meta">@SerializedName(<span class="string">&quot;msg&quot;</span>)</span><span class="comment">//状态的简单解释</span></span><br><span class="line">        <span class="keyword">val</span> msg: String,</span><br><span class="line">        <span class="meta">@SerializedName(<span class="string">&quot;body&quot;</span>)</span><span class="comment">//响应数据</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span>: T</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> STATUS_OK = <span class="number">0</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> STATUS_FAILED = <span class="number">1</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> STATUS_CANCEL = <span class="number">2</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">success</span><span class="params">(msg: <span class="type">String</span> = <span class="string">&quot;success&quot;</span>, <span class="keyword">data</span>: <span class="type">T</span>)</span></span>: Response&lt;T&gt; = Response(STATUS_OK, msg, <span class="keyword">data</span>)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(msg: <span class="type">String</span> = <span class="string">&quot;canceled&quot;</span>)</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; = Response(STATUS_CANCEL, msg, <span class="built_in">Unit</span>)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">failed</span><span class="params">(msg: <span class="type">String</span> = <span class="string">&quot;failed&quot;</span>)</span></span>: Response&lt;<span class="built_in">Unit</span>&gt; = Response(STATUS_FAILED, msg, <span class="built_in">Unit</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NativeHandler-lt-in-T-out-R-gt"><a href="#NativeHandler-lt-in-T-out-R-gt" class="headerlink" title="NativeHandler&lt;in T, out R&gt;"></a>NativeHandler&lt;in T, out R&gt;</h4><p>对于 JS 的请求，需要有特定的类来进行处理，这里还是直接看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NativeHandler</span>&lt;<span class="type">in T, out R</span>&gt; </span>&#123;<span class="comment">// T 表示接收请求参数类型，R 表示响应参数类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">name</span><span class="params">()</span></span>: String</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">handleJSCall</span><span class="params">(requestStr: <span class="type">String</span>, wv: <span class="type">WebView</span>)</span></span> &#123;<span class="comment">//kotlin 接口可以有方法实现</span></span><br><span class="line">        Log.d(<span class="string">&quot;NativeHandler&quot;</span>,requestStr)</span><br><span class="line">        <span class="keyword">val</span> request = JsonUtil.json2Obj&lt;Request&lt;T&gt;&gt;(requestStr)</span><br><span class="line">        handle(request.params, JSCallback(wv, request.callbackId))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">handle</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>, callback: <span class="type">JSCallback</span>&lt;<span class="type">R</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应对不同类型的请求，可以通过实现不同的 NativeHandler 来实现，其中 <code>name()</code> 应该返回一个全局唯一的、易于识别的字符串用于标识这个 Handler，重写 <code>handle()</code> 来处理请求并响应。要注意的是，<code>handle()</code> 方法默认运行在子线程，所以如果想操作 UI ，还要进行线程切换（JSCallback 内部进行了线程切换）。</p><blockquote><p>最好是做到每个请求都响应一些状态，让另外一端知道请求是失败还是成功又或者取消了等</p></blockquote><h4 id="Pivot"><a href="#Pivot" class="headerlink" title="Pivot"></a>Pivot</h4><p>这个类是通信的枢纽，对 JS 的调用与接受 JS 的请求都是在这里。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPivot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callJS</span><span class="params">(handlerName: <span class="type">String</span>, params: <span class="type">String</span>, callback: <span class="type">NativeCallback</span>&lt;*&gt;)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callFromJS</span><span class="params">(handlerName: <span class="type">String</span>, request: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">responseFromJS</span><span class="params">(callbackId: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JStraw"><a href="#JStraw" class="headerlink" title="JStraw"></a>JStraw</h4><p>这个类用于对外暴露 API 接口，有些接口需要隐藏，所以使用 <code>internal</code> 进行修饰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IJStraw</span> </span>&#123;<span class="comment">//interface 不能使用 internal 所以改成 abstract class</span></span><br><span class="line">    <span class="keyword">abstract</span>  <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">callJS</span><span class="params">(handlerName: <span class="type">String</span>, <span class="keyword">data</span>: <span class="type">String</span> = <span class="string">&quot;&quot;</span>)</span></span>: NativeCallback&lt;T&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerNativeHandler</span><span class="params">(handler: <span class="type">NativeHandler</span>&lt;*, *&gt;)</span></span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">findNativeHandler</span><span class="params">(handlerName: <span class="type">String</span>)</span></span>: NativeHandler&lt;*, *&gt;?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">addCallback</span><span class="params">(callbackId: <span class="type">Int</span>, callback: <span class="type">NativeCallback</span>&lt;*&gt;)</span></span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeCallback</span><span class="params">(callbackId: <span class="type">Int</span>)</span></span>: NativeCallback&lt;*&gt;?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过几行代码就可以完成 Native 调用 JS：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jstraw.callJS&lt;String&gt;(<span class="string">&quot;js_handler&quot;</span>,<span class="string">&quot;json data&quot;</span>)</span><br><span class="line">    .success &#123; result: String -&gt; toast(result) &#125;</span><br><span class="line">.failed &#123; msg -&gt; toast(msg) &#125;</span><br><span class="line">.canceled &#123; toast(<span class="string">&quot;canceled&quot;</span>) &#125;</span><br><span class="line">.error &#123; e -&gt; toast(e.message.toString()) &#125;</span><br><span class="line">.exec()</span><br></pre></td></tr></table></figure><blockquote><p>到这里，Native 端的大概轮廓就出来了，剩下的只剩下一些细节方面的东西了</p></blockquote><h4 id="JS-实现"><a href="#JS-实现" class="headerlink" title="JS 实现"></a>JS 实现</h4><p>因为 JS 实现真的是容易，所以下面直接贴代码（凑字数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniqueId = <span class="number">1</span>;<span class="comment">//用于回调标示</span></span><br><span class="line"><span class="keyword">let</span> callbacks = &#123;&#125;;<span class="comment">//保存 回调</span></span><br><span class="line"><span class="keyword">let</span> handlers = &#123;&#125;;<span class="comment">//Native 调用的处理集合</span></span><br><span class="line"><span class="comment">// 注册 handler ,需要一个 handlerName 进行标识</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">registerJSHandler</span> = (<span class="params">handlerName, handler</span>) =&gt; &#123;</span><br><span class="line">    handlers[handlerName] = &#123;</span><br><span class="line">        <span class="attr">handleNativeCall</span>: <span class="function">(<span class="params">request</span>) =&gt;</span> &#123;</span><br><span class="line">            handler.<span class="title function_">handle</span>(request, &#123;</span><br><span class="line">                <span class="attr">success</span>: <span class="function">(<span class="params">body = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                    pivot.<span class="title function_">responseFromJS</span>(request.<span class="property">callback_id</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">msg</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">                        <span class="attr">body</span>: body</span><br><span class="line">                    &#125;));</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">failed</span>: <span class="function">(<span class="params">msg = <span class="string">&quot;failed&quot;</span></span>) =&gt;</span> &#123;</span><br><span class="line">                    pivot.<span class="title function_">responseFromJS</span>(request.<span class="property">callback_id</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="attr">msg</span>: msg,</span><br><span class="line">                        <span class="attr">body</span>: &#123;&#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">cancel</span>: <span class="function">(<span class="params">reason = <span class="string">&#x27;canceled&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">                    pivot.<span class="title function_">responseFromJS</span>(request.<span class="property">callback_id</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="attr">msg</span>: reason,</span><br><span class="line">                        <span class="attr">body</span>: &#123;&#125;</span><br><span class="line">                    &#125;))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用 Native 功能的方法，需要 Native 端的 handler标识 和 参数</span></span><br><span class="line"><span class="comment">//这里使用 Promise 来使得调用流程更加方便</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">callNative</span> = (<span class="params">handlerName, params = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> callbackId = uniqueId++;</span><br><span class="line">    <span class="keyword">const</span> request = &#123;</span><br><span class="line">        <span class="attr">handler_name</span>: handlerName,</span><br><span class="line">        <span class="attr">callback_id</span>: callbackId,</span><br><span class="line">        <span class="attr">params</span>: params</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callbacks[callbackId] = &#123;</span><br><span class="line">                <span class="attr">onResponse</span>: <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            pivot.<span class="title function_">callFromJS</span>(handlerName, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(request));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">            <span class="keyword">delete</span> callbacks[callbackId];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过定义 straw 来将模块中的函数暴露出去</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">straw</span> = &#123;</span><br><span class="line">    <span class="attr">callNative</span>: callNative,</span><br><span class="line">    <span class="attr">registerJSHandler</span>: registerJSHandler</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//called by native code</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">callFromNative</span> = <span class="function">(<span class="params">request</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handlerName = request.<span class="property">handler_name</span>;</span><br><span class="line">    <span class="keyword">if</span> (handlers[handlerName]) &#123;</span><br><span class="line">        handlers[handlerName].<span class="title function_">handleNativeCall</span>(request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;undefined handler&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//called by native code</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">responseFromNative</span> = <span class="function">(<span class="params">callbackId, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callbacks[callbackId]) &#123;</span><br><span class="line">        callbacks[callbackId].<span class="title function_">onResponse</span>(response);</span><br><span class="line">        <span class="keyword">delete</span> callbacks[callbackId];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 因为这段 JS 代码是在页面加载完成之后才进行注入的，JS 端使用时需要监听这个事件的完成</span></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;onStrawInit&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure><p>另外，通过 JS 对象的特性，我们可以非常方便的向 Native 端暴露接口，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 Native 端接口集合</span></span><br><span class="line"><span class="keyword">const</span> nativeApiList = [&#123;</span><br><span class="line">    <span class="string">&quot;funName&quot;</span>:<span class="string">&quot;isLogin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;handlerName&quot;</span>: <span class="string">&quot;loginHandler&quot;</span>,</span><br><span class="line">    <span class="string">&quot;needParams&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">apiGenerator</span> = (<span class="params">nativeApi</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeApi.<span class="property">needParams</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> straw.<span class="title function_">callNative</span>(nativeApi.<span class="property">handlerName</span>, params);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> straw.<span class="title function_">callNative</span>(nativeApi.<span class="property">handlerName</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用 JS 对象类似于键值对的特性动态绑定函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">apiFactory</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">    list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">nativeApi</span>) =&gt;</span> &#123;</span><br><span class="line">        straw[<span class="string">`<span class="subst">$&#123;nativeApi.funName&#125;</span>`</span>] = <span class="title function_">apiGenerator</span>(nativeApi);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//function apiFactory() below should be called after straw.bundle-x.x.x.js is injected</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">straw</span>) &#123;</span><br><span class="line">    <span class="title function_">apiFactory</span>(nativeApiList);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;onStrawInit&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Straw inited&#x27;</span>);</span><br><span class="line">        <span class="title function_">apiFactory</span>(nativeApiList);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Native 要是实现上面的功能就比较蛋疼了！！！</p><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>上面大概就是实现 JSBridge 的思路，在这之外还有一些问题需要注意。</p><h3 id="注入时机"><a href="#注入时机" class="headerlink" title="注入时机"></a>注入时机</h3><p>刚刚也说了，JSbridge JS 端代码一般是在客户端本地的，并没直接添加到网页里，所以我们需要将这段 JS 注入网页，最容易想到的就是在页面加载完成的时候进行注入。 <code>webViewClient.onPageFinished()</code>  能够完成网页加载完成的事件，那就继承一个呗。但是考虑到开发者可能还想在这方法里面进行一些其他操作，为了不起冲突，包装一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JStrawWebViewClient</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> puppetWVC: WebViewClient?, <span class="keyword">private</span> <span class="keyword">var</span> jsUrl: String)</span><br><span class="line">: WebViewClient() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPageFinished</span><span class="params">(view: <span class="type">WebView</span>?, url: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        InjectUtil.injectJS(view, jsUrl)</span><br><span class="line">        puppetWVC?.onPageFinished(view, url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>puppetWVC 就是用户自己的 WebViewClient 实例。</p><h3 id="注入安全性"><a href="#注入安全性" class="headerlink" title="注入安全性"></a>注入安全性</h3><p>注入非常简单，定义一个 <code>script</code> 节点，将这个节点插入网页就好了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;$jsUrl&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> firstScript = <span class="variable language_">document</span>.<span class="property">scripts</span>[<span class="number">0</span>];</span><br><span class="line">firstScript.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(script,firstScript);</span><br></pre></td></tr></table></figure><p>一看没毛病，觉得完全OK。但是如果这个 jsUrl 是 <code>file:///android_asset/jstraw.js</code> ，并且你加载的网页不是应用内置的，那么 WebView 内核是不会去加载的，因为它会认为是 <strong>网页主动</strong> 想要拿到本地的资源（事实上是被我们注入的）。但是如果 jsUrl 是 <code>https://host/path/jstraw.js</code> 类型，那么 WebView 是会去尝试加载的。</p><p>知道了这些，我们再考虑这些情况，加载一个非本地网页，理想情况是应用内部、SD 卡和网络上的 JS 文件 都能注入。那么怎么才能使得 这三种情况都被满足呢？</p><p>又要用到 WebViewClient 了，这次需要重写的是 <code>shouldInterceptRequest</code> 这个方法，这个方法会在 WebView 请求每一个资源之前调用一次，如果返回 null 那么，WebView 就自己去加载，如果返回 nonnull ，那么WebView 就会使用我们的提供的资源。</p><p>那么，考虑的安全性限制，我们对 jsUrl 来进行一个转换，如果是来自 应用内部 或者 SD 卡，那就对它改造下，改成 WebView 认可的格式，然后我们再在  <code>shouldInterceptRequest</code>  中来解析并返回资源就OK 了。</p><blockquote><p>也可以利用这个方法来接管 WebView 的缓存，使得整个应用的网络请求都能被监控到。</p></blockquote><p><a target="_blank" rel="noopener" href="https://github.com/dashMrl/JStraw">完整代码</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/577a6f41128fe10056539e03">android 中的 Hybrid 开发</a></p><p><a target="_blank" rel="noopener" href="https://quanru.github.io/2016/10/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%20Webview%20Jsbridge%20%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/">记一次 Webview Jsbridge 接口封装</a></p><p><a target="_blank" rel="noopener" href="https://github.com/lzyzsd/JsBridge">JSBridge</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Hybrid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webview </tag>
            
            <tag> JSB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装</title>
      <link href="/2018/01/08/bac07c03beeb.html"/>
      <url>/2018/01/08/bac07c03beeb.html</url>
      
        <content type="html"><![CDATA[<p>这篇文章真不知道怎么写描述，很尴尬的开头。<br>只是简单的记录一下 Docker 的安装和常用的操作命令。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>这里安装的是 Docker-ce，满足我们的学习需求是完全没有问题的</p><p>我使用的是 Ubuntu 17.04</p></blockquote><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>Docker 要求我们的操作系统（Ubuntu）必须是 64-bit，同时必须是下面这些版本：</p><ul><li>Artful 17.10 (Docker CE 17.11 Edge and higher only)</li><li>Zesty 17.04</li><li>Xenial 16.04 (LTS)</li><li>Trusty 14.04 (LTS)</li></ul><blockquote><p>虽然可能不是这些版本也能安装成功，但是可能官方文档上的一些操作可能会执行失败，所以最妥当的方法就是使用长期支持版本（LTS）</p></blockquote><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>Docker 目前版本和之前的版本名称有改变，所以需要卸载以前的版本，如果这是你第一次安装的话，可以跳过。<br>终端执行一下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt remove docker docker-engine docker.io</span></span><br></pre></td></tr></table></figure><blockquote><p>你的镜像、容器等不会被一起清除，它们还呆在 <code>/var/lib/docker/</code> 目录下</p></blockquote><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>安装方式有 <strong>从源安装</strong> 和 <strong>安装包安装</strong> 两种，这里选择前者进行演示。</p><h4 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h4><h5 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br></pre></td></tr></table></figure><h5 id="安装-HTTPS-证书"><a href="#安装-HTTPS-证书" class="headerlink" title="安装 HTTPS 证书"></a>安装 HTTPS 证书</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install \</span></span><br><span class="line"><span class="language-bash">    apt-transport-https \</span></span><br><span class="line"><span class="language-bash">    ca-certificates \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    software-properties-common</span></span><br></pre></td></tr></table></figure><h5 id="添加-Docker-官方-GPG-密钥"><a href="#添加-Docker-官方-GPG-密钥" class="headerlink" title="添加 Docker 官方 GPG 密钥"></a>添加 Docker 官方 GPG 密钥</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span></span><br></pre></td></tr></table></figure><p>如果密钥添加成功，那么源列表里面会有指纹（fingerprint）为 <code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code> 的 key，这里通过搜索后八位指纹来验证下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-key fingerprint 0EBFCD88</span></span><br><span class="line"></span><br><span class="line">pub   4096R/0EBFCD88 2017-02-22</span><br><span class="line">      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   4096R/F273FCD8 2017-02-22</span><br></pre></td></tr></table></figure><h5 id="配置稳定版的源"><a href="#配置稳定版的源" class="headerlink" title="配置稳定版的源"></a>配置稳定版的源</h5><p>因为机器属于 x86_64&#x2F;amd64 所以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo add-apt-repository \</span></span><br><span class="line"><span class="language-bash">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">   <span class="subst">$(lsb_release -cs)</span> \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">   stable&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><h5 id="再次更新源列表"><a href="#再次更新源列表" class="headerlink" title="再次更新源列表"></a>再次更新源列表</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br></pre></td></tr></table></figure><h5 id="安装指定版本-Docker"><a href="#安装指定版本-Docker" class="headerlink" title="安装指定版本 Docker"></a>安装指定版本 Docker</h5><p>因为生产环境中最好是选定一个版本后就基本保持不变，所以这里来制定安装版本，而不是一股脑直接装最新版。</p><p>先执行一下命令看看有哪些版本可供选择：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-cache madison docker-ce</span></span><br><span class="line"></span><br><span class="line"> docker-ce | 17.12.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu zesty/stable amd64 Packages</span><br><span class="line"> docker-ce | 17.09.1~ce-0~ubuntu | https://download.docker.com/linux/ubuntu zesty/stable amd64 Packages</span><br><span class="line"> docker-ce | 17.09.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu zesty/stable amd64 Packages</span><br><span class="line"> docker-ce | 17.06.2~ce-0~ubuntu | https://download.docker.com/linux/ubuntu zesty/stable amd64 Packages</span><br><span class="line"> docker-ce | 17.06.1~ce-0~ubuntu | https://download.docker.com/linux/ubuntu zesty/stable amd64 Packages</span><br><span class="line"> docker-ce | 17.06.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu zesty/stable amd64 Packages</span><br></pre></td></tr></table></figure><p>输出中 <code>17.12.0~ce-0~ubuntu</code> 的字样就是版本号了，这里选择最新的版本安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install docker-ce=17.12.0~ce-0~ubuntu</span></span><br></pre></td></tr></table></figure><p><code>=</code> 号后面接你想安装的版本</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>跑一个 HelloWorld 看看 Docker 有没有安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker run hello-world</span></span><br></pre></td></tr></table></figure><p>如果得到下面的输出就证明安装成功了，否则再回过头看看哪里出了错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">ca4f61b1923c: Pull complete</span><br><span class="line">Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://cloud.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure><h3 id="后续配置"><a href="#后续配置" class="headerlink" title="后续配置"></a>后续配置</h3><p>完成基本安装后，还可以通过一些设置来提高使用的便捷性。</p><h4 id="添加当前用户到-docker-用户组"><a href="#添加当前用户到-docker-用户组" class="headerlink" title="添加当前用户到 docker 用户组"></a>添加当前用户到 docker 用户组</h4><p>完成最基本的安装后，虽然可以使用，但是每次都需要加上 <code>sudo</code> ，这是因为 docker daemon 进程是绑定在 Unix socket 上，并且默认地 Unix socket 属于 root 用户。如果想避免每次都使用 <code>sudo</code> 进行操作，可以创建一个叫 <code>docker</code> 的 Unix 用户组，然后将当前登录的用户添加进去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="variable">$USER</span></span></span><br></pre></td></tr></table></figure><h4 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h4><p>大多数 Linux 发行版（RHEL，CentOS，Fedora，Ubuntu1604及以上）使用 <code>systemd</code> 管理开机自启的服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="built_in">enable</span>/disable docker</span></span><br></pre></td></tr></table></figure><p>到这里也就安装好了。</p><blockquote><p>关于 docker 提供的其他命令，建议直接看 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/cli/">官方文档</a> 里介绍.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Ubutnu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity 生命周期</title>
      <link href="/2018/01/06/8ac5ba4f490e.html"/>
      <url>/2018/01/06/8ac5ba4f490e.html</url>
      
        <content type="html"><![CDATA[<p>Activity 的生命周期是每位 Android 开发都必须掌握的基本知识，以致于几乎所有的 Android ，入门书籍在前几章就会开始讲生命周期。这篇文章大体上是官方文档的个人理解，内容上可能会有一些出入。</p><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>随着用户的操作，应用会在几个状态之间进行一系列的切换，映射到 Activity 上就是一系列的生命周期回调：onCreate()、onStart()、onResume()、onPause()、onStop() 以及 onDestroy()。当 Activity 切换到不同的状态时，系统会调用对应的生命周期回调方法。</p><p>下图是官方对 Activity 状态转移的图示：</p><p><img src="https://developer.android.com/guide/components/images/activity_lifecycle.png"></p><p>通过重写这些生命周期方法，以便在适当的时候做出处理，比如保存数据、停止音乐、释放数据库连接等，根据应用的复杂程度，并不是必须重写所有的生命周期回调方法。</p><h2 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h2><p>这一节会分别对主要生命周期回调进行一些说明。</p><h3 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h3><p>这个方法一般情况下必须重写，系统创建 Activity 实例之后就会调用这个方法，Activity 进入 <code>Created</code> 状态。这个回调方法里面主要完成一些整个 Activity 生命周期中只需要执行一次的逻辑，例如初始化控件等。 Activity 不会在这个方法停留，执行完后马上相继调用 <code>onStart()</code> 和  <code>onResume()</code> 。</p><h3 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h3><p>当应用进入 <code>Started</code> 状态时，系统会调用这个方法，这是 Activity 对用户可见，但是还不能和用户进行交互。这个方法里面主要做一些 UI 相关的初始化操作，这个方法执行完 Activity 就会迅速进入下一个状态 <code>Resumed</code> 。</p><h3 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h3><p>当 Activity 进入 <code>Resumed</code> 状态，系统也会调用这个方法，同时 Activity 也能和用户进行交互了。Activity 一旦进入 <code>Resumed</code> 状态，将会一直保持这个状态，知道有事件使得当前 Activity 失去焦点，例如来电、返回 HomeScreen 等。当 Activity 每次回到前台时，系统都会调用这个方法，所以不要在这个方法里面进行非必须的开销大的初始化操作。</p><h3 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h3><p>当系统调用这个方法的时候，表示 Activity 失去焦点，进入 <code>Paused</code> 状态，变得不可交互，但是还是可见的。这个方法里面不适合做一些诸如数据保存、网络请求等重量级的操作，应该考虑将它们交给 <code>onStop()</code> 来完成，否则一个很常见的问题就是会导致启动其它 Activity 变得很慢。</p><p>这个方法的执行完成 <strong>不代表</strong> Activity 离开 <code>Paused</code> 状态，只有当这个 Activity 变得 <strong>完全不可见</strong> 时才会转入 <code>Stopped</code> 状态。</p><h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h3><p>当 Activity 变得 <strong>完全不可见</strong> 时，系统就会调用这个方法，同时进入 <code>Stopped</code> 状态，并且从 WindowsManager 上解绑。这时可以做一些相对比较重的资源释放操作。这时候 Activity 会呆在内存里头，直到进入 <code>Destroyed</code> 状态。</p><h3 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h3><p>在 Activity 被销毁之前这个方法会被调用，这也是生命周期里面的最后一个方法，所有的资源释放操作必须在这个方法结束前完成。</p><h2 id="生命周期其它"><a href="#生命周期其它" class="headerlink" title="生命周期其它"></a>生命周期其它</h2><p>在基本的流程之外，还有一些经典的知识点需要我们能够通过生命周期来进行解释。</p><h3 id="onStart-x2F-onPause、onResume-x2F-onStop"><a href="#onStart-x2F-onPause、onResume-x2F-onStop" class="headerlink" title="onStart&#x2F;onPause、onResume&#x2F;onStop"></a>onStart&#x2F;onPause、onResume&#x2F;onStop</h3><p>有些初学者可能并没有很清楚地知道为什么需要两对生命周期回调，其实这里抓住要点就很好懂了，关键就是可交互与不可交互、可见与不可见。</p><p>结合启动一个窗口主题的 Activity 的问题，设置它们四的理由就很清晰了。当 ActivityA 启动一个窗口主题的 ActivityB，B获取到焦点，A 变得不可交互，但是 A 还是可见的，B 开始和用户进行交互。如果把可见性和可交互性状态交个同一对回调方法，简单推敲下就会发现问题了。</p><h3 id="startActivity-时两个-Activity-的生命周期"><a href="#startActivity-时两个-Activity-的生命周期" class="headerlink" title="startActivity 时两个 Activity 的生命周期"></a>startActivity 时两个 Activity 的生命周期</h3><p>当 A 启动 B 时，它俩的生命周期回调之间的顺序如何？这个问题其实也很好理解，同样是根据不同生命周期方法调用之后 Activity 状态特点来进行判断。所以简单推敲后我们可以得到下面的顺序：</p><ul><li>A : onPause()</li><li>B : onCreate()</li><li>B : onStart()</li><li>B : onResume()</li><li>A : onStop()</li></ul><p>通过这里也可以解释为什么 onPause() 里面只能做一些轻量操作，而 onStop() 里面可以进行开销稍大的操作了。</p><h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><p>当系统资源紧张的时候，系统会选择性杀死一些没那么重要的 Activity；系统通常不是直接杀死Activity，而是直接杀死 Activity 所在进程。进程和Activity 状态之间的关系可用下列表格表示：</p><table><thead><tr><th>被杀可能性</th><th>进程状态</th><th>Activity 状态</th></tr></thead><tbody><tr><td>Least</td><td>Foreground（having or about to get focus）</td><td>Created、Started、Resumed</td></tr><tr><td>More</td><td>Background（lost focus）</td><td>Paused</td></tr><tr><td>Most</td><td>Background（not visible）</td><td>Stopped</td></tr><tr><td>Most</td><td>Empty</td><td>Destroyed</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lifecycle </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit 拆轮子之构建流程分析</title>
      <link href="/2018/01/06/d45e3dbb6019.html"/>
      <url>/2018/01/06/d45e3dbb6019.html</url>
      
        <content type="html"><![CDATA[<p>在使用 OkHttp 的时候，还是要自己构建 Request 的，我们的目的是请求一个 url 并拿到数据，构建流程不利于逻辑清晰，特别是当需要 Post 上传数据的时候。Square 显然是看到了这个问题，便推出了 Retrofit 来解决这个问题。</p><span id="more"></span><p>Retrofit 使用注解的方式来定义一个后端接口，在 <strong>运行时</strong> 解析，动态构建出请求逻辑并执行。有时候还是会遇上一些坑，所以最快捷的方式就是阅读它的源码，知道了内部逻辑，自然而然就知道了问题出在哪里。</p><blockquote><p>这里基于 Retrofit：2.4.0-SNAPSHOT 分析</p></blockquote><h1 id="构建流程分析"><a href="#构建流程分析" class="headerlink" title="构建流程分析"></a>构建流程分析</h1><p>Retrofit 简化请求的构建，使得网络请求就像简单的函数调用一样。这次就分析下面的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">  <span class="meta">@GET(&quot;/user&quot;)</span></span><br><span class="line">  Observable&lt;User&gt; <span class="title function_">getUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://example.com/&quot;</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> retrofit.create(MyService.class);</span><br><span class="line"></span><br><span class="line">Observable&lt;User&gt; observable = service.getUser();</span><br></pre></td></tr></table></figure><ul><li>Retrofit：2.4.0-SNAPSHOT</li></ul><h2 id="请求流程概览"><a href="#请求流程概览" class="headerlink" title="请求流程概览"></a>请求流程概览</h2><p>忽略前面 Retrofit 实例的配置和构建，直接分析后面的请求发起过程，下面是整个流程的概览图：<br><img src="https://i.loli.net/2018/01/06/5a4fbb5eeba30.png"></p><blockquote><p>参照<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/fb8d21978e38">@stay4it</a> 的流程图作了简化。</p></blockquote><h2 id="重要类剖析"><a href="#重要类剖析" class="headerlink" title="重要类剖析"></a>重要类剖析</h2><h3 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a>ServiceMethod</h3><p>JavaDoc 中的注释是这样的：Adapts an invocation of an interface method into an HTTP call。大概意思就是把我们定义的接口方法包装成一个 HTTP 请求。在构建一个 ServiceMethod 实例时会解析我们定义的接口方法，解析注解以及返回值等等并确定 CallAdapter 和 Converter。</p><h3 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h3><p>CallAdapter 是个接口，在 retrofit-calladapters 这个 module 下有它的实现类。这个类的作用是将一个 Call<R> 转换成一个 T，比如 Call<User> -&gt; Observable<User> ，从而直接拿到想要的类型值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CallAdapter</span>&lt;R, T&gt; &#123;</span><br><span class="line">  Type <span class="title function_">responseType</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//核心方法</span></span><br><span class="line">  T <span class="title function_">adapt</span><span class="params">(Call&lt;R&gt; call)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><p>请求&#x2F;响应体转换，将实例转换成 HTTP 能接受的形式，或者从 HTTP 中转换出想要的类型。在 retrofit-converters 这个 Module 下有它的一些实现类，如 GsonXXXBodyConverter，它能实现 Call<ResponseBody> -&gt; Call<User> 的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;F, T&gt; &#123;</span><br><span class="line">  T <span class="title function_">convert</span><span class="params">(F value)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class="line">        Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h3><p>对 OkHttp 的Call 进行了一个包装，然后完成一些 Call 的操作，这里的 Call 是指 okhttp3.Call。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Retrofit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见，2017！！！</title>
      <link href="/2018/01/01/0e6c7f96e0f9.html"/>
      <url>/2018/01/01/0e6c7f96e0f9.html</url>
      
        <content type="html"><![CDATA[<p>今天元旦，2018 年的第一天，也琢磨着是不是该写写什么，就这么过去似乎太平淡了。思前想后，留有印象的事情好像就那么几件，似乎每天都是差不多的生活——看文章、写代码。</p><span id="more"></span><blockquote><p>公历农历真是神奇的东西，今年明年怎么算一时半会竟然还糊涂了，那还是按照公历来算吧。</p></blockquote><p>去年这个时候，差不多也是临近期末，既要准备考试，又要忙于项目。有时候真想什么都甩手不敢，去他妈的考试，干他妈的项目。也就想想，生活还是要继续。</p><p>2 月份就已经放寒假了，还是像往常一样，继续待在学校（自从进了高中就是这样）。到现在热记忆犹新的，还是回家居然买反了票，虽然取票的时候觉得哪里不对，取出来硬是盯了半天才发现问题。不过运气还不算太差，人工窗口那买到了回家的票，虽然只能在岳阳暂住一晚。比较神奇的是，半路上高中同学突然联系（怕是一年半没联系过了），约着出去浪了一波，蹭了顿饭，之后还建了个群水到现在hhh。</p><p>然后春节还是那么无聊，正月里9号就滚回了学校，元宵节就和俩傻逼在外面兜了个大圈子，还特么和几个陌生妹子建了个微信群，狗血。比较遗憾的是春游没有和大家一起泡温泉，不过和其他人玩狼人杀也很开心。</p><p>上半年，上了我的第一款App，虽然后来没有继续维护下去，但是毕竟是我第一次的合作，给我攒了一波实战经验。此处应该有个<a target="_blank" rel="noopener" href="http://android.myapp.com/myapp/detail.htm?apkName=net.bingyan.marknow&apkCode=1">链接</a> 。</p><p>大学就是奇怪，期中一过马上就开始期末考试了，陆陆续续，让人不敢怠慢。然后，碰上上大学来的第一次挂科，后来也变成了第一次重修，实在惭愧。团队学长学姐们深造的深造，找实习的也都找到了窝。</p><p>暑假留下来参加夏令营，过着朝九晚五的生活，挺惬意、挺舒服的，每天都有一大堆人一起忙活，很充实。作为上次夏令营进团队的人，也非常希望每个人都能从夏令营收获一些东西，不管是能力还是知识还是朋友，觉得不虚此行就OK了。</p><p>暑假过完，就大三了，偶尔还会嘴误说自己是大二的，虽然打心底不愿意变成学长，可还是得承认。</p><p>开学本来还是发展对象，可觉得每季度一篇的思想汇报难以下笔，不开心便放弃了。接着班长似乎也变成挂名的了，虽然有点小缺憾，不过偶尔觉得挺乐呵的，毕竟室友帮我背锅了。</p><p>紧接着就接了我的第二个项目，也是现在正在写的内部工具。因为自己喜欢作，想把时髦的工具一次性尝个遍，结果遇上不少坑，然后也导致了几次大改。还好最后还是回到了一个比较正常的开发路线上，争取年内上线。</p><p>到这里，这一年似乎就这样了。</p><h2 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a>生活上</h2><ul><li>生活还是不那么规律，不愿意动</li><li>想好的说要长 20 斤也丝毫没有进度，虚</li><li>可能还是要多出去转一下，不然每次去世界城都要迷路QAQ（可能是我没开地图）</li></ul><h2 id="技术上"><a href="#技术上" class="headerlink" title="技术上"></a>技术上</h2><ul><li>上半年还是一直在学 Android 方面的东西，也还能沉下心来研究一些偏底层的东西，下半年似乎变得浮躁了些。可能没有安排好时间</li><li>之前也一直想要学习后台，5～6月的时候就持续看 Spring 官方文档，中间又放下了一段时间</li><li>虽然不是很想学习前端，但是为了更好合作以及配合当前发展趋势，还是努力尝试过一段时间，也产出了一个 JStraw</li><li>人工智能大数据火热依旧，为了迎合潮流，学习了 Python ，把环境给装好了hhh</li><li>算法弱鸡依旧，再不抓紧就 真&#96;菜鸡 了</li></ul><p>平时都自诩是互联网人，可是真谈起互联网这一年的变化，似乎自己跟着白痴一样，啥都没听过一样，兴许还是打不起兴趣关注那些看起来无聊的事情。<br>在待人接物方面还是习惯以自我为中心，有点 “直”（黑脸.jpg）。</p><h2 id="2018-展望"><a href="#2018-展望" class="headerlink" title="2018 展望"></a>2018 展望</h2><p>虽然没有写计划的习惯，但是还是简单写写，不然只是自己脑子想想，过段时日，还是会给自己找借口。写下来好给自己留个督促：</p><ul><li><input disabled="" type="checkbox"> 坚持每天阅读互联网新闻资讯</li><li><input disabled="" type="checkbox"> 读6本书</li><li><input disabled="" type="checkbox"> 学学 BBOX（室友带）</li><li><input disabled="" type="checkbox"> 锻炼身体，一周跑步俩次</li><li><input disabled="" type="checkbox"> 拿到驾照</li><li><input disabled="" type="checkbox"> 坚持写博客，尽量每星期一篇</li><li><input disabled="" type="checkbox"> 多蹭会，向设计组的小姐姐学画图</li><li><input disabled="" type="checkbox"> 学习后台和前端</li><li><input disabled="" type="checkbox"> 学习音视频开发</li></ul><p><strong>2018，做个健康的、有趣有内涵又不失节操的程序猿</strong></p><blockquote><p>作为一枚典型工科生，每到捏字造句的时候，得靠绞尽脑汁才能凑出那几百字，只怪自己读书少。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Year-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2017 </tag>
            
            <tag> 2018 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dagger2 上手指南</title>
      <link href="/2017/12/31/92ea79c6293a.html"/>
      <url>/2017/12/31/92ea79c6293a.html</url>
      
        <content type="html"><![CDATA[<p>在 Java 的开发中，怎么利用各种设计模式和架构设计来解耦、提高拓展性，似乎已经成了一名 Java 开发人员的必修课。在一些大型系统中，还会有各种听起来高大上的名词，如 IOC、OSGI、CGLIB 等。所以这里我们就来讲讲 IOC 的一个实现框架——Dagger2。</p><span id="more"></span><h2 id="IOC-x2F-DI"><a href="#IOC-x2F-DI" class="headerlink" title="IOC&#x2F;DI"></a>IOC&#x2F;DI</h2><blockquote><p>什么是 IOC（inverse of control）？</p></blockquote><p>IOC 是一种面向对象编程中的一种设计原则，主要用来降低代码之间的耦合度。主要手段是通过 <strong>第三方工具</strong> 实现具有依赖关系代码之间的解耦。</p><p>IOC 名称的含义？</p><p>考虑两种情况：</p><ul><li>类 A 需要类 B 的实例，A通过 new 关键字来创建实例，这时创建和使用都是 A 做主。</li><li>类 A 需要类 B 的实例，但是并没有主动使用 new 关键字，这时 A 只能被动接受外部传递给它的实例。</li></ul><p>对比两种情况，第二种情况中 A 失去了对 B 的控制权，获取 B 的过程由主动变为被动。</p><blockquote><p>什么是 DI（Dependency Injection）？</p></blockquote><p>DI 就是将某个实例通过某种方式传递给需要这个实例的地方。</p><blockquote><p>IOC 与 DI</p></blockquote><ul><li>IOC 是一种工程思想</li><li>DI 是一种设计模式，一种手段</li></ul><h2 id="Dagger2"><a href="#Dagger2" class="headerlink" title="Dagger2"></a>Dagger2</h2><blockquote><p>latest version 2.13</p></blockquote><p>Dagger2 是一个针对 Java  和 Android 的 <strong>静态</strong>、<strong>编译时运行</strong> 的依赖注入框架。因为是编译时运行，避免了在运行时使用反射所带来的性能开销，非常适合一些性能敏感的场景。</p><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>首先看一下初学 Java 时会写出的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个问题：</p><ul><li>A 对 B 的依赖程度非常高，当出现一个 NewB 的时候，需要修改 A 代码，不符合开闭原则</li><li>不利于单元测试，无法使用 mock B 对象</li></ul><p>考虑上述两个问题，可以改造成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> BaseB b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(BaseB b)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseB</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">BaseB</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样，之前的两个问题都解决了。</p><p>现在再来思考一种情况：</p><p>假如 A 是有状态的，并且很多功能模块使用到了 A，那么会有很多地方存在创建 A 实例的动作，然后因为需求不同还需要不同的 BaseB 子类。如果这时候产经突然改需求，导致我们的的 A 又需要依赖 C ，按照上一步的思想，我们可能需要给 A 构造函数添加一个参数，这时候使用到了 A 的地方就都得修改，虽然不是什么难事，但是效率（投入产出比）十分之低。</p><p>Dagger2 的可以比较完美的解决这个问题。</p><h3 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h3><p>先来看几个 Dagger2 最主要的四个注解。</p><h4 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h4><p>这个不是 Dagger2 提供的注解，而是 java 依赖注入规范提供的注解。<code>Inject</code> 可以用在 <strong>成员属性</strong>、<strong>构造方法</strong>、<strong>成员方法</strong> 上，对应于每一种情况都会有不同的作用，这里用表格来归纳下：</p><table><thead><tr><th align="left">使用对象</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">构造器</td><td align="left">表示可以使用这个构造器来对外提供实例</td></tr><tr><td align="left">成员属性</td><td align="left">表示这个属性需要被注入</td></tr><tr><td align="left">方法</td><td align="left">表示这个方法在依赖注入的最后阶段会被调用</td></tr></tbody></table><p>这里有几点需要注意：</p><ul><li>注入优先级： 构造器 &gt; 成员属性 &gt; 方法</li><li>只能有一个构造器被 <code>@Inject</code> 标注，访问权限不能是 <code>private</code></li><li>成员属性 被注入的顺序不能保证</li><li>方法 被调用的顺序不能保证</li></ul><h4 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h4><p>被 <code>@Module</code> 标注的类表明这个类会参与 <strong>依赖图</strong> 的构建，最主要的功能是 <strong>提供</strong> 依赖，提供依赖的方法（可以是静态方法）被 <code>@Provides</code> 标注。这些方法本身可能也需要别的依赖，这时 Dagger2 就会寻找满足这个方法的依赖，找不到就编译失败。</p><h4 id="Provides"><a href="#Provides" class="headerlink" title="@Provides"></a>@Provides</h4><p>配合 <code>@Module</code> 使用在方法上，表明这个方法会参与 <strong>依赖树</strong> 的构建。</p><blockquote><p>要注意方法的访问权限</p></blockquote><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>上面提到了两个代表：<strong>依赖需求方</strong> 和 <strong>依赖供给方</strong>，但是它们之间没有直接的联系，怎么把依赖交到 依赖需求方 的手上还是个问题。<br><code>@Component</code> 就是它们之间的桥梁，一般会使用 <code>@Component</code> 来标注一个 <strong>接口</strong>，然后指定 <code>@Component</code> 的 <code>modules</code> 属性为定义好的 <code>Module</code>（依赖供给方），最后声明一个包含 <strong>依赖需求方</strong> 参数类型的函数。<br>这样，联系就建立好了，构建一下工程，Dagger2 的注解处理器就会帮我们生成一个 <code>DaggerXXXX</code> 的类，通过它我们就能完成依赖注入工作了。</p><h3 id="实例练习"><a href="#实例练习" class="headerlink" title="实例练习"></a>实例练习</h3><p>刚刚讲解完几个概念，现在来看看在它们的联系在代码中的体现：</p><blockquote><p>为了便于表达，这里使用 MVP 来演示</p></blockquote><h4 id="声明-Inject"><a href="#声明-Inject" class="headerlink" title="声明 Inject"></a>声明 Inject</h4><p>首先得确定哪些地方需要依赖注入（即依赖需求方）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">MainContract</span>.MainView &#123;</span><br><span class="line">  <span class="comment">// MainActiivty 作为 MVP 中的 V，需要持有 P 层实例，即 MainContract.BaseMainPresenter 的一个实例</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">protected</span> MainContract.BaseMainPresenter presenter;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里 <code>presenter</code> 的类型声明是 <code>MainContract.BaseMainPresenter</code> ，这是一个抽象类。<br>再看一下 <code>MainContract.BaseMainPresenter</code> 的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainPresenter</span> <span class="keyword">extends</span> <span class="title class_">MainContract</span>.BaseMainPresenter &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照之前的理解，这里可以使用 <code>@Inject</code> 来标注 <code>MainPresenter</code> 的构造器，但是这里没有，而且也不行，因为 Dagger2 是静态解析的，所以我们通过 Module 来提供它的实例。</p><h4 id="声明-Module"><a href="#声明-Module" class="headerlink" title="声明 Module"></a>声明 Module</h4><p>定义好了 依赖需求方，还差供给方没有定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainModule</span> &#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> MainContract.BaseMainPresenter <span class="title function_">provideMainPresenter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MainPresenter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个点说明一下：</p><ul><li>被 <code>@Provides</code> 标注的方法一般命名为 <code>provideXXX</code></li><li>返回值类型一定要和 <code>@Inject</code> 标注的类型一致，如 <code>MainContract.BaseMainPresenter</code>，否则编译失败</li><li>在方法内部直接构建实例。这也是我个人比较喜欢的方式，因为这样就不需要在 <code>MainPresenter</code> 那边添加啥东西，配置过程都集中到 Module 里面。 再考虑另一种情况，当使用第三方库的时候，一般是没办法在它的构造器上加注解的，也只能在 Module 里面创建实例，保持风格统一总是没错的。</li></ul><h4 id="声明-Component"><a href="#声明-Component" class="headerlink" title="声明 Component"></a>声明 Component</h4><p>还需要 Component 来建立上面两者之间的联系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = &#123;MainModule.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MainComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MainActivity activity)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的名称可以随意，为了便于理解还是建议使用类似 <code>injectXXX</code> 的命名方式。<br>编译之后，Dagger2 会生成一个 <code>DaggerMainComponent</code> 实现 <code>MainComponent</code>，通过这个类就能完成注入了</p><h4 id="完成注入"><a href="#完成注入" class="headerlink" title="完成注入"></a>完成注入</h4><p>直接看代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">MainContract</span>.MainView &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    DaggerMainComponent.create().inject(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用到 presenter 之前进行注入，官方说是要在 <code>super.onCreate(savedInstanceState)</code> 之前注入，不过还是觉得在使用之前注入合理点。</p><p>这样就完成了一个比较简单的依赖注入实践。</p><h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><p>除了最基本的注入之外，Dagger2 还提供了一些其他的满足我们需求的功能，比如说单例、懒加载等。</p><h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><p>这个用在注解上的，因为它本身没有具体定义，只是提供了一个规范。它表明一个依赖的使用规则，可以看做生命周期或者作用域（我更喜欢用生命周期表述），如我在注入 <code>MainPresenter</code>的时候，是注入同一个实例，还是每执行一次 <code>inject()</code> 就创建一个新的 <code>MainPresenter</code> ，这个需求还是挺常见的。</p><p>体现 Scope 的注解有：<code>@Singleton</code> 和 <code>@Resuable</code>，下面具体说说它们的作用。</p><h5 id="Singleton"><a href="#Singleton" class="headerlink" title="@Singleton"></a>@Singleton</h5><p>向 Dagger2 声明，每次都使用同一个实例进行注入。因为 Dagger2 为 Component 和 依赖<br> 在依赖图中建立联系，所以需要保持它们两个的 Scope 是相同的，比如我在 <code>provideMainPresenter()</code> 上使用了 <code>@Singleton</code> ，那么在 <code>MainComponent</code> 上也要使用 <code>@Singleton</code> 来保持一致。<br> 这样，通过 <strong>同一个</strong>　<code>DaggerMainComponent</code> 实例获取的 <code>presenter</code> 就都是一样的了。请注意 “同一个” 这个修饰词，如果我们连续执行 <code>DaggerMainComponent.create().inject(this)</code> 两次，那么每次实例还是不一样的，只有这样：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DaggerMainComponnet</span> <span class="variable">component</span> <span class="operator">=</span> DaggerMainComponent.create();</span><br><span class="line">component.inject(<span class="built_in">this</span>);</span><br><span class="line">component.inject(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><br> 注入的 <code>presenter</code> 才是同一个实例。<br> 所以我们不能够指望 <code>@Singleton</code> 能够创建全局单例，而且它也没有处理并发的情况。</p><h5 id="Resuable"><a href="#Resuable" class="headerlink" title="@Resuable"></a>@Resuable</h5><p>可重用，表示希望能够重用之前创建的实例，不过也可能还是会创建出新的实例，一般用在类声明上。不过我似乎并没看出使用和不使用有什么区别，所以也就不多嘴了。</p><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="Lazy"></a>Lazy<T></h3><p>懒加载，只有第一次使用的时候才会真正的去创建实例。它的适用场景还是比较容易想到，比如有一些开销比较大的对象，但是又不一定会马上用到，甚至不会用上，那么只有真正用上的时候再创建是是再好不过的了。比如要懒加载 <code>presenter</code>，就可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="keyword">protected</span> Lazy&lt;MainContract.BaseMainPresenter&gt; presenter;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">presenter.get().loadMsg();</span><br></pre></td></tr></table></figure><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider<T></h3><p>有时候可能需要很多的实例，而不是一次注入就一直是这么一个实例了。这种需求非常适合 stateful 实例，能够保证每次都能拿到一个全新的实例，不会受之前的操作影响。代码实现是这样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span> Provider&lt;MainContract.BaseMainPresenter&gt; presenterProvider;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">presenterProvider.get().loadMsg();</span><br></pre></td></tr></table></figure><blockquote><p>这个例子不太恰当，不过懂大概意思就好了。</p></blockquote><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>Dagger2 是静态解析的，直接通过类型来进行辨别依赖关系，但是有时候光凭类型还不能确定一个依赖，那么就需要为 Dagger2 提供额外的信息，Dagger2 使用 <code>@Named</code> 来完成这种额外约束。下面演示一下这种需求场景的代码，还是继续改造我们的 <code>MainPresenter</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainPresenter</span> <span class="keyword">extends</span> <span class="title class_">MainContract</span>.BaseMainPresenter &#123;</span><br><span class="line">    <span class="keyword">private</span> Repo local;</span><br><span class="line">    <span class="keyword">private</span> Repo remote;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainPresenter</span><span class="params">(Repo local, Repo remote)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.local = local;</span><br><span class="line">        <span class="built_in">this</span>.remote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候 <code>MainPresenter</code> 多了两个 Repo 依赖，那么 <code>MainModule</code> 也需要做相应的更改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainModule</span> &#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Reusable</span></span><br><span class="line">    <span class="keyword">public</span> MainContract.BaseMainPresenter <span class="title function_">provideMainPresenter</span><span class="params">(</span></span><br><span class="line"><span class="params">            Repo local, Repo remote)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MainPresenter</span>(local, remote);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> Repo <span class="title function_">provideLocalRepo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalRepo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> Repo <span class="title function_">provideRemoteRepo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalRepo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看着没问题，不过 Dagger2 不认，它不知道你方法名字有啥意思，也不知道你方法内部怎么的。<br>所以我们需要使用 <code>@Named</code> 来帮助 Dagger2 判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainModule</span> &#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Reusable</span></span><br><span class="line">    <span class="keyword">public</span> MainContract.BaseMainPresenter <span class="title function_">provideMainPresenter</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Named(&quot;local&quot;)</span> Repo local, <span class="meta">@Named(&quot;remote&quot;)</span> Repo remote)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MainPresenter</span>(local, remote);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named(&quot;local&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Repo <span class="title function_">provideLocalRepo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalRepo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named(&quot;remote&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Repo <span class="title function_">provideRemoteRepo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RemoteRepo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就 OK 了。</p><blockquote><p>这里例子也不是很恰当，Repo 应该有一个良好的封装，Presenter 是不应该知道有 Remote 和 Local 的区别的</p></blockquote><h3 id="BindsInstance"><a href="#BindsInstance" class="headerlink" title="@BindsInstance"></a>@BindsInstance</h3><p>用在 <code>Component</code> 或 <code>SubComponent</code> 的 <code>Builder</code> 的方法上，它允许我们在构建 <code>DaggerXXXX</code> 的时候主动提供依赖到依赖树中。还是用例子来说明，<code>MainPresenter</code> 能够通过 <code>loadMsg()</code> 来获取一条消息，但是按照常理，我们还得告诉它一个 <code>address</code>，不能让它 xjb 找，所以还得改改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainPresenter</span> <span class="keyword">extends</span> <span class="title class_">MainContract</span>.BaseMainPresenter &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainPresenter</span><span class="params">(String address, Repo local, Repo remote)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.local = local;</span><br><span class="line">        <span class="built_in">this</span>.remote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MainModule</code> 中再加个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainModule</span> &#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Reusable</span></span><br><span class="line">    <span class="keyword">public</span> MainContract.BaseMainPresenter <span class="title function_">provideMainPresenter</span><span class="params">(</span></span><br><span class="line"><span class="params">            String address, <span class="meta">@Named(&quot;local&quot;)</span> Repo local, <span class="meta">@Named(&quot;remote&quot;)</span> Repo remote</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MainPresenter</span>(address, local, remote);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以了！<br>这样还可以把 Activity 的实例绑定上去，只要要注意下内存泄漏问题。</p><blockquote><p>也可以通过手动创建 <code>MainModule</code> 实例来完成一些依赖的传递。</p></blockquote><blockquote><p>到这里，一些基本的、常用的方法就讲得差不多，更多的还是要自己踩坑，经验这东西也不好说。<br>Dagger2 的使用方式非常像配置文件，把依赖的构建过程从具体的业务逻辑或其它逻辑中抽离出来，使业务代码变得清晰，然后拓展性、可测试性也提高了。<br>如果是 Android 开发的话，可能带来的问题就是方法数增多，不过也不算大问题，毕竟还有 multidex，如果使用了热修复、插件化等技术的话，可能还需要折腾下。</p></blockquote><p>完整代码在 <a target="_blank" rel="noopener" href="https://github.com/dashMrl/Android_Demos/tree/90f5715ecfddb74f11bb393c6f4f00e931a2d96a">这里</a></p><blockquote><p>关于 Dagger2 一些更高级的用法，我们下一篇文章再交流（再不复习怕是要挂了）</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/">控制反转（IoC）与依赖注入（DI</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dagger2 </tag>
            
            <tag> IOC </tag>
            
            <tag> DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 搭建静态博客</title>
      <link href="/2017/12/30/d218002a591d.html"/>
      <url>/2017/12/30/d218002a591d.html</url>
      
        <content type="html"><![CDATA[<p>上次搭的博客写了两篇 Hexo 的配置后就凉了，所以这次刚刚搭好的时候就没想做个记录，怕和上次一样，把写博客的热情全花在了搭建博客上。</p><span id="more"></span><blockquote><p>系统平台是 Ubuntu 17.04，其他平台的安装过程可能会有一些不同，不过后面的配置还是一样的。这里只有安装配置过程，具体使用，还请移步官方文档。<br>建议先看完再进行操作！！！</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>hexo 是一个基于 node 的静态博客生成工具，所以先安装 node ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nodejs</span><br></pre></td></tr></table></figure><p>这样安装似乎没有像 windows 下那样顺带把 npm 也给安装了，所以还需要安装一下 npm ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install npm</span><br></pre></td></tr></table></figure><p>再接着安装 Hexo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo -g</span><br></pre></td></tr></table></figure><blockquote><p>很多朋友会遇到 <code>Permission denied</code> 的错误，所以我们需要使用 <code>sudo</code> 安装</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在有读写权限的目录下执行，Blog 可以换成你喜欢的名字</span></span><br><span class="line">mkdir Blog &amp;&amp; cd Blog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化 Blog</span></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>不出问题，写作环境就安装好了，再测试下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成静态资源</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在本地启动 node 静态资源服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开命令行里面输出的 <code>http://27.0.0.1:4000</code>，就能看到一篇 <strong>hello world</strong></p><p>这里把安装命令整理一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nodejs npm</span><br><span class="line">sudo npm install hexo -g</span><br><span class="line">mkdir Blog &amp;&amp; cd Blog</span><br><span class="line">hexo init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面的命令是为了安装某些正常安装但安装失败的依赖</span></span><br><span class="line">npm install -f</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>完成最基本的安装后， Blog 的目录结构大概是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── page.md</span><br><span class="line">│   └── post.md</span><br><span class="line">├── source</span><br><span class="line">│   └── _posts</span><br><span class="line">│       └── hello-world.md</span><br><span class="line">├── themes</span><br><span class="line">│   └── landscape</span><br><span class="line">├── package.json</span><br><span class="line">└── _config.yml</span><br></pre></td></tr></table></figure><p>每个都简单说明一下：</p><ul><li><p>node_modules</p><p>差不多是一个本地运行环境，一般情况下是不需要动它的</p></li><li><p>sacffolds</p><p>里面都是模板文件，可以打开看看，后面会进行一些修改</p></li><li><p>source</p><p>这里放的是我们的源文件，文章和图片等</p></li><li><p>themes</p><p>这里放的是一些主题，不同的文件夹就是不同的主题，目录名就是主题名</p></li><li><p>package.json</p><p>Blog 工程的配置文件，一般情况下也不会动</p></li><li><p>_config.yml</p><p>站点配置文件，定制化需要对它进行一些修改，我们下文也叫它 <strong>站点配置文件</strong></p></li></ul><h2 id="站点基础配置"><a href="#站点基础配置" class="headerlink" title="站点基础配置"></a>站点基础配置</h2><p>首先打开 <code>站点配置文件</code>，将 <code>#Site</code> 信息根据你的情况配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&quot;Backyard&quot;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&quot;敲敲代码，扯扯蛋&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;dashMrl&#x27;s 个人小站————笔记+随笔&quot;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">dashMrl</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure><p>然后修改 <code># Deployment</code> 部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:dashMrl/dashMrl.github.io.git</span></span><br></pre></td></tr></table></figure><blockquote><p>这里默认你知道怎么启用 GithubPages 服务，避免每次部署输入密码，我们使用 ssh密钥的方式部署</p></blockquote><p>完成这些基本配置，就可以比较舒服的开始写博客了，如果你还需要更多定制化，接着往下看。</p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>到现在我们还是使用的默认主题 —— landscape，以我的审美来看，还是挺挫的。这里我们选择 Next 主题，这也是 GItHub 上 star 最多的一个主题。</p><blockquote><p>如果觉得 Next 主题样式还行，也能满足你的大部分需求，就用它吧，其他的主题可能真的会有很多小问题，亲测</p></blockquote><p>每个主题文件下都有一个 <code>_config.yml</code> 文件，这里我们就叫它 <strong>主题配置文件</strong> 。</p><p>首先去 Github 下载 Next 主题的 release 版本，解压到 thems 目录下，改名 <code>next</code> ，然后修改 <strong>站点配置文件</strong> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>再次执行 <code>hexo g &amp;&amp; hexo s</code> 就可以看到生效的主题。</p><blockquote><p>关于一些基本的配置，Next 的使用文档上都有，这里就只调我觉得重要的讲</p></blockquote><h3 id="阅读更多按钮"><a href="#阅读更多按钮" class="headerlink" title="阅读更多按钮"></a>阅读更多按钮</h3><p>默认情况下首页会将整篇文章显示出来，非常丑陋并且影响阅读，所以有时候只想显示一小段描述。</p><p>在 <strong>主题配置文件</strong> 中找到 <code>auto_excerpt</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>上面这种方式是截取 <strong>前 80</strong>  字符作为描述，如果想要精确控制的话，关闭 <code>auto_excerpt</code>使用 <code>&lt;--! more --&gt;</code> 来截断。我比较懒，就直接默认截取前80了。</p><h3 id="back-2-top-按钮设置"><a href="#back-2-top-按钮设置" class="headerlink" title="back 2 top 按钮设置"></a>back 2 top 按钮设置</h3><p>在 <strong>主题配置文件</strong> 找到 <code>sidebar</code> 设置项，将相应子设置改成：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line"><span class="attr">onmobile:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样就能够在 backtotop 按钮上显示当前阅读的百分比了。</p><h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>在 <strong>主题配置文件</strong>  找到 <code>Post wordcount display settings</code> ，修改成下面样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">totalcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置完后我们还需要安装 <code>hexo-wordcount</code> 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save-dev</span><br></pre></td></tr></table></figure><p>这样就能显示每篇文章字数和大概阅读时长，同时在页面底部显示整个站点的字数，，感觉挺有用的。</p><h3 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h3><p>在 <strong>主题配置文件</strong> 中找到 <code>#Local Search</code> ，修改成这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后在 <strong>站点配置文件</strong>  里你开心的位置加上&#x2F;修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>最后安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>还有更多的细节配置，就不一个个讲了，自己看 <strong>主题配置文件</strong> ，里面都有介绍，按照自己的需求配置就行了。</p></blockquote><h2 id="高级定制"><a href="#高级定制" class="headerlink" title="高级定制"></a>高级定制</h2><p>有时候还需要对博客进行一些优化配置，比如资源压缩等，需要我们添加一些插件甚至修改框架文件。</p><h3 id="文章链接优化"><a href="#文章链接优化" class="headerlink" title="文章链接优化"></a>文章链接优化</h3><p>默认情况下，文章链接是 <code>year/month/day/title</code> 的形式，这样的链接层级对搜索引擎很不友好，当标题里包含中文的时候链接还会因为编码的问题变得丑陋异常。这里我们使用 <code>hexo-abbrlink</code> 插件对此进行优化。</p><p>在 <strong>站点配置文件</strong> 里找到 <code>#URL</code> 配置部分，然后修改成下面这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://xinsbackyard.tech</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span></span><br></pre></td></tr></table></figure><p>这样每篇文章就会有一个类似 <code>f4a6041.html</code> 的链接了，而且还提升了逼格。</p><blockquote><p>配置完了记得安装插件（虽然应该先安装再配置来着的）</p></blockquote><h3 id="RSS-订阅"><a href="#RSS-订阅" class="headerlink" title="RSS 订阅"></a>RSS 订阅</h3><p>提供 RSS 订阅功能，让关注我们博客的朋友及时收到新文章的“推送”，虽然我自己没有用过 RSS ，但是感觉还是很牛逼的样子，既然这么牛逼，肯定要加上。</p><p>在 <strong>站点配置文件</strong> 中你开心的位置上加上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSS</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure><p> 然后安装 <code>hexo-generator-feed</code> 插件。</p><h3 id="添加站点运行时长"><a href="#添加站点运行时长" class="headerlink" title="添加站点运行时长"></a>添加站点运行时长</h3><p>在网页底部显示 <code>本站已运行 0 年 12 天 1 小时 33 分钟 4 秒</code> 这样的字样，虽然并没有什么实质上的作用，但是以后看着自己的博客运行了这么久，发布了多少篇文章还是挺不错的。</p><blockquote><p>这里以 Next 主题为例，其它的主题应该类似的</p></blockquote><p>在 next 文件夹找到 <code>layout/_partials/footer.swig</code> 文件，然后找到这一段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.<span class="property">footer</span>.<span class="property">custom_text</span> %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>在它前面加上 <code>&lt;div id=&quot;showDays&quot;&gt;本站已运行 0 年 0 天 0 小时 0 分钟 0 秒&lt;/div&gt;</code> ，然后在它后面加上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> seconds = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">var</span> minutes = seconds * <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">var</span> hours = minutes * <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">var</span> days = hours * <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">var</span> years = days * <span class="number">365</span>;</span><br><span class="line">  <span class="keyword">var</span> birthDay = <span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2017</span>,<span class="number">12</span>,<span class="number">19</span>,<span class="number">14</span>,<span class="number">00</span>,<span class="number">00</span>); <span class="comment">// 这里设置建站时间</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> todayYear = today.<span class="title function_">getFullYear</span>();</span><br><span class="line">    <span class="keyword">var</span> todayMonth = today.<span class="title function_">getMonth</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> todayDate = today.<span class="title function_">getDate</span>();</span><br><span class="line">    <span class="keyword">var</span> todayHour = today.<span class="title function_">getHours</span>();</span><br><span class="line">    <span class="keyword">var</span> todayMinute = today.<span class="title function_">getMinutes</span>();</span><br><span class="line">    <span class="keyword">var</span> todaySecond = today.<span class="title function_">getSeconds</span>();</span><br><span class="line">    <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">UTC</span>(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);</span><br><span class="line">    <span class="keyword">var</span> diff = now - birthDay;</span><br><span class="line">    <span class="keyword">var</span> diffYears = <span class="title class_">Math</span>.<span class="title function_">floor</span>(diff/years);</span><br><span class="line">    <span class="keyword">var</span> diffDays = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff/days)-diffYears*<span class="number">365</span>);</span><br><span class="line">    <span class="keyword">var</span> diffHours = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff-(diffYears*<span class="number">365</span>+diffDays)*days)/hours);</span><br><span class="line">    <span class="keyword">var</span> diffMinutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours)/minutes);</span><br><span class="line">    <span class="keyword">var</span> diffSeconds = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;showDays&#x27;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;本站已运行 &quot;</span>+diffYears+<span class="string">&quot; 年 &quot;</span>+diffDays+<span class="string">&quot; 天 &quot;</span>+diffHours+<span class="string">&quot; 小时 &quot;</span>+diffMinutes+<span class="string">&quot; 分钟 &quot;</span>+diffSeconds+<span class="string">&quot; 秒&quot;</span>;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这时候就可以在网页底部显示运行时间了。不过问题也来了，当我们在手机浏览器中加载网页的时候，底部因为太高而挡住了帖子中阅读更多按钮，所以为了避免这种情况，我们把 <code>Powered by Hexo</code> 等推广字样去掉（在这里对 Hexo 和 Next 说声抱歉）。</p><p>在 <strong>站点配置文件</strong> 里找到 <code>footer:</code> 配置，然后修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这样就算完成了。</p><blockquote><p>如果学过 web 开发的话，可以把它们改得“面目全非”</p></blockquote><h3 id="修改-tag-图标"><a href="#修改-tag-图标" class="headerlink" title="修改 tag 图标"></a>修改 tag 图标</h3><p>每篇文章底部都会显示几个 <code>#tagname</code>  ，这个 # 号觉着不怎么好看，换成图标。</p><p>在 next 文件夹中找到 <code>layout/_macro/post.swig</code> ，找到 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">&lt;div class=&quot;post-tags&quot;&gt;</span><br><span class="line">    &#123;% for tag in post.tags %&#125;</span><br><span class="line">            &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt; #&#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">         &#123;% endfor %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>把 <code>&#123;&#123; tag.name &#125;&#125;</code> 前面的 <strong>#</strong> 改成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code> 。这样就 OK 了。</p><h3 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h3><p>Hexo 生成的静态资源中有很多的空行空格，然后我们的图片也有比较大的优化空间，为了减小它们的体积，提高加载速速，需要对其进行一定程度的压缩。</p><p>这里我们使用 Gulp 来压缩资源，首先安装必要的依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp gulp-clean-css gulp-html-clean gulp-htmlmin gulp-imagemin gulp-uglify --save-dev</span><br></pre></td></tr></table></figure><p>然后在博客根目录下添加 <code>gulpfile.js</code> 文件，并写入如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">&#x27;gulp-clean-css&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlmin&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlclean&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-imagemin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩html</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-html&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;public/**/*.html&#x27;</span>)</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">htmlclean</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">htmlmin</span>(&#123;</span><br><span class="line">            <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,<span class="comment">//压缩HTML</span></span><br><span class="line">            <span class="attr">removeEmptyAttributes</span>: <span class="literal">true</span>,<span class="comment">//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;</span></span><br><span class="line">            <span class="attr">minifyJS</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minifyURLs</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩css</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-css&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>([<span class="string">&#x27;public/css/**/*.css&#x27;</span>, <span class="string">&#x27;!public/css/**/*min.css&#x27;</span>])</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">minifycss</span>(&#123; <span class="attr">compatibility</span>: <span class="string">&#x27;ie8&#x27;</span> &#125;))</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;public/css&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩js</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-js&#x27;</span>,  <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>([<span class="string">&#x27;public/js/**/*.js&#x27;</span>, <span class="string">&#x27;!public/js/**/*min.js&#x27;</span>])</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">uglify</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;public/js&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩图片</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-images&#x27;</span>,  <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;public/images/**/*.*&#x27;</span>)</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">imagemin</span>(</span><br><span class="line">            [imagemin.<span class="title function_">gifsicle</span>(&#123; <span class="string">&#x27;optimizationLevel&#x27;</span>: <span class="number">3</span> &#125;),</span><br><span class="line">            imagemin.<span class="title function_">jpegtran</span>(&#123; <span class="string">&#x27;progressive&#x27;</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"><span class="comment">//在我电脑上下面这一行会报错</span></span><br><span class="line"><span class="comment">//            imagemin.optipng(&#123; &#x27;optimizationLevel&#x27;: 5 &#125;),</span></span><br><span class="line">            imagemin.<span class="title function_">svgo</span>()],</span><br><span class="line">            &#123; <span class="string">&#x27;verbose&#x27;</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;public/images&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 默认任务</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;default&#x27;</span>, [</span><br><span class="line">    <span class="string">&#x27;minify-html&#x27;</span>, <span class="string">&#x27;minify-css&#x27;</span>, <span class="string">&#x27;minify-js&#x27;</span>, <span class="string">&#x27;minify-images&#x27;</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>然后在每次部署博客之前都执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure><p>如果站点的文本文件比重大的话，压缩效果还是很可观的。</p><h2 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h2><p>其实 SEO 也可以放在上一节中，但是 SEO 算是比较不同的配置，所以就拿出来单独讲。</p><h3 id="生成-sitemap"><a href="#生成-sitemap" class="headerlink" title="生成 sitemap"></a>生成 sitemap</h3><p>我们需要把站点内容主动推给搜索引擎，推送载体就是 sitemap。打开 <strong>站点配置文件</strong> ，在你开心的位置添加上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site Map</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><p>然后安装 <code>hexo-generator-sitemap</code> 和 <code>hexo-generator-baidu-sitemap</code> 两个插件。</p><h3 id="认证网站所有权"><a href="#认证网站所有权" class="headerlink" title="认证网站所有权"></a>认证网站所有权</h3><p>这里需要分 Google 和 百度 分别认证，具体怎么认证，有很多优秀的博客有讲，这里就不赘述了</p><h3 id="主动-x2F-自动推送"><a href="#主动-x2F-自动推送" class="headerlink" title="主动&#x2F;自动推送"></a>主动&#x2F;自动推送</h3><p>这里主要是针对百度的，因为 Github 把百度的爬虫给屏蔽了(虽然不知道为什么，但觉得百度好委屈hhh)。在百度站长认证完网站所有权之后就可以推送链接了，有被动爬取(被屏蔽)、自动推送和主动推送三种方式。</p><p>要开启自动推送非常简单，Next 帮我们把推送脚本内置了，只需要在 <strong>主题配置文件</strong> 里开启 <code>baidu_push: true</code> 就可以了。</p><p>至于主动推送，就是我们按照一定格式手工推送链接。emmm，手工？不存在的，这么无聊的事情肯定要自动化，然后就是考虑推送时机，更新博客的时候最合适，所以我们写一个博客的 <strong>部署脚本</strong> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">statusCheck()&#123;</span><br><span class="line">    if [ $? != 0 ]</span><br><span class="line">    then</span><br><span class="line">        echo -n $1&#x27; failed!!\n&#x27;</span><br><span class="line">        exit $?</span><br><span class="line">    else</span><br><span class="line">        echo -n $1&#x27; completed!!\n&#x27;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">echo &#x27;start cleaning...&#x27;</span><br><span class="line">node_modules/hexo/bin/hexo clean</span><br><span class="line">statusCheck &#x27;cleaning public resource&#x27;</span><br><span class="line"></span><br><span class="line">echo &#x27;start generating...&#x27;</span><br><span class="line">node_modules/hexo/bin/hexo g</span><br><span class="line">statusCheck &#x27;generating public resource&#x27;</span><br><span class="line"></span><br><span class="line">echo &#x27;start compressing by gulp...&#x27;</span><br><span class="line">node_modules/gulp/bin/gulp.js</span><br><span class="line">statusCheck &#x27;compressing public resource&#x27;</span><br><span class="line"></span><br><span class="line">echo &#x27;start deploying...&#x27;</span><br><span class="line">node_modules/hexo/bin/hexo d</span><br><span class="line">statusCheck &#x27;deploying to repository&#x27;</span><br><span class="line"></span><br><span class="line">echo &#x27;start upload sitemap to baidu&#x27;</span><br><span class="line">cat public/sitemap.xml | grep loc| grep -o &#x27;https://xinsbackyard.tech/posts/.*\.html&#x27; &gt; public/urls.txt</span><br><span class="line">curl -H &#x27;Content-Type:text/plain&#x27; --data-binary @public/urls.txt &quot;http://data.zz.baidu.com/urls?site=https://xinsbackyard.tech&amp;token=tZapjdbbZwBxt7WV&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">rm</span> public/urls.txt</span></span><br><span class="line">statusCheck &#x27;push links to baidu&#x27;</span><br><span class="line"></span><br><span class="line">echo &#x27;completed...&#x27;</span><br></pre></td></tr></table></figure><h2 id="PWA-改造"><a href="#PWA-改造" class="headerlink" title="PWA 改造"></a>PWA 改造</h2><p>PWA（渐进式 WebApp）在国内还一直不愠不火，但是 PWA 在提高用户体验方面确实有很大的作用，国外有很多案例（没亲自考证）。更重要的一点是，如果你使用原生系统，并且使用 Chrome 浏览 PWA 改造过的站点，Chrome 会根据用户的浏览情况来弹出 <code>添加该站点到主屏幕</code> 的请求窗口，当点击确认后， <strong>应用抽屉</strong> 里就会出现一个你站点的 “App”，你没看错，是和我们从应用商店安装的应用待在一个地方，而且还能在系统设置里看到它。</p><h3 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h3><p>就像一个 Android App 一样，我们需要提供一个清单文件来描述我们的站点，它大概长这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Backyard&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;short_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Backyard&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dashMrl&#x27;s 后花园——笔记+随笔&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 这里设置成 standalone 很重要，不然不会显示为一个单独的应用</span></span><br><span class="line">  <span class="attr">&quot;display&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standalone&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 下面的两个颜色可以设置一样，会配合图标生成一个启动页</span></span><br><span class="line">  <span class="attr">&quot;theme_color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#272727&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;background_color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#272727&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;start_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/?pwa=true&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 下面是 PWA 安装到手机上后显示的图标，最高需要提供到 512x512（我找遍了都没找到我头像这种分辨率的图，QAQ）</span></span><br><span class="line">  <span class="attr">&quot;icons&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icons/touch48.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;48x48&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icons/touch72.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;72x72&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icons/touch96.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;96x96&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icons/touch144.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;144x144&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icons/touch168.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;168x168&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icons/touch192.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192x192&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后把这个文件丢到 <code>source</code> 文件夹下面，再修改 <code>.../themes/next/layout/_partials/head.swig</code> 文件使得每个页面都声明 manifest ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;link rel=<span class="string">&quot;manifest&quot;</span> href=<span class="string">&quot;/manifest.json&quot;</span>&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>还有一些辅助我们生成这个文件的网站，大家可以自行搜索，如果想要深入了解这个文件，可以前往 MDN 上学习。</p><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>这算是 PWA 精髓所在了，它的作用可以不恰当地理解为缓存。当我们第一次浏览某个网页的时候，浏览器会尝试注册这个 ServiceWorker，此时处于 <code>installing</code> 状态，注册成功后它就会运行在一个单独的进程，并处于 <code>active</code> 状态，然后当我们请求我们站内资源的时候，请求就会先经过 sw ，如果它恰好有缓存的话，直接返回，否则进行网络请求。当我们下一次访问这个站点的时候，如果 sw 的缓存没有过期，我们就可以接着使用缓存（和浏览器本身缓存很像）。</p><p>说了这么多，那到底怎么才能使用 sw 呢？也非常简单，首选打开 <strong>站点配置文件</strong> ，在合适的位置加入 ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># offline config passed to sw-precache</span></span><br><span class="line"><span class="attr">service-worker:</span></span><br><span class="line">  <span class="attr">maximumFileSizeToCacheInBytes:</span> <span class="number">5242880</span></span><br><span class="line">  <span class="attr">staticFileGlobs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">public/**/*.&#123;js,html,css,png,jpg,gif,webp,svg,eot,ttf,woff,woff2&#125;</span></span><br><span class="line">  <span class="attr">stripPrefix:</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">verbose:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p> 然后安装 <code>hexo-offline</code> 插件就可以了，这时候执行 <code>hexo g</code> 可以看到类似 “ INFO  Total precache size is about 5.17 MB for 153 resources ” 的字样，然后在 public 目录下会出现一个 <code>service-worker.js</code> 文件，这就表示它能缓存我们整个站点的文件。</p><h3 id="启用-HTTPS"><a href="#启用-HTTPS" class="headerlink" title="启用 HTTPS"></a>启用 HTTPS</h3><p>PWA 要求站内所有资源都通过 HTTPS 传输，如果使用的 GithubPages 的话，默认开启 HTTPS ，不需要我们操心。但是如果配置了自定义域名，GitHub 提供的 HTTPS 就无法开启了，如果你也和我一样想省时省钱的话，就是用 cloudflare 来提供 HTTPS 服务吧。具体怎么玩，大家自己亲自去实践吧hhh。</p><p>到现在应该是写得差不多了，写教程类的文章总是最累的（所以我偷工减料），即怕说得不够清楚，又怕说得太多不利于读者思考，更怕误导读者，所以还是向所有为人师者致敬。</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Pages </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Annotation 基础</title>
      <link href="/2017/12/30/9854b11baab4.html"/>
      <url>/2017/12/30/9854b11baab4.html</url>
      
        <content type="html"><![CDATA[<p>注解是一种元数据（metadata），它在虽然能提供关于程序的一些信息，但并不是程序本身的一部分。注解对被其标注的对象没有任何副作用。</p><span id="more"></span><p>关于注解的作用，主要有以下三点：</p><ul><li>为编译器提供信息：比如语法检查等</li><li>在编译或部署时进行一些处理：比如生成一些报表信息</li><li>运行时：主要通过反射来操作</li></ul><blockquote><p>这里假设读者对注解有一定的了解</p></blockquote><h2 id="表现形似"><a href="#表现形似" class="headerlink" title="表现形似"></a>表现形似</h2><p><code>@Override</code> 应该最常见的注解之一，比如一些注解可能还会有参数，那么就有点像 Java 的构造函数，不过参数位置没有固定，所以也就需要显示指定参数的名称和值。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>元注解（meta-annotation）： 用来自定义注解时使用</li><li>标注注解： 即 JDK 自带的，有 <code>Override</code>，<code>Deprecated</code> 等</li><li>自定义注解： 即我们为满足某种需求而自定义的注解</li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>最快学习 Annotation 的方式还是自定义注解，下面我们就来定义一个 <code>Message</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Message&#123;</span><br><span class="line">  String content <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以划分为 5 个部分，我们都过一遍：</p><h3 id="Documented"><a href="#Documented" class="headerlink" title="Documented"></a>Documented</h3><p>根据名字可以判断，它和代码文档有关。我们的 <code>Message</code> 被它标注了，那么当对一个 <code>A</code> 类使用 <code>Message</code> 注解时，文档生成工具（如 javadoc）会将 <code>Message</code> 的信息也输出；反之，当 <code>Message</code> 没有被 <code>@Documented</code> 标记的时候，那么文档生成工具的输出中将不会保留 <code>Message</code> 相关的信息</p><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="Inherited"></a>Inherited</h3><p>表示这个注解可以被继承，具体表现是：父类 <code>A</code> 被 <code>Message</code> 标注，通过 <code>A</code> 的子类 <code>B</code> 也能直接拿到 <code>Message</code> 相关信息。内部的逻辑是：当在子类 <code>B</code> 上查询 <code>Message</code> 的时候，如果 <code>B</code> 没有被标注，那么就接着查询父类 <code>A</code>，如此直到找到或者查询到 Object。</p><h3 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h3><p>表明注解信息将会被保留到什么时候，这里的例子表明会保存到运行时，如果不使用这个元注解或者不指定保存时期，默认是留到字节码中（即  RetentionPolicy.CLASS）。<br>关于 RetentionPolicy，可以简单的记一张表格：</p><table><thead><tr><th align="left">RetentionPolicy</th><th align="left">Effects</th></tr></thead><tbody><tr><td align="left">SOURCE</td><td align="left">注解只会存在于源码中，编译时将会被编译器去除</td></tr><tr><td align="left">CLASS</td><td align="left">存在于源码和字节码中，但是不会被 VM 载入到运行时</td></tr><tr><td align="left">RUNTIME</td><td align="left">存在于源码和字节码中，并且会被 VM 载入，这时可以通过反射读取</td></tr></tbody></table><h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p>表示哪些元素可以被这个注解标记，这里的例子中表示只能使用在 <strong>类</strong> 上面。我们还是用一张表格来说明：</p><table><thead><tr><th align="left">ElementType</th><th align="left">Effects</th></tr></thead><tbody><tr><td align="left">ANNOTATION_TYPE</td><td align="left">用于注解，类似元注解</td></tr><tr><td align="left">TYPE_USE</td><td align="left">用在泛型上，比如 &lt;@Message T&gt;</td></tr><tr><td align="left">PACKAGE</td><td align="left">用在包上</td></tr><tr><td align="left">TYPE</td><td align="left">用在类、接口、枚举类以及注解上</td></tr><tr><td align="left">FIELD</td><td align="left">用在成员变量上</td></tr><tr><td align="left">CONSTRUCTOR</td><td align="left">用在构造器上</td></tr><tr><td align="left">METHOD</td><td align="left">用在方法上</td></tr><tr><td align="left">PARAMETER</td><td align="left">用在构造器、方法的参数上</td></tr><tr><td align="left">TYPE_PARAMETER</td><td align="left">用在构造器、方法的泛型参数上，比如 @Message T t</td></tr><tr><td align="left">LOCAL_VARIABLE</td><td align="left">用在本地变量上</td></tr></tbody></table><blockquote><p>当没有指定 Target 的时候，可以用在任何元素上</p></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>最后，我们看到 <code>Message</code> 内部还声明了一个类似成员变量的属性—— content，它的一般格式为： <code>&lt;Type&gt; &lt;name&gt;() [ default value ]</code> ，它的作用就是携带信息。<br>它支持如下的数据类型：</p><ul><li>基本类型（Primary Type）：byte、char、short、int、long、float、double</li><li>String</li><li>Class</li><li>Enum</li><li>Annotation</li><li>以上的数组形式</li></ul><blockquote><p>当参数名为 <code>value</code> 的时候，使用的时候可以不指定参数名，像这样：@Message(“2333”)</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用注解进行标注并携带信息，如果没有读取注解及携带信息的方法，那么注解就完全没有意义了。<br>我们前面提过，注解一般在编译时或运行时起作用，这里就看看怎么在运行时使用。<br>首先定义一个 <code>Messenger</code>，表示信使：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Message(content=&quot;hello world!!&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Messenger</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信使携带了一份消息，我们现在的问题就是怎么从他身上获取这消息。一开始也提到过，我们主要通过反射来进行操作，看我们的 main 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Messenger</span> <span class="variable">messenger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Messenger</span>();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Messenger</span>&gt; clazz = messenger.getClass();</span><br><span class="line"><span class="comment">//    Class&lt;Messenger&gt; clazz = Messenger.class;</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> clazz.getAnnotation(Message.class);</span><br><span class="line">    System.out.println(message.content());<span class="comment">//输出: hello world!!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能在运行获取到数据了，据此，我们也可以把一些配置信息写到注解里来减少编码。<br>不过需要注意的是，反射调用时会在虚拟机内存里遍历查找这个类的信息，这样的是比较低效的，所以这种方式不能滥用，而且有必要做好缓存。所以这种方式就不太适合性能敏感的场景，比如手机。</p><h2 id="注解处理器（Annotation-Processor）"><a href="#注解处理器（Annotation-Processor）" class="headerlink" title="注解处理器（Annotation Processor）"></a>注解处理器（Annotation Processor）</h2><p>我们现在已经能够在运行时获取到注解里面的信息，但是性能上的问题还是不能够忽视。文章开头也说过注解能够为编译器提供信息，所以我们可以在编译的时候做些手脚，以避免反射的开销。Java 提供了注解处理器来帮助开发者来在编译时期完成某些操作，关于它更多的信息，请看 <a href="/posts/ec0bc8d.html">下一篇文章</a>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Annotation Processor </tag>
            
            <tag> Annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp 拆轮子之连接池</title>
      <link href="/2017/12/30/e15546fa28ad.html"/>
      <url>/2017/12/30/e15546fa28ad.html</url>
      
        <content type="html"><![CDATA[<p>OkHttp 内部还维护了一个连接池，用于缓存一定数量的连接，以减少与服务器建立连接时的资源开销。同时，为了保证缓存的连接数在一个合理的水平，连接池有一个最多闲置连接数量和最长连接闲置时长。这里我们还是通过分析一些关键方法来分析它的连接池机制：</p><span id="more"></span><h2 id="ConnectionPool-get"><a href="#ConnectionPool-get" class="headerlink" title="ConnectionPool#get()"></a>ConnectionPool#get()</h2><p>这个方法用于从连接池中获取一个可用的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RealConnection <span class="title function_">get</span><span class="params">(Address address, StreamAllocation streamAllocation, Route route)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class="line">            streamAllocation.acquire(connection);</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现也很简单，遍历连接池，找到可用的就返回，没找到就返回null。</p><h2 id="ConnectionPool-put"><a href="#ConnectionPool-put" class="headerlink" title="ConnectionPool#put()"></a>ConnectionPool#put()</h2><p>每次新建一个连接，都会往这个连接池里面丢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(RealConnection connection)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">        cleanupRunning = <span class="literal">true</span>;</span><br><span class="line">        executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    connections.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先会判断有没有正在清理 <strong>多余</strong> 或者 <strong>闲置过久</strong> 的连接，没有的话，就先清理一波，然后把连接丢进去。</p><h2 id="连接池的维护"><a href="#连接池的维护" class="headerlink" title="连接池的维护"></a>连接池的维护</h2><p>连接池内部有一个专门负责清理冗余连接的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">cleanupRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">waitNanos</span> <span class="operator">=</span> cleanup(System.nanoTime());</span><br><span class="line">            <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">// 如果连接池为空，直接结束当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">                waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (ConnectionPool.<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 暂停当前线程，直到可能有过期的连接出现</span></span><br><span class="line">                        ConnectionPool.<span class="built_in">this</span>.wait(waitMillis, (<span class="type">int</span>) waitNanos);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">inUseConnectionCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idleConnectionCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">RealConnection</span> <span class="variable">longestIdleConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">longestIdleDurationNs</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"><span class="comment">//    下面的目的是找出一个需要关闭的连接或计算最短多久会有下一个连接过期</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">RealConnection</span> <span class="variable">connection</span> <span class="operator">=</span> i.next();</span><br><span class="line"><span class="comment">//    判断这个连接是否正在被使用，是就执行下一次循环</span></span><br><span class="line">            <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            idleConnectionCount++;</span><br><span class="line">            <span class="comment">// 找到最先过期的连接</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">idleDurationNs</span> <span class="operator">=</span> now - connection.idleAtNanos;</span><br><span class="line">            <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">                longestIdleDurationNs = idleDurationNs;</span><br><span class="line">                longestIdleConnection = connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//    下面一串的判断就是判断目标连接现在是否已经过期，过期就关闭，否则返回距离过期的时间差</span></span><br><span class="line">        <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="built_in">this</span>.keepAliveDurationNs</span><br><span class="line">                || idleConnectionCount &gt; <span class="built_in">this</span>.maxIdleConnections) &#123;</span><br><span class="line">            connections.remove(longestIdleConnection);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cleanupRunning = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概的意思就是这个清理线程一直运行，它会不断的检查是否有过期的连接并进行关闭，然后暂停特定时间来进行下一次清理。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>OkHttp 内部有一个很重要的类– <code>StreamAllocation</code> ，这个类协调了 <code>Connection</code> 、<code>Streams</code> 、<code>Calls</code> 之间的关系，作为一次请求（ Call ）的代表，在一个或多个连接（ Connection ）上传输一个或多个数据流（ Stream ）。<br>整个请求流程中，这个类最先出现在 <code>RetryAndFollowUpInterceptor</code> 里面，当简单了解这个类的内部实现之后，对请求的逻辑也能更好的理解。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal 源码分析</title>
      <link href="/2017/12/30/f6ffd4184e5e.html"/>
      <url>/2017/12/30/f6ffd4184e5e.html</url>
      
        <content type="html"><![CDATA[<p>在并发编程的时候，常常会遇到共享变量，通常为了保证数据的 <strong>一致性</strong> ，需要对变量加锁，这就导致了执行效率的降低。如果仅仅在线程内部访问，就不需要进行加锁，这时候就体现出了数据的 <strong>独立性</strong> （这两个名词是随手造的，知道意思就好了）。</p><span id="more"></span><p>ThreadLocal 类能够帮助我们实现数据独立性，它保证了线程单独持有一个变量，并且对这个变量的操作不会影响其它线程的值。具体的情况可能和我讲的你所理解的有些出入，下面我们通过源代码来深入探究。</p><h2 id="提供的API"><a href="#提供的API" class="headerlink" title="提供的API"></a>提供的API</h2><p>正式开始之前，先看看 ThreadLocal 这个类给我提供了哪些API</p><ul><li><strong>set(T value)</strong> <br/><br>给当前线程设置一个 ThreadLocal <strong>值</strong> 的拷贝</li><li><strong>T get()</strong> <br/><br> 获取当前线程保存的 ThreadLocal <strong>值</strong> 的拷贝</li><li><strong>remove()</strong> <br/><br> 移除当前线程保存的拷贝</li><li><strong>T initialValue()</strong> <br/><br> 当当前线程通过 <code>get()</code> 来第一次访问 Threadlocal 的时候被调用，然后会返回一个 <strong>T</strong> ，默认返回是 <code>null</code> 。 如果调用了 <code>remove()</code>，下一次又调用 <code>get()</code> ，这个方法还会被调用</li></ul><p>下面简单使用一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;init value&quot;</span></span><br><span class="line">    <span class="keyword">val</span> tl = ThreadLocal&lt;String&gt;()</span><br><span class="line">    tl.<span class="keyword">set</span>(str)</span><br><span class="line">    <span class="keyword">val</span> thread = Thread&#123;</span><br><span class="line">        tl.<span class="keyword">set</span>(<span class="string">&quot;child&#x27;s value&quot;</span>)</span><br><span class="line">        println(tl.<span class="keyword">get</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    thread.start()</span><br><span class="line">    thread.join()<span class="comment">//让子线程执行完</span></span><br><span class="line">    println(tl.<span class="keyword">get</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的预期结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child&#x27;s value</span><br><span class="line">init value</span><br></pre></td></tr></table></figure><p>运行之后的结果和上面一样。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>如果上面的代码没什么问题，我们接着写另一个例子。<br>为了演示方便，我们先定义一个 Foo 类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">var</span> name:String)</span><br></pre></td></tr></table></figure><p>然后再看我们的 main 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> foo = Foo(<span class="string">&quot;init value&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> tl = ThreadLocal&lt;Foo&gt;()</span><br><span class="line">    tl.<span class="keyword">set</span>(foo)</span><br><span class="line">    <span class="keyword">val</span> thread = Thread &#123;</span><br><span class="line">        tl.<span class="keyword">get</span>().name = <span class="string">&quot;changed in child&quot;</span></span><br><span class="line">        println(tl.<span class="keyword">get</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    thread.start()</span><br><span class="line">    thread.join()<span class="comment">//保证线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    println(tl.<span class="keyword">get</span>())</span><br><span class="line">    <span class="comment">//预期结果：</span></span><br><span class="line">    <span class="comment">//changed in child</span></span><br><span class="line">    <span class="comment">//init value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，Oops，崩了！！！<br>对比一下之前的例子，会发现第二个例子在子线程中首先通过 <code>get()</code> 获取 foo 实例。这里就存在一个问题，回过头看 <code>initialValue()</code> 函数的注释，发现这个线程正好符合它被调用的条件，所以我们会得到一个 <strong>NullPointException</strong> 。</p><p>既然 <code>initialValue()</code> 返回了一个 null 值，那么我们重写这个方法，返回一个合法值。改造之后的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tl = <span class="keyword">object</span>:ThreadLocal&lt;Foo&gt;()&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initialValue</span><span class="params">()</span></span>: Foo = Foo(<span class="string">&quot;init value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> thread = Thread &#123;</span><br><span class="line">        tl.<span class="keyword">get</span>().name = <span class="string">&quot;changed in child&quot;</span></span><br><span class="line">        println(tl.<span class="keyword">get</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    thread.start()</span><br><span class="line">    thread.join()<span class="comment">//保证线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    println(tl.<span class="keyword">get</span>())</span><br><span class="line">    <span class="comment">//预期结果：</span></span><br><span class="line">    <span class="comment">//changed in child</span></span><br><span class="line">    <span class="comment">//init value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，打印结果也确实和预期结果一致。不过还有个问题，如果我们执行 <code>println(tl.get().hashCode())</code> ，会发现两个对象不一样，因为不同线程的初始值都是新创建的 Foo 对象。有同学可能就会想到这样改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tl = <span class="keyword">object</span>:ThreadLocal&lt;Foo&gt;()&#123;</span><br><span class="line"><span class="keyword">val</span> foo = Foo(<span class="string">&quot;init value&quot;</span>)</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initialValue</span><span class="params">()</span></span>: Foo = foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就是实现了，不同线程的初始值是同一个实例了，不过这个初始值不是线程私有的，并发情况下还是会发生数据不同步的问题。到底怎么使用，根据具体情况吧。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>ThreadLocal 这个类还是比较简单，只有几个关键函数，我们一个个来分析：</p><h3 id="T-get"><a href="#T-get" class="headerlink" title="T get()"></a>T get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致意思为：</p><ul><li>获取当前线程的 ThreadLocalMap 实例</li><li>如果 ThreadLocalMap 实例为 null，创建并设置初值；否则以 this 为 key 从 ThreadLocalMap 里取值</li><li>如果取值不为 null，强转返回，否则调用 <code>initialValue()</code> 并返回<br>这里的 ThreadLocalMap 可以简单地看作一个散列表；然后 Entry 其实是 WeakReference 子类，这个弱引用保证在某些场景下不会发生 <strong>内存泄漏</strong>。</li></ul><h3 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set() 所做的工作非常简单：</p><ul><li>获取当前线程的 ThreadLocalMap 对象</li><li>如果ThreadLocalMap 不为 nul，从 ThreadLocalMap 中取值；如果为null，为当前线程创建ThreadLocalMap 实例并设置初始值</li></ul><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">         m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到当前线程的 ThreadLocalMap ，不为null 就清除值。调用这个方法之后，ThreadLocal 就重新进入刚创建时的状态了。</p><h2 id="关于线程私有"><a href="#关于线程私有" class="headerlink" title="关于线程私有"></a>关于线程私有</h2><p>Java 中对象都是存放在 heap（堆内存） 中，而堆内存是线程共享的，也就是说 ThreadLocal 保存的值还是线程共享的，只是代码逻辑给它提供了线程私有的属性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp 请求流程简析</title>
      <link href="/2017/12/30/64c1951fa4bf.html"/>
      <url>/2017/12/30/64c1951fa4bf.html</url>
      
        <content type="html"><![CDATA[<p>从 Android 4.4 开始，<code>HttpURLConnection</code>  底层使用 OkHttp 实现，所以阅读并学习它的源码就显得更加地理所应当。</p><span id="more"></span><blockquote><p>为了简洁起见，我们去除源码中一些健壮性代码。</p><p>本文基于 OkHttp 3.8.1</p></blockquote><h2 id="分析案例"><a href="#分析案例" class="headerlink" title="分析案例"></a>分析案例</h2><p>这里我们选用最简单的 GET 请求来分析 OKHttp 的内部工作大体流程。</p><p>一般情况下的<strong>同步 GET</strong> 请求我们是以下面的方式发起的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .build();</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">    .build();</span><br><span class="line"><span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> client.newCall(request)；</span><br><span class="line"><span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> call.execute();</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">response.close();</span><br></pre></td></tr></table></figure><p>**异步 GET **请求又是下面这样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">        response.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调用 <code>call.execute()</code> 将会执行同步请求，执行 <code>call.enqueue()</code> 则会发起异步请求。</p><p>下面看看<strong>网络请求</strong>真正开始前做的动作。</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>真正开始之前，我们还是先看看一个请求执行的整体流程吧。</p><p><img src="https://i.loli.net/2017/12/30/5a476ca150d94.png"></p><h2 id="请求准备"><a href="#请求准备" class="headerlink" title="请求准备"></a>请求准备</h2><p>首先会构建 <strong>Request</strong> ，不管是 GET 还是 POST，然后调用 <code>OKHttpClient#newCall(request)</code> 得到一个表示请求的 <code>Call</code> 对象。</p><p>然后调用 <code>call.execute()</code> 或者 <code>call.enqueue()</code> 触发同步或异步请求。</p><p>先看一下 <code>okHttpClient.newCall(request)</code> 做了什么工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟着看 <code>RealCall#newRealCall()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> RealCall <span class="title function_">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="type">boolean</span> forWebSocket)</span> &#123;</span><br><span class="line">  <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">  <span class="type">RealCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealCall</span>(client, originalRequest, forWebSocket);</span><br><span class="line">  call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">  <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Call 只是一个接口，内部实际上给我们返回了 Call 的实现类 RealCall 的一个实例。</p><p>到了区分同步异步的地方了，为了方便分析，我们先看代码：</p><p>RealCall#execute()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">Response</span> <span class="variable">result</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RealCall#enqueue()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span> <span class="keyword">extends</span> <span class="title class_">NamedRunnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;<span class="comment">//线程启动后将会调用这个方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;<span class="comment">//请求取消了</span></span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="built_in">this</span>, response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      responseCallback.onFailure(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方式中，先将请求添加到 <code>DIspacher</code> 同步请求队列里，然后发起网络请求；而异步方式中，先将 <code>RealCall</code> 包装成一个 <code>AsyncCall</code> 然后添加到 <code>Dispatcher</code> 的异步请求队列里，这里 <code>AsyncCall</code> 是 <code>Runnable</code> 的一个子类，<code>run</code> 方法的内部实现会调用 <code>AsyncCall#execute()</code>，从而发起网络请求。</p><p>两种请求方式最终都是通过调用 <code>RealCall#getResponseWithInterceptor()</code> 来发起真正请求的，两种方式的区别只是在任务的管理方式不一样。</p><h2 id="发起真正的请求"><a href="#发起真正的请求" class="headerlink" title="发起真正的请求"></a>发起真正的请求</h2><p>上面我们分析知道，不管是同步还是异步请求，最终都是调用 <code>RealCall#getResponseWithInterceptors()</code> 来发起请求并获得响应。那么我们先看看这个方式内部做了一些什么样的工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">      interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest, <span class="built_in">this</span>, eventListener);</span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如这个方法的名称一样，这里构建了一个拦截器列表，然后通过 <code>RealInterceptorChain#proceed()</code> 方法的启动拦截器链。首先会将所有我们在构建 <code>OKHttpClient</code> 时添加的一系列 <strong>应用拦截器</strong> ，然后添加一些内置的拦截，最后添加的是 <strong>网络拦截器</strong>。</p><blockquote><p>应用拦截器和网络拦截器的区别我们另一篇文章见</p></blockquote><p>关于拦截器，我们这里暂时不做具体讨论，不过为了方便分析，还是看看拦截器的接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">  Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">    Request <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Response <span class="title function_">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the connection the request will be executed on. This is only available in the chains</span></span><br><span class="line"><span class="comment">     * of network interceptors; for application interceptors this is always null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span> Connection <span class="title function_">connection</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Interceptor</code> 定义还是非常简单，核心函数定义就只有一个——<code>intercept</code>  ，这个方法负责的就是处理传入的 <code>Request</code> ，然后传递给下一个拦截器，直到最后一个拦截器的时候，它就会将请求发送给服务器，然后获得相应并且返回。请求是如何在拦截器之间传递的呢？我们看到 <code>Interceptor</code>  内部还有一个 <code>Chain</code> 接口，这个就是一个抽象的拦截器链，在上面的代码中，它的实现类 <code>RealIntercetorChain</code> 调用 <code>proceed</code> 函数来开始拦截器的处理。我们看看这个 <code>RealInterceptor#proceed()</code>  方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span><br><span class="line"><span class="params">    RealConnection connection)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">  <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, streamAllocation, httpCodec,</span><br><span class="line">      connection, index + <span class="number">1</span>, request, call, eventListener);<span class="comment">//构建下一级的拦截器链</span></span><br><span class="line">  <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);<span class="comment">//获取下一个拦截器</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next);<span class="comment">//调用拦截器的拦截方法</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用已经用注释注明，然后我们看一眼拦截器的 <code>intercept</code> 内部的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//其他处理</span></span><br><span class="line">  response = chain.proceed(networkRequest);</span><br><span class="line"><span class="comment">//其他处理</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有列举具体的拦截器的代码，不过自定义过拦截器的同学应该都很熟悉上面的流程，除去对请求和响应的处理工作，核心语句就是调用 <code>Chain#intercept</code> ，反反复复，拦截器和拦截器链之间的相互调用，会将 <code>Request</code> 传递到最顶层的拦截器，最终向服务器发起请求报文并获得响应。</p><p>这里还是简单的讲一下每个拦截器的作用:</p><blockquote><ul><li>RetryAndFollowUpInterceptor</li></ul><p>处理失败重试和重定向问题，同时还负责控制请求的取消等操作</p><ul><li>BridgeInterceptor</li></ul><p>处理请求头，添加一些必要的头信息或者转换头信息</p><ul><li>CacheInterceptor</li></ul><p>缓存相关，如果缓存可用，就没必要从服务器获取响应，直接返回缓存的响应；如果缓存过期或不可用，则向服务器发起请求，获取响应之后缓存并返回</p><ul><li>ConnectInterceptor</li></ul><p>见名知意，他负责建立与服务器的连接，期间会进行三次握手，建立 TCP 连接；如果目前已经有了一条空闲的连接，则会直接使用这条连接，避免重新进行三次握手等建立连接</p><ul><li>CallServerInterceptor</li></ul><p>这是最顶级的拦截器，它前面的拦截器建立好了连接，那么这个拦截器就是负责向服务器发起具体的请求并获取响应</p></blockquote><p>现在还只是粗略的分析了请求的整体流程，关于其他具体的部分如 连接池、拦截器等，我们单独列出文章讲解。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Picasso 加载流程</title>
      <link href="/2017/12/30/54a15046a4d4.html"/>
      <url>/2017/12/30/54a15046a4d4.html</url>
      
        <content type="html"><![CDATA[<p>自己第一次写比较完整 app 还是去年暑假，当时参加现在的团队夏令营，组长要求我们不能使用第三方库（亏得自己还苦哈哈地看了几天各种第三方库），所以就得自己手写图片加载逻辑，所以也就遇到很多问题，比如错位、加载慢等。不过使用第三方库的话，一行代码就能解决这些问题。</p><span id="more"></span><p>不废话了，从我的角度来看，网上目前流行的图片加载库也就三款，Picasso、Glide 和 Fresco，而它们的功能也是依次递增。Glide 是 Google 员工基于 Picasso 进行的二次开发，Google 在自己的应用里面也大量使用；Fresco 则出自 Facebook 之手，由于使用 Native&#x2F;C 来缓存图片，所以一定程度上减少了 OOM 的可能。</p><p>现在大概清楚了三款库的定位，前两者专业性显然不如 Fresco，但是使用上简单，如果是应用内有大量的图片加载场景，如图库类应用，使用 Fresco 应该是个不错的选择。所以这次我们就选最简单的 Picasso 来分析，认怂。。。</p><p>图片加载库最经典的场景就是 <strong>从网络加载一张图片到 ImageView</strong> ， Picasso 对此给出了最简单的解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Picasso.with(context)</span><br><span class="line">    .load(<span class="string">&quot;http://i.imgur.com/DvpvklR.png&quot;</span>)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure><p>那么我们的分析也就针对这几行代码。</p><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><ul><li>OS：Ubuntu 17.04</li><li>IDE：Android Studio</li><li>Picasso：3.0.0-SNAPSHOT</li></ul><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>还是先看看一个简单的流程图：<br><img src="https://i.loli.net/2017/12/30/5a46800033c20.png"></p><h2 id="关键类剖析"><a href="#关键类剖析" class="headerlink" title="关键类剖析"></a>关键类剖析</h2><p>真正开始分析源码之前先简单地解下一些重要的类，以及相关的接口。</p><h3 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h3><p>图片加载的入口，主要是完成诸如 <strong>Downloader</strong> 、<strong>ExecutorService</strong> 、 <strong>Cache</strong> 、 <strong>RequestHandler</strong> 、<strong>Bitmap.Config</strong> 等的配置，如果没有使用自定义的配置，Picasso内部都有默认配置。</p><h3 id="RequestCreator"><a href="#RequestCreator" class="headerlink" title="RequestCreator"></a>RequestCreator</h3><p>这个类主要职责是构造一次图片加载的配置，比如 url、大小、动画等等，最后提交请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestCreator</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Picasso picasso;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Request.Builder data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> noFade;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> deferred;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">setPlaceholder</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> placeholderResId;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> errorResId;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> memoryPolicy;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> networkPolicy;</span><br><span class="line">  <span class="keyword">private</span> Drawable placeholderDrawable;</span><br><span class="line">  <span class="keyword">private</span> Drawable errorDrawable;</span><br><span class="line">  <span class="keyword">private</span> Object tag;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> willReplay;</span><br><span class="line">  <span class="type">boolean</span> cancelled;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>针对图片加载的目标对象，Action 对此进行了一个抽象，具体的由实现类实现，比如简单加载图片到 <code>ImageView</code> 中，那么就是 <code>ImageViewAction</code>，同理，<code>NotificationAction</code> 就是加载图片到 <code>Notification</code> 中。我们本次要分析的是 <code>ImageViewAction</code></p><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>加载任务的调度器，负责加载任务的开始、暂停、恢复以及失败之后的回调处理。</p><h3 id="BitmapHunter"><a href="#BitmapHunter" class="headerlink" title="BitmapHunter"></a>BitmapHunter</h3><p>Runnable 子类，具体图片加载的抽象，内部调用 Cache 、Downloader 提供的接口来完成 bitmap 的获取，也完成一些图片的转换操作。</p><h3 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h3><p>针对图片不同来源，比如从网络、磁盘、assets、resources 等获取，会有不同的 RequestHandler 子类处理。 Picasso 内部有个 RequestHandler 的集合，到遇到一个加载任务时，遍历这个集合并调用 <code>RequestHandler#canHandleRequest(Request data)</code> 方法来判断是否可以处理这个请求，当找到可以处理的就立即中断循环，没有则会得到一个 ERRORING_HANDLER 。而判断是否可以处理请求的依据就是我们传入的图片 uri ，源码中都很清晰。</p><p>这里我们的分析 <code>NetworkRequestHandler</code> 。</p><h3 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h3><p>下载网络图片的下载器接口，Picasso 默认实现是 OkHttp3Downloader。因为我们主要是分析图片加载流程，所以这一部分大概知道就行了。</p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>图片转换接口，在配置加载的时候传入自定义的 Transformation 实现可以实现诸如 <strong>圆形</strong>、<strong>高斯模糊</strong> 等。</p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>内存缓存接口，默认实现是 LruCache。Picasso 没有自己实现磁盘缓存，而是直接使用 OkHttp3 的磁盘缓存。</p><h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><p>图片加载完成之后的回调。</p><h2 id="流程剖析"><a href="#流程剖析" class="headerlink" title="流程剖析"></a>流程剖析</h2><p>关于 Picasso 初始化配置也有太多必要去看，直接从 <code>picasso#load()</code> 方法开始。</p><h3 id="创建请求并提交"><a href="#创建请求并提交" class="headerlink" title="创建请求并提交"></a>创建请求并提交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RequestCreator <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> Uri uri)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestCreator</span>(<span class="built_in">this</span>, uri, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的 <code>picasso#load()</code> 最终都会创建一个 <code>RequestCreator</code> 实例。然后调用 <code>RequestCreator#into()</code> 方法提交一个加载请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">into</span><span class="params">(ImageView target, Callback callback)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">started</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  checkMain();</span><br><span class="line"></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> createRequest(started);</span><br><span class="line">  <span class="type">String</span> <span class="variable">requestKey</span> <span class="operator">=</span> createKey(request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> picasso.quickMemoryCacheCheck(requestKey);</span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="literal">null</span>) &#123;</span><br><span class="line">      picasso.cancelRequest(target);</span><br><span class="line">      setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</span><br><span class="line">      <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        callback.onSuccess();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Action</span> <span class="variable">action</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImageViewAction</span>(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</span><br><span class="line">          errorDrawable, requestKey, tag, callback, noFade);</span><br><span class="line"></span><br><span class="line">  picasso.enqueueAndSubmit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有删改，只保留了和本次分析有关的关键代码。<br>首先是创建一个请求，但是并没有立即提交。然后查询 <strong>内存缓存</strong> ，如果内存有可用的缓存，设置 Bitmap 并回调；这里的 <strong>key</strong> 是根据 <code>Request</code> 来创建的，不同的请求配置，key 也会不一样。当缓存不可用时，就把 Request 封装成 <strong>Action</strong> ，然后交由 Picasso 来进行提交。</p><h3 id="提交过程"><a href="#提交过程" class="headerlink" title="提交过程"></a>提交过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">enqueueAndSubmit</span><span class="params">(Action action)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> action.getTarget();</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; targetToAction.get(target) != action) &#123;</span><br><span class="line">        cancelExistingRequest(target);</span><br><span class="line">        targetToAction.put(target, action);</span><br><span class="line">    &#125;</span><br><span class="line">    submit(action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Action action)</span> &#123;</span><br><span class="line">    dispatcher.dispatchSubmit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交时需要取消当前 ImageView 可能存的加载请求，同时放入 <strong>targetToAction</strong> 这个 Map 容器里，最后由 <strong>Dispatcher</strong> 进行调度。</p><h3 id="Dispatcher-中转"><a href="#Dispatcher-中转" class="headerlink" title="Dispatcher 中转"></a>Dispatcher 中转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchSubmit</span><span class="params">(Action action)</span> &#123;</span><br><span class="line">  handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">performSubmit</span><span class="params">(Action action, <span class="type">boolean</span> dismissFailed)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">    pausedActions.put(action.getTarget(), action);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">BitmapHunter</span> <span class="variable">hunter</span> <span class="operator">=</span> hunterMap.get(action.getKey());</span><br><span class="line">  <span class="keyword">if</span> (hunter != <span class="literal">null</span>) &#123;</span><br><span class="line">    hunter.attach(action);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hunter = forRequest(action.getPicasso(), <span class="built_in">this</span>, cache, stats, action);</span><br><span class="line">  hunter.future = service.submit(hunter);</span><br><span class="line">  hunterMap.put(action.getKey(), hunter);</span><br><span class="line">  <span class="keyword">if</span> (dismissFailed) &#123;</span><br><span class="line">    failedActions.remove(action.getTarget());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dispatcher 内部有一个用于消息转发的 <strong>Handler</strong> ，与此出现的是多对 <code>dispatchXXX()</code> 和 <code>performXXX()</code> 函数，利用 handler 的消息队列的特性，可以提高单个任务的处理速度。<br>至于这一对函数的工作就是拿到&#x2F;创建一个 BitmapHunter ，然后交由线程池执行加载任务。如果之前有相同的加载任务被暂停，那这次的加载任务也不会被执行，除非是执行 <code>Picasso.resumeXXX()</code> 操作。</p><p>BitmapHunter 的创建是由 <code>BitmapHunter#forRequest()</code> 来完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BitmapHunter <span class="title function_">forRequest</span><span class="params">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span></span><br><span class="line"><span class="params">                               Action action)</span> &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> action.getRequest();</span><br><span class="line">    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">RequestHandler</span> <span class="variable">requestHandler</span> <span class="operator">=</span> requestHandlers.get(i);</span><br><span class="line">        <span class="keyword">if</span> (requestHandler.canHandleRequest(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BitmapHunter</span>(picasso, dispatcher, cache, stats, action, requestHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BitmapHunter</span>(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会遍历内置的 RequestHandler，然后确定 BitmapHunter 的需要的 RequestHandler。</p><h3 id="BitmapHunter-加载工作"><a href="#BitmapHunter-加载工作" class="headerlink" title="BitmapHunter 加载工作"></a>BitmapHunter 加载工作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        updateThreadName(data);</span><br><span class="line">        result = hunt();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            dispatcher.dispatchFailed(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dispatcher.dispatchComplete(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        exception = e;</span><br><span class="line">        dispatcher.dispatchFailed(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bitmap <span class="title function_">hunt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">        bitmap = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="literal">null</span>) &#123;</span><br><span class="line">            loadedFrom = MEMORY;</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    networkPolicy = retryCount == <span class="number">0</span> ? NetworkPolicy.OFFLINE.index : networkPolicy;</span><br><span class="line">    RequestHandler.<span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> requestHandler.load(data, networkPolicy);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        loadedFrom = result.getLoadedFrom();</span><br><span class="line">        exifOrientation = result.getExifOrientation();</span><br><span class="line">        bitmap = result.getBitmap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there was no Bitmap then we need to decode it from the stream.</span></span><br><span class="line">        <span class="keyword">if</span> (bitmap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Source</span> <span class="variable">source</span> <span class="operator">=</span> result.getSource();</span><br><span class="line">            bitmap = decodeStream(source, data);</span><br><span class="line">            source.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.needsTransformation() || exifOrientation != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DECODE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.needsMatrixTransform() || exifOrientation != <span class="number">0</span>) &#123;</span><br><span class="line">                    bitmap = transformResult(data, bitmap, exifOrientation);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (data.hasCustomTransformations()) &#123;</span><br><span class="line">                    bitmap = applyCustomTransformations(data.transformations, bitmap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载逻辑在 <code>hunt()</code> 里面，这里会先再查询一次内存缓存，没找到就会去从网络下载（不同的Uri可能不同），从网络下载完之后可能需要对图片的方向进行一些调整，然后如果又配置 Transformation 的话，也会进行一些转换。bitmap 的后续操作都用 DECODE_LOCK 锁住，同一时间只有一张 bitmap 被处理，这样保证了不会对内存和 CPU 造成太大的压力。</p><h3 id="获取之后"><a href="#获取之后" class="headerlink" title="获取之后"></a>获取之后</h3><p>在获取到 bitmap 之后，又需要借助 Dispatcher 来完成后续的中转操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchComplete</span><span class="params">(BitmapHunter hunter)</span> &#123;</span><br><span class="line">  handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">performComplete</span><span class="params">(BitmapHunter hunter)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</span><br><span class="line">    cache.set(hunter.getKey(), hunter.getResult());</span><br><span class="line">  &#125;</span><br><span class="line">  hunterMap.remove(hunter.getKey());</span><br><span class="line">  batch(hunter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">batch</span><span class="params">(BitmapHunter hunter)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hunter.isCancelled()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hunter.result != <span class="literal">null</span>) &#123;</span><br><span class="line">    hunter.result.prepareToDraw();</span><br><span class="line">  &#125;</span><br><span class="line">  batch.add(hunter);</span><br><span class="line">  <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</span><br><span class="line">    handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">performBatchComplete</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;BitmapHunter&gt; copy = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(batch);</span><br><span class="line">  batch.clear();</span><br><span class="line">  mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法会依次被调用，首先将 bitmap 写入缓存，然后将 bitmapHunter 保存到 batch 这个容器里面，然后进行 <strong>批量处理</strong> ，批量处理可以减少消息数量，提高效率。</p><h3 id="主线程处理"><a href="#主线程处理" class="headerlink" title="主线程处理"></a>主线程处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(BitmapHunter hunter)</span> &#123;</span><br><span class="line">    <span class="type">Action</span> <span class="variable">single</span> <span class="operator">=</span> hunter.getAction();</span><br><span class="line">    List&lt;Action&gt; joined = hunter.getActions();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasMultiple</span> <span class="operator">=</span> joined != <span class="literal">null</span> &amp;&amp; !joined.isEmpty();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">shouldDeliver</span> <span class="operator">=</span> single != <span class="literal">null</span> || hasMultiple;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shouldDeliver) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> hunter.getData().uri;</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> hunter.getException();</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> hunter.getResult();</span><br><span class="line">    <span class="type">LoadedFrom</span> <span class="variable">from</span> <span class="operator">=</span> hunter.getLoadedFrom();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (single != <span class="literal">null</span>) &#123;</span><br><span class="line">        deliverAction(result, from, single, exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasMultiple) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = joined.size(); i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Action</span> <span class="variable">join</span> <span class="operator">=</span> joined.get(i);</span><br><span class="line">            deliverAction(result, from, join, exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deliverAction</span><span class="params">(Bitmap result, LoadedFrom from, Action action, Exception e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!action.willReplay()) &#123;</span><br><span class="line">        targetToAction.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        action.complete(result, from);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码没有什么好讲，就是一些 action 后续处理，是否该取消操作、是否移出列表啥的。最重要的就是 <code>action.complete()</code> 这句。</p><h3 id="最后的工作"><a href="#最后的工作" class="headerlink" title="最后的工作"></a>最后的工作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Bitmap result, Picasso.LoadedFrom from)</span> &#123;</span><br><span class="line">    <span class="type">ImageView</span> <span class="variable">target</span> <span class="operator">=</span> <span class="built_in">this</span>.target.get();</span><br><span class="line"></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> picasso.context;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">indicatorsEnabled</span> <span class="operator">=</span> picasso.indicatorsEnabled;</span><br><span class="line">    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        callback.onSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 bitmap ，回调。整个流程到这里算是完成了。</p><blockquote><p>大概的流程很简单，看完这再看 Glide 应该会顺利很多</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Picasso </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterknife 剖析</title>
      <link href="/2017/12/30/d430da0f206c.html"/>
      <url>/2017/12/30/d430da0f206c.html</url>
      
        <content type="html"><![CDATA[<p>在初学 Android 的时候，写一个 Activity，就要写好几句 <code>findViewById</code> （现在 support 包使用泛型避免强转），慢地就变得厌倦这些模板代码，但是又不能不写。ButterKnife 使用注解的方式来避免这一类模板代码，比如事件监听器等。代码变得好看了，也就开始思考它内部的工作原理。</p><span id="more"></span><blockquote><p>学习源码最重要的是学习它的设计思想，然后帮助我们在以后学习中打开思路，多一种解决问题的可能。我觉得 ButterKnife 告诉我们要学会偷懒，能少写的代码绝不多写一句。</p><p>另外，Kotlin 可以直接使用 xml 里面的 id 来操作控件。</p></blockquote><h2 id="平台和工具"><a href="#平台和工具" class="headerlink" title="平台和工具"></a>平台和工具</h2><blockquote><p>OS：Ubuntu 17.04<br>Android Studio：<a target="_blank" rel="noopener" href="https://developer.android.com/studio/archive.html">Android Studio 2.4 Preview7</a><br>ButterKnife：8.5.1</p></blockquote><h2 id="ButterKnife-做了啥"><a href="#ButterKnife-做了啥" class="headerlink" title="ButterKnife 做了啥"></a>ButterKnife 做了啥</h2><p>这里我们创建一个简单的工程，布局文件里面就放一个 id 为 button 的按钮。MainActivity 里面的代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"><span class="comment">//    @BindView(R.id.button)</span></span><br><span class="line">    <span class="keyword">protected</span> Button mButton;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"><span class="comment">//        ButterKnife.bind(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们 <code>Ctrl + F9</code> 对项目进行编译，然后我们进入 &#x2F;app&#x2F;build&#x2F;intermediates&#x2F;classes&#x2F;debug&#x2F;com&#x2F;xiansenliu&#x2F;test 目录，会有下面这些文件(去掉了一些):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── BuildConfig.class</span><br><span class="line">├── MainActivity.class</span><br><span class="line">└── R.class</span><br></pre></td></tr></table></figure><p>然后去掉 <code>@BindView(R.id.button)</code> 的注释，再次编译，这次我们发现这个目录有了变化:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── BuildConfig.class</span><br><span class="line">├── MainActivity.class</span><br><span class="line">├── MainActivity_ViewBinding.class    //多的文件</span><br><span class="line">└── R.class</span><br></pre></td></tr></table></figure><p>明眼人都知道多了一个 <code>MainActivity_ViewBinding.class</code> 文件，我们接着看这里面又做了哪些小动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    这里删减了一点点代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity_ViewBinding</span> <span class="keyword">implements</span> <span class="title class_">Unbinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MainActivity target;</span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainActivity_ViewBinding</span><span class="params">(MainActivity target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(target, target.getWindow().getDecorView());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainActivity_ViewBinding</span><span class="params">(MainActivity target, View source)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        target.mButton = (Button)Utils.findRequiredViewAsType(source, <span class="number">2131427414</span>, <span class="string">&quot;field &#x27;mButton&#x27;&quot;</span>, Button.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@CallSuper</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unbind</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MainActivity</span> <span class="variable">target</span> <span class="operator">=</span> <span class="built_in">this</span>.target;</span><br><span class="line">        <span class="built_in">this</span>.target = <span class="literal">null</span>;</span><br><span class="line">        target.mButton = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到这一句：<code>target.mButton = ...</code>，这里就完成了 View 的绑定工作。<br>我们接着看 <code>Utils.findRequiredViewAsType()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    去掉了一些检查代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">findRequiredViewAsType</span><span class="params">(View source, <span class="meta">@IdRes</span> <span class="type">int</span> id, String who,</span></span><br><span class="line"><span class="params">      Class&lt;T&gt; cls)</span> &#123;</span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> findRequiredView(source, id, who);</span><br><span class="line">    <span class="keyword">return</span> castView(view, id, who, cls);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> View <span class="title function_">findRequiredView</span><span class="params">(View source, <span class="meta">@IdRes</span> <span class="type">int</span> id, String who)</span> &#123;</span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> source.findViewById(id);    <span class="comment">//发现了</span></span><br><span class="line">      <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">castView</span><span class="params">(View view, <span class="meta">@IdRes</span> <span class="type">int</span> id, String who, Class&lt;T&gt; cls)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cls.cast(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个函数的作用就是 <code>(Button)findViewById(...)</code> , 还是蛮简单的。</p><h2 id="ButterKnife-绑定触发"><a href="#ButterKnife-绑定触发" class="headerlink" title="ButterKnife 绑定触发"></a>ButterKnife 绑定触发</h2><p>辅助类生成了，绑定逻辑也清楚了，那么这些逻辑是怎么调用的呢？用过的朋友可能知道 <code>ButterKnife.bind(this);</code> 这句就是整个绑定逻辑起点，我们再看看触发过程的内部逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    已省略健壮性代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title function_">bind</span><span class="params">(<span class="meta">@NonNull</span> Activity target)</span> &#123;</span><br><span class="line">    <span class="type">View</span> <span class="variable">sourceView</span> <span class="operator">=</span> target.getWindow().getDecorView();</span><br><span class="line">    <span class="keyword">return</span> createBinding(target, sourceView);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unbinder <span class="title function_">createBinding</span><span class="params">(<span class="meta">@NonNull</span> Object target, <span class="meta">@NonNull</span> View source)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Unbinder</span>&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line">    <span class="keyword">return</span> constructor.newInstance(target, source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Unbinder</span>&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Unbinder</span>&gt; bindingCtor = BINDINGS.get(cls)；</span><br><span class="line">    <span class="keyword">if</span> (bindingCtor != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> bindingCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">clsName</span> <span class="operator">=</span> cls.getName();</span><br><span class="line">    Class&lt;?&gt; bindingClass = Class.forName(clsName + <span class="string">&quot;_ViewBinding&quot;</span>);    <span class="comment">//敲黑板</span></span><br><span class="line">    bindingCtor = (Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Unbinder</span>&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">    BINDINGS.put(cls, bindingCtor);</span><br><span class="line">    <span class="keyword">return</span> bindingCtor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码就是 <code>Class&lt;?&gt; bindingClass = Class.forName(clsName + &quot;_ViewBinding&quot;)</code> ，<strong>通过类名</strong> 找到对应的辅助类，然后通过 <strong>反射</strong> 得到构造器，并 <strong>缓存</strong> 到 BINDINGS 这个 Map 中去，最后通过这个构造器完成辅助类的实例化，同时完成View的注入工作。</p><blockquote><p>至于其它的绑定，如监听器绑定等，</p></blockquote><h2 id="辅助类的生成"><a href="#辅助类的生成" class="headerlink" title="辅助类的生成"></a>辅助类的生成</h2><p>最后一个可能的疑问就是：辅助类是哪里来的？<br>我们知道要引入 ButterKnife 的依赖，我们除了需要像一般依赖添加之外，还要添加 <code>annotationProcessor &#39;com.jakewharton:butterknife-compiler:8.5.1&#39;</code> ，谜底就在这一行脚本里面。这一行脚本告知 Gradle：我要使用 ButterKnife 的注解处理器，然后当我们按下 <code>Ctrl + F9</code> 的时候，这个注解器就会提取那些 BindView 之类的注解，然后解析并生成辅助类。<br>如果想具体了解辅助类的生成过程，请移步</p><p>看到这里，不知道你有没有豁然开朗的感觉，其实 ButterKnife 是一个非常轻量的注解库，因为核心代码就这么多，真正高大上的代码都在注解处理器里面，不需要编译进最终的 Android 工程。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ButterKnife </tag>
            
            <tag> Annotation Processor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 学习 curl</title>
      <link href="/2017/12/28/790985cb4957.html"/>
      <url>/2017/12/28/790985cb4957.html</url>
      
        <content type="html"><![CDATA[<p>最近有个作业需要自己写个服务器，接口写完了还得测试，虽然使用 postman 等工具很便捷，但是感觉不够装逼（嗯，就是不够装逼），所以 curl 成了不二之选。</p><span id="more"></span><p>当信用一个命令行工具的时候，习惯性动作都是在 Terminal 里面键入 ‘<tool> –help’ 来看看都有哪些功能和参数，基本上能大概知道学习成本了。不过本人比较怂，如果一下子输出了好几页的帮助文档，基本上就转投 Google ，毕竟可能就用这么一次（以后得改改）。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options...] &lt;url&gt;</span><br></pre></td></tr></table></figure><p>它的学问全部在 [options…] 里，鉴于帮助文档实在太多了，这里就只挑选进行 Http 请求时用的比较多的参数项。</p><h3 id="保存输出到文件"><a href="#保存输出到文件" class="headerlink" title="保存输出到文件"></a>保存输出到文件</h3><p>直接执行 <code>curl http://www.baidu.com</code> 会默认输出到标准输出，如果要保存至本地文件，有三种方式：</p><ul><li>重定向<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://www.baidu.com &gt; ./index.html</span><br></pre></td></tr></table></figure>这样就能够输出到 index.html 了</li><li>使用 -o<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o ./index.html https://www.baidu.com</span><br></pre></td></tr></table></figure>index.html 可以是任意有写权限的文件</li><li>使用 -O<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://www.baidu.com/index.html</span><br></pre></td></tr></table></figure>这里和 -O 有两点不同，首先 url 精确到了具体的资源， -O 后面没有参数。输出文件名称和远程资源名称一样，局限性比较大</li></ul><h3 id="获取响应头信息"><a href="#获取响应头信息" class="headerlink" title="获取响应头信息"></a>获取响应头信息</h3><p>有时候可能需要根据响应头信息做一些判断，那么可以执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://www.baidu.com</span><br></pre></td></tr></table></figure><p>控制台会输出完整的响应（response header + response body）<br>如果不需要响应体，可以使用 <code>-I</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://www.baidu.com</span><br></pre></td></tr></table></figure><blockquote><p>如果这些信息还不够，还可以使用 -v、-V 选项</p></blockquote><h3 id="设置头信息"><a href="#设置头信息" class="headerlink" title="设置头信息"></a>设置头信息</h3><p>有些接口可能需要定制头信息，这时候就可以使用 <code>-H</code> 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;User-Agent: custom UA&quot; -H &quot;Referer: https://xinsbackyard.tech&quot; https://www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="设置-UA"><a href="#设置-UA" class="headerlink" title="设置 UA"></a>设置 UA</h3><p>设置 User-Agent 可以使用 -H，也可以使用 <code>-A</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -A &quot;custom UA&quot; https://www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="设置-Referer"><a href="#设置-Referer" class="headerlink" title="设置 Referer"></a>设置 Referer</h3><p>同理 UA，可以使用 <code>-e</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -e “http://xinsbackyard.tech” https://baidu.com</span><br></pre></td></tr></table></figure><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>在进行模拟登录的时候，需要保存 cookie 来保持登录状态。使用 <code>-c</code> 保存返回的 cookie，下次请求的时候就可以使用 <code>-b</code> 来读取 cookie ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -c ./cookie-jar https://www.baidu.com</span><br><span class="line">curl -b ./cookir-jar https://www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>模拟登录成功后一般会进行一次重定向，如果想要获得重定向之后的输出，那么就使用 <code>-L</code> 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L http://www.xxxxx.com</span><br></pre></td></tr></table></figure><h3 id="指定请求方法"><a href="#指定请求方法" class="headerlink" title="指定请求方法"></a>指定请求方法</h3><p>curl 默认请求方法是 GET，要更改默认行为可以使用 <code>-X</code> 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://www.xxx.com</span><br></pre></td></tr></table></figure><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>POST 请求需要发送数据时，使用 <code>-d</code> 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;username=hahaha&amp;password=23333&quot; https://www.xxx.com/login</span><br></pre></td></tr></table></figure><p>这样就可以发送一个表单。</p><p>如果要发送文件，使用 <code>@</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d @filename.zip https://www.xxx.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Curl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 磁盘目录</title>
      <link href="/2017/12/26/2a00e14d34f5.html"/>
      <url>/2017/12/26/2a00e14d34f5.html</url>
      
        <content type="html"><![CDATA[<p>每次遇到存储这一块的时候，都要去看 <a target="_blank" rel="noopener" href="https://developer.android.com/training/basics/data-storage/files.html">官方文档</a> ；但是这里有一个蛋疼的问题就是，官方文档中没有对特定方法返回的路径进行说明。所以每次都会在这个问题上耗费十多分钟来 <strong>看文档</strong> 和 <strong>写 Demo</strong> 来找到符合要求的方法，这次就做个笔记，以防不时之需。</p><span id="more"></span><h2 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h2><p>官方术语：<strong>Internal Storage</strong><br>我的理解就是 <strong>系统存储空间</strong> ，也就是一般情况下，用户无法通过文件管理器查看。应用安装的时候会分配这样的一个空间，当用户卸载的时候系统会清理掉这部分存储空间。<br>获取方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /data/user/0/your.package.name/cache</span></span><br><span class="line">Context.getCacheDir().absolutePath()</span><br><span class="line"></span><br><span class="line"><span class="comment">// /data/user/0/your.package.name/files</span></span><br><span class="line">Context.getFilesDir().absolutePath()</span><br></pre></td></tr></table></figure><p>这两种也能够满足大部分的需求了。</p><h2 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h2><p>官方术语： <strong>External Storage</strong><br>理解成 <strong>用户存储空间</strong> 可能比较恰当，因为用户通过一个文件管理器就可以把这部分存储空间看个遍（除非有这么闲）。<br>这部分空间又要分成两部分：<strong>private</strong> + <strong>public</strong></p><h3 id="private-外部存储"><a href="#private-外部存储" class="headerlink" title="private 外部存储"></a>private 外部存储</h3><p>这部分空间通常用来进行缓存或一些私有的文件。虽然系统没有提供 API 来读取其他应用的这部分空间，但是可以简单通过 <strong>字符串拼接</strong> 的方式来直接操作其他应用的这部分空间，所以这部分空间的 <strong>安全性不是很高</strong> ，所以一些关乎应用正常运行的文件还是会被丢到 <strong>internal Storage</strong> 。<br>当应用被用户卸载的时候，这部分空间也会像内部存储一样被清理。<br>获取方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /storage/emulated/0/Android/data/your.package.name/cache</span></span><br><span class="line">Context.getExternalCacheDir()</span><br><span class="line"></span><br><span class="line"><span class="comment">// /storage/emulated/0/Android/data/your.package.name/files</span></span><br><span class="line">Context.getExternalFilesDir(<span class="literal">null</span>)</span><br><span class="line">Context.getExternalFilesDir(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// /storage/emulated/0/Android/data/your.package.name/files/dirName</span></span><br><span class="line">Context.getExternalFilesDir(<span class="string">&quot;dirName&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="public-外部存储"><a href="#public-外部存储" class="headerlink" title="public 外部存储"></a>public 外部存储</h3><p>这部分空间所有应用都能共享，会有一些诸如：Alarms、Music、Pictures 等为命名的文件夹，这也是用户最容易接触到的存储空间。如果应用在这里放了啥东西，就算应用被卸载这些文件还是会继续留着，所以很多 app 就在这里放一些缓存或者配置文件啥的，如果用户重新安装应用，能够继续使用一些配置或者缓存。<br>获取方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Environment.getExternalStorageDirectory();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_ALARMS);</span><br></pre></td></tr></table></figure><h3 id="外部存储的状态"><a href="#外部存储的状态" class="headerlink" title="外部存储的状态"></a>外部存储的状态</h3><p>在对外部存储进行操作之前还需要检测下它的状态，比如 SD 卡被移除（现在手机都没SD 卡槽了）、PC 通过 USB 读取这部分空间的时候。<br>检测方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> Environment.getExternalStorageState();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当外部存储 可读可写 时语句返回值为 true</span></span><br><span class="line">state.equals(Environment.MEDIA_MOUNTED)；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当外部存储 至少可读 时语句返回值为 true</span></span><br><span class="line">state.equals(Environment.MEDIA_MOUNTED)||state.equals(Environment.MEDIA_MOUNTED_READ_ONLY);</span><br></pre></td></tr></table></figure><hr><p>这些 api 应该能够满足大部分需求，然对应的路径不同的系统可能会有不同，所以通过字符串硬编码读取这些路径是绝对不可取的。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存之 MemoryLruCache</title>
      <link href="/2017/12/26/f29039e0c557.html"/>
      <url>/2017/12/26/f29039e0c557.html</url>
      
        <content type="html"><![CDATA[<p>在开发图片加载功能时，既要保证加载速度，又要避免 OOM，特别是在类似于图库这样的场景中，如何处理好这两者关系显得尤为重要。所以最简单的想法就是一共缓存，将那些暂时 “食之无味，弃之可惜”  的对象暂时缓存起来，以备不适之需。</p><span id="more"></span><h2 id="LruCache-简单使用"><a href="#LruCache-简单使用" class="headerlink" title="LruCache 简单使用"></a>LruCache 简单使用</h2><p>这里我们以缓存 <code>Bitmap</code> 为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cacheSize = (Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">8</span>).toInt()</span><br><span class="line"><span class="keyword">val</span> cache = <span class="keyword">object</span> : LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sizeOf</span><span class="params">(key: <span class="type">String</span>?, value: <span class="type">Bitmap</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value?.byteCount ?: <span class="number">0</span> / <span class="number">1024</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(key: <span class="type">String</span>?)</span></span>: Bitmap &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">entryRemoved</span><span class="params">(evicted: <span class="type">Boolean</span>, key: <span class="type">String</span>?, oldValue: <span class="type">Bitmap</span>?, newValue: <span class="type">Bitmap</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.entryRemoved(evicted, key, oldValue, newValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用该进程最大可用内存的 <strong>八分之一</strong> 来缓存 bitmap，单位为 KB 。<br>然后重写用于 <strong>计算 value 大小</strong> 的 <code>sizeOf()</code>，如果不重写，每个 value 的大小会被记为 1。<br>至于 <code>entryRemoved()</code>，当有相应的 value 被移除的时候会调用，默认是个空方法。<br><code>create()</code> 函数在缓存没有命中的时候会调用，可以重写该函数来返回一个缺省值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> previous = cache.put(<span class="string">&quot;bitmap&quot;</span>,bitmap)</span><br><span class="line"><span class="keyword">val</span> removed = cache.remove(<span class="string">&quot;bitmap&quot;</span>)</span><br></pre></td></tr></table></figure><p>调用 <code>put()</code> 函数，传入键值就完成了缓存的写入，如果这个 key 之前有对应的 value ，则会返回旧值，否则返回 null；移除&#x2F;更新缓存就调用 <code>remove()</code> 并传入 key 就行了，如果有与 key 对应的 value，则返回 value，否则返回 null。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>看完了简单使用，我们接着看看它的内部是怎么实现的。</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>首先看看它的成员变量和构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LruCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> putCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> createCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> evictionCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hitCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> missCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LruCache</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>size：表示已缓存的大小</li><li>maxSize：表示最大缓存大小，这个值由构造器的参数决定，也可以通过函数更改</li><li>putCount：放入缓存的次数</li><li>createCount：创建缺省值的次数</li><li>evictionCount：缓存剔除次数</li><li>hitCount：缓存命中次数</li><li>missCount：缓存未命中次数</li></ul><p>这些值都可以通过函数获取，可以通过这些值的分析来确定最适合的缓存的大小。</p><p>然后我们看到构造函数里初始化了一个大小为零，负载因子为 0.75 并且按 <strong>访问顺序</strong> 排序的 LinkedHashMap，最后一个 true 就是实现 LruCache 的关键所在，它表示 LinkedHashMap 里面的值是以 <strong>最后一次</strong> 被访问&#x2F;缓存的时间来排序。</p><br/><h3 id="LruCache-put"><a href="#LruCache-put" class="headerlink" title="LruCache#put()"></a>LruCache#put()</h3><p>再来看 <code>LruCache#put()</code> 函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    V previous;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="literal">false</span>, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的工作非常简单，将键值放入 map ，调整相应的成员变量，如果有被替换出来的值，调用 <code>entryRemoved()</code>，最后看看是不是要移除一些“很久“没访问过的缓存。</p><br/><h3 id="LruCache-get"><a href="#LruCache-get" class="headerlink" title="LruCache#get()"></a>LruCache#get()</h3><p>接着看 <code>LruCache#get()</code> 函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    V mapValue;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        mapValue = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            <span class="keyword">return</span> mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">V</span> <span class="variable">createdValue</span> <span class="operator">=</span> create(key);</span><br><span class="line">    <span class="keyword">if</span> (createdValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size += safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mapValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="literal">false</span>, key, createdValue, mapValue);</span><br><span class="line">        <span class="keyword">return</span> mapValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        <span class="keyword">return</span> createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查找 map，如果找到缓存就立马返回；如果没有相应的缓存，则尝试调用 <code>create(key)</code> 来创建一个缺省值，这里要注意的是，并发情况下， map 有可能在 <code>create()</code> 还没有返回时被其他的线程更新了，也即有可能这个 key 对应的缓存被添加到了 map。如果没有缺省值，立即返回 null，如果有，放入 map 进行缓存，然后根据返回值是否为 null 来判断 map 在此前有没有被放入 key 的缓存，如果有的话，取消缺省值的放入。最后就是返回缺省值或者缓存。</p><br/><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>最后，我们再来看看 <code>trimToSize()</code> 函数是怎么保证缓存大小不超过最大大小的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(getClass().getName()</span><br><span class="line">                        + <span class="string">&quot;.sizeOf() is reporting inconsistent results!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (size &lt;= maxSize) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class="line">            <span class="keyword">if</span> (toEvict == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entryRemoved(<span class="literal">true</span>, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二话不说，先来个死循环，循环里面首先判断当前大小有没有超出最大大小，如果超出则从 map 里面移除最老的缓存，调用 <code>entryRemoved()</code> 函数，进入下一轮。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体上讲，并没有什么太难的地方，整体的逻辑弄清楚就差不多知道内部是怎么工作的了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LruCache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存之 DiskLruCache</title>
      <link href="/2017/12/26/d03b71bc367c.html"/>
      <url>/2017/12/26/d03b71bc367c.html</url>
      
        <content type="html"><![CDATA[<p><code>DiskLruCache</code> 在 Glide 、 OkHttp 中都有使用，不过这些第三方库有可能根据自己的需求进行了一定的修改，不过总体上的还是一样的。<a target="_blank" rel="noopener" href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html">下载地址</a></p><span id="more"></span><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>当缓存损坏的时候，它能够高效地进行处理。最明显的方法就是删除缓存，其他大多数缓存是没有这种机制的。不过一般来说，缓存损坏的情况还是比较少见的。</li><li>维护了一个缓存条目的内存LRU缓存，避免在每次访问缓存条目都需要查询数据库和磁盘，提高数据加载效率。</li><li>能够自己判断缓存是不是最新的，也就是说，每次使用 Editor 进行操作的时候都会做一个版本控制。</li><li>写入缓存发生错误时，可以调用 <code>Editor#abort()</code> 来放弃本次操作，并且产生的临时文件也将被删除。即使 app 在操作的时候意外停止运行，我们可以通过调用 <code>DiskLruCache#close()</code> 来删除所有的临时文件来保证缓存的状态连续性。</li><li>对同一份缓存的读写是线程安全的。</li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化并获取实例</span></span><br><span class="line"><span class="type">DiskLruCache</span> <span class="variable">cache</span> <span class="operator">=</span> DiskLruCache.open(directory, appVersion, valueCount, maxSize)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 key 拿到 Editor 对象</span></span><br><span class="line">DiskLruCache.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> cache.edit(key);</span><br><span class="line"><span class="comment">// 拿到一个没有缓冲的输出流，通过它向磁盘写入需要缓存的数据</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 完成数据写入之后调用 commit() 提交</span></span><br><span class="line">editor.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 key 拿到 Snapshot 对象</span></span><br><span class="line">DiskLruCache.<span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"><span class="comment">// 拿到一个没有缓冲的 输入流，通过它读取磁盘缓存</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> snapshot.getInputStream(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要使用缓存的时候可以选择关闭，关闭后再不能执行读写操作</span></span><br><span class="line">cache.close();</span><br></pre></td></tr></table></figure><p>上面代码就是 DiskLruCache 提供的一些基本操作，还有另外一些 API，如：remove(key)、getDirectory() 等。至于调用这些方法所需要提供的参数的原因，再分析了其他部分之后就清楚了。</p><br/>## journal 文件`DiskLruCache` 基于 journa 文件来进行缓存，在操作缓存的时候这个文件会有大量的读写操作。先瞄一眼这些缓存在磁盘上的组织形式(这里以简书的缓存为例)：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ef41763bb5d73d8c0ed56342d192c470.1</span><br><span class="line">f004340685af913064825e5e67dbbda9.0</span><br><span class="line">f004340685af913064825e5e67dbbda9.1</span><br><span class="line">f1e314bfd0834ddcc5decfa52d81f9f7.0</span><br><span class="line">f1e314bfd0834ddcc5decfa52d81f9f7.1</span><br><span class="line">fbaee0fc0b5d9aca24ab3937d55fbb28.0</span><br><span class="line">fbaee0fc0b5d9aca24ab3937d55fbb28.1</span><br><span class="line">journal</span><br></pre></td></tr></table></figure>我们看到这里有很多有着 **不明觉厉的命名** 的文件和一个 **journal** 文件，再仔细看看发现有些文件只是后缀不一样，前面都一长串字符。其实这些命名很屌的文件就是缓存，可能是一张图片或者一篇文章，而 **journal** 就是一个文本文件，里面记录的就是这些缓存的信息：**状态** 、**key** 、**大小** ，打开后是这样的：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">libcore.io.DiskLruCache        // 表示这是一个 DiskLruCache 的日志文件</span><br><span class="line">1                              // 当前 DiskLruCache 的版本</span><br><span class="line">201105                         // 应用的版本号</span><br><span class="line">2                              // 一个 key 对应缓存的数量，即 valueCount</span><br><span class="line">                               // 空行</span><br><span class="line">CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054</span><br><span class="line">DIRTY 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line">CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342</span><br><span class="line">REMOVE 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line">DIRTY 1ab96a171faeeee38496d8b330771a7a</span><br><span class="line">CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</span><br><span class="line">READ 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line">READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</span><br><span class="line">...</span><br></pre></td></tr></table></figure>前面的五行组成了日志文件的头信息（Headers），格式是固定的。头下面就是缓存操作记录了，我们的每一次存取都会在里面形成一条记录。当然，内部肯定会定期的做一个日志的清理以保证这个日志文件大小在可接受的范围之内。每一行代表一个操作记录，一条记录由 state 空格 key [sizes] 组成。下面是四种操作状态的含义：> - **DIRTY**：一条缓存条目正在创建或者更新。每一个 DIRTY 动作后面都跟着一个 CLEAN/REMOVE ，如果不是则表示需要删除临时文件。我们还能知道，每一个 key 在 journal 文件里面的 **第一条** 记录就是 DIRTY **打头** 的。- **CLEAN**：表示一个缓存是可以读取的，这种类型的记录还会有 **缓存大小** 跟在尾部。- **READ**：每一次对缓存的访问都会产生一条 READ 记录。- **REMOVE**：表示 key 所对应的缓存已经被删除了。<p>这里可能有同学会感到疑惑：为什么不直接在每次写入缓存成功后写入 CLEAN 到 journal 文件，省去中间的步骤？<br>这里我们设想这样的场景：我们缓存图片缓存到一半，然后 app 突然崩溃，然后除了临时文件我们什么都没留下。如果我们使用 DIRTY ，至少能保证下次打开 app 的时候通过 DIRTY 来删除这个临时文件。</p><h2 id="重要内部类"><a href="#重要内部类" class="headerlink" title="重要内部类"></a>重要内部类</h2><p><code>DiskLruCache</code> 内部有三个重要的类，它们提供缓存的抽象、读和写。</p><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>每一个 Entry 实例都是一条缓存记录的抽象，它包含了缓存的key、长度、状态等。下面是这个类的关键声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] lengths;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> readable;</span><br><span class="line">    <span class="keyword">private</span> Editor currentEditor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> File <span class="title function_">getCleanFile</span><span class="params">(<span class="type">int</span> i)</span>；</span><br><span class="line">    <span class="keyword">public</span> File <span class="title function_">getDirtyFile</span><span class="params">(<span class="type">int</span> i)</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>key</strong>：这个缓存的唯一身份标示</li><li><strong>lengths</strong>：初始化 DiskLruCache 时我们传入了一个 valueCount，这表示一个 key 可以又多个缓存，所以大小也用一个长整型数组表示。</li><li><strong>readable</strong>：表示改缓存可以读取。</li><li><strong>currentEditor</strong>：<strong>NON-NULL</strong> 表示该缓存目前正在进行一个写操作。</li><li><strong>sequenceNumber</strong>：这个和 <code>Snapshot</code> 里面的 sequenceNumber 进行配合，以此分辨 <code>Snapshot</code> 的数据是否过期。</li><li><strong>getDirtyFile(index)<strong>：获取该缓存与 index 对应的写入</strong>成功之前</strong>的临时文件。</li><li><strong>getCleanFile(index)<strong>：获取该缓存与 index 对应的写入</strong>成功之后</strong>的缓存文件。</li></ul><h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p><code>Snapshot</code> 是 <code>DiskLruCache</code> 另一个非常重要的内部类，通过它可以读取缓存，下面是它的重要声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Snapshot</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> sequenceNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream[] ins;</span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">(<span class="type">int</span> index)</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>key</strong>：对应缓存的唯一身份标示</li><li><strong>sequenceNumber</strong>：正如在 <code>Entry</code> 中所说，这里也包含了一个 sequenceNumber。在 <code>Snapshot</code> 被实例化的时候，sequenceNumber 是直接从 <code>Entry</code> 里复制过来的。如果在此之后有人对缓存进行的了编辑或者更新操作，<code>Entry</code> 里面的 sequenceNumber 就会自增，这时两边的值就不相等了，也就意味着 <code>Snapshot</code> 里的数据过期了。</li><li>**getInputStream(index)**：获取缓存与 index 对应的没有缓冲的输入流。</li></ul><h3 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h3><p><code>Editor</code> 是对缓存写入的一个封装，下面是它的一些重要声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Entry entry;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> hasErrors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">newInputStream</span><span class="params">(<span class="type">int</span> index)</span>；</span><br><span class="line">    <span class="keyword">public</span> OutputStream <span class="title function_">newOutputStream</span><span class="params">(<span class="type">int</span> index)</span>；</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>；</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Entry</strong>：editor 操作的对象。</li><li><strong>hasError</strong>：标示缓存写入是否发生异常。</li><li>**newInputStream(index)**：获取与 index 对应的最近的缓存输入流。</li><li>**newOutputStream(index)**：获取与 index 对应的缓存输出流，如果写入期间发生异常，写入将会被撤销。</li><li>**commit()**：写入完成后进行提交。</li><li>**abort()**：撤销本次对 Entry 的操作。</li></ul><h2 id="journal-文件的管理"><a href="#journal-文件的管理" class="headerlink" title="journal 文件的管理"></a>journal 文件的管理</h2><p>上面的三个内部类对 缓存条目、读、写进行了抽象，那么留给 <code>DiskLruCache</code> 的工作显然就是对日志的管理了。这里我们通过分析缓存的初始化、读写来分析日志的管理机制。</p><h3 id="DiskLruCache-open"><a href="#DiskLruCache-open" class="headerlink" title="DiskLruCache#open()"></a>DiskLruCache#open()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title function_">open</span><span class="params">(File directory, <span class="type">int</span> appVersion,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> valueCount, <span class="type">long</span> maxSize)</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DiskLruCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskLruCache</span>(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.readJournal();</span><br><span class="line">            cache.processJournal();</span><br><span class="line">            cache.journalWriter = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(cache.journalFile, <span class="literal">true</span>),</span><br><span class="line">                    IO_BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">return</span> cache;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">            cache.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new empty cache</span></span><br><span class="line">    directory.mkdirs();</span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">DiskLruCache</span>(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    cache.rebuildJournal();</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果之前有使用过缓存，则尝试去读取。读取过程就是验证 journal 文件头信息的合法性并且逐行读取缓存条目。然后对缓存条目进行一些类似筛选的操作，这里会删除一些临时文件。这些操作过程中都有可能发生异常，异常发生就会删除所有缓存。</p><p>如果之前没有使用过缓存，就会尝试去重新建立一个缓存，这里没有对异常进行捕获，而是交给使用者处理，这表明如果重新建立缓存也失败，那么 <code>DiskLruCache</code> 将不可用。</p><h3 id="DiskLruCache-readJournalLine"><a href="#DiskLruCache-readJournalLine" class="headerlink" title="DiskLruCache#readJournalLine()"></a>DiskLruCache#readJournalLine()</h3><p>当 journal 文件的头信息合法之后，就是逐行读取缓存条目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    String[] parts = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (parts.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;unexpected journal line: &quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> parts[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(REMOVE) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</span><br><span class="line">        lruEntries.remove(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        entry = <span class="keyword">new</span> <span class="title class_">Entry</span>(key);</span><br><span class="line">        lruEntries.put(key, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(CLEAN) &amp;&amp; parts.length == <span class="number">2</span> + valueCount) &#123;</span><br><span class="line">        entry.readable = <span class="literal">true</span>;</span><br><span class="line">        entry.currentEditor = <span class="literal">null</span>;</span><br><span class="line">        entry.setLengths(copyOfRange(parts, <span class="number">2</span>, parts.length));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(DIRTY) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</span><br><span class="line">        entry.currentEditor = <span class="keyword">new</span> <span class="title class_">Editor</span>(entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(READ) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// this work was already done by calling lruEntries.get()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;unexpected journal line: &quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易看到，这里主要对四种不同状态进行具体情况具体分析：</p><ul><li>REMOVE：表示这个 key 对应的缓存已经删除，相应的缓存条目也需要删除。</li><li>CLEAN：表示 key 对应的缓存存在，并且可读。然后继续解析尾部的大小信息。</li><li>DIRTY：表示 key 对应的缓存最近执行过一次写入操作，但是最后写入失败。</li><li>READ：表示最近读取过该条缓存。</li></ul><p>这里需要知道的是，每条缓存可能不止一条记录，所以一条缓存最终状态的是它所有操作记录的总和，不过最后一次记录会起到很关键的作用。<br>到这里我们就完成缓存记录的读取，不过读取出来的数据还没有经过筛选，其中还有一些坏缓存的记录，下一步操作需要剔除它们并删除与之对应的缓存文件。</p><h3 id="DiskLruCache-processJournal"><a href="#DiskLruCache-processJournal" class="headerlink" title="DiskLruCache#processJournal()"></a>DiskLruCache#processJournal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    deleteIfExists(journalFileTmp);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> i.next();</span><br><span class="line">        <span class="keyword">if</span> (entry.currentEditor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">                size += entry.lengths[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry.currentEditor = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">                deleteIfExists(entry.getCleanFile(t));</span><br><span class="line">                deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">            &#125;</span><br><span class="line">            i.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上一步的筛选，这里处理的数据都是以 <strong>DIRTY</strong> 、 <strong>CLEAN</strong> 、 <strong>READ</strong> 开头的记录。<br>这里的筛选操作主要依据 <code>Entry.currentEditor</code> 是不是 <strong>null</strong> ，上一步中知道只有 <strong>DIRTY</strong> 打头的记录才满足这个条件。如果不为 null ，表明最近有失败的写入操作，需要删除临时文件和过期的缓存文件。如果不死的话，表明这是一条合法可用的缓存，读取缓存占用磁盘的空间大小。</p><h3 id="DiskLruCache-rebuildJournal"><a href="#DiskLruCache-rebuildJournal" class="headerlink" title="DiskLruCache#rebuildJournal()"></a>DiskLruCache#rebuildJournal()</h3><p>如果是第一次使用的缓存，那么就会调用 <code>DiskLruCache#rebuildJournal</code> 来新建缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">rebuildJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (journalWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">        journalWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(journalFileTmp), IO_BUFFER_SIZE);</span><br><span class="line">    writer.write(MAGIC);</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    writer.write(VERSION_1);</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    writer.write(Integer.toString(appVersion));</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    writer.write(Integer.toString(valueCount));</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">            writer.write(DIRTY + <span class="string">&#x27; &#x27;</span> + entry.key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writer.write(CLEAN + <span class="string">&#x27; &#x27;</span> + entry.key + entry.getLengths() + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writer.close();</span><br><span class="line">    journalFileTmp.renameTo(journalFile);</span><br><span class="line">    journalWriter = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(journalFile, <span class="literal">true</span>), IO_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法还是很好懂，先创建一临时的 journal 文件，然后向里面写入头信息，写入成功之后就重命名为 journal 文件。因为这个方法不止在新建journal 文件的时候调用，所以还需要将已有所有的 Entry 写入到 journal 里面，这里新建的情况下 lruEntries 是空的。</p><h3 id="DiskLruCache-edit"><a href="#DiskLruCache-edit" class="headerlink" title="DiskLruCache#edit()"></a>DiskLruCache#edit()</h3><p>调用 <code>DiskLruCache#edit(key)</code> 最终会调用 <code>DiskLruCache#edit(key,expectedSequenceNumber)</code> ，这里第二个参数可能会给大家另一个惊喜：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Editor <span class="title function_">edit</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> edit(key, ANY_SEQUENCE_NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Editor <span class="title function_">edit</span><span class="params">(String key,</span></span><br><span class="line"><span class="params">                                <span class="type">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER</span><br><span class="line">            &amp;&amp; (entry == <span class="literal">null</span> || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// snapshot is stale</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        entry = <span class="keyword">new</span> <span class="title class_">Entry</span>(key);</span><br><span class="line">        lruEntries.put(key, entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// another edit is in progress</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Editor</span>(entry);</span><br><span class="line">    entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flush the journal before creating files to prevent file leaks</span></span><br><span class="line">    journalWriter.write(DIRTY + <span class="string">&#x27; &#x27;</span> + key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    journalWriter.flush();</span><br><span class="line">    <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>DiskLruCache#edit(key)</code> ，那么 <code>expectedSequenceNumber</code> &#x3D;&#x3D; ANY_SEQUENCE_NUMBER 是恒成立的，所以第一个条件语句我们直接跳过。接下来的操作就是，如果不存在与 key 多对应的缓存，则新建一个 Entry；如果存在就判断 Entry 的 Editor 是不是为空，不为空表示有另一个线程正在进行写操作。判断操作合法性之后就给这个 Entry 分配一个 Editor，同时向 journal 文件里面写入一条 <strong>DIRTY</strong> 记录。</p><h3 id="DiskLruCache-completeEdit"><a href="#DiskLruCache-completeEdit" class="headerlink" title="DiskLruCache#completeEdit()"></a>DiskLruCache#completeEdit()</h3><p>在使用 Editor 完成操作后，需要调用 <code>Editor#abort()</code> 或 <code>Editor#commit()</code> 最终向 <code>DiskLruCache</code> 提交，这两个方法最终都会调用 <code>DiskLruCache#completeEdit()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">completeEdit</span><span class="params">(Editor editor, <span class="type">boolean</span> success)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> editor.entry;</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor != editor) &#123;<span class="comment">// 安全性检查</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if this edit is creating the entry for the first time, every index must have a value</span></span><br><span class="line">    <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">                editor.abort();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;edit didn&#x27;t create file &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valueCount; i++) &#123;<span class="comment">// 将写入成功的临时文件重命名为正式的缓存文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dirty</span> <span class="operator">=</span> entry.getDirtyFile(i);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dirty.exists()) &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">clean</span> <span class="operator">=</span> entry.getCleanFile(i);</span><br><span class="line">                dirty.renameTo(clean);</span><br><span class="line">                <span class="type">long</span> <span class="variable">oldLength</span> <span class="operator">=</span> entry.lengths[i];</span><br><span class="line">                <span class="type">long</span> <span class="variable">newLength</span> <span class="operator">=</span> clean.length();</span><br><span class="line">                entry.lengths[i] = newLength;</span><br><span class="line">                size = size - oldLength + newLength;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deleteIfExists(dirty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;    <span class="comment">// 多余的操作数量+1，用来判断是否需要重建 journal 文件用的</span></span><br><span class="line">    entry.currentEditor = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry.readable | success) &#123;</span><br><span class="line">        entry.readable = <span class="literal">true</span>;</span><br><span class="line">        journalWriter.write(CLEAN + <span class="string">&#x27; &#x27;</span> + entry.key + entry.getLengths() + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            entry.sequenceNumber = nextSequenceNumber++;    <span class="comment">// 如果在此之前有获取过该 Entry 的 Snapshot ，这一步操作将使 Snapshot 过期</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 写入 REMOVE 记录，便于下次移除临时文件</span></span><br><span class="line">        lruEntries.remove(entry.key);</span><br><span class="line">        journalWriter.write(REMOVE + <span class="string">&#x27; &#x27;</span> + entry.key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;    <span class="comment">// journal 文件清理</span></span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个方法比较长，自己看代码的效果应该会好一点，里面的注释基本上也讲清楚了大概的操作。唯一要注意的就是，<code>Entry.readable</code> 这个成员变量，初始值为 <code>false</code> ，只有当完成一次读取或者成功的写入操作的时候才会被置为 <code>true</code> 。</p><h3 id="DiskLruCache-get"><a href="#DiskLruCache-get" class="headerlink" title="DiskLruCache#get()"></a>DiskLruCache#get()</h3><p>写入缓存就是为了读取，下面看看 <code>DiskLruCache</code> 是怎么构建一个缓存快照 <code>Snapshot</code> 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title function_">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!entry.readable) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Open all streams eagerly to guarantee that we see a single published</span></span><br><span class="line"><span class="comment">     * snapshot. If we opened streams lazily then the streams could come</span></span><br><span class="line"><span class="comment">     * from different edits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InputStream[] ins = <span class="keyword">new</span> <span class="title class_">InputStream</span>[valueCount];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">            ins[i] = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(entry.getCleanFile(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// a file must have been deleted manually!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(READ + <span class="string">&#x27; &#x27;</span> + key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(key, entry.sequenceNumber, ins);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也很简单，大概情况就是，拿到 key 所对应的缓存，然后打开所有的文件输入流，将操作记录写入 journal 文件，最后再判断是否需要重建 journal 文件。至于那个一大段文本注释中的解释，我也不是很清楚，大概就是说如果不马上打开的话，之后打开获取的缓存可能是被更新过的。然后我们又看到了 sequenceNumber ，就是直接从 Entry 里面复制过来的，所以可以根据两边的值来判断 Snapshot 过期与否。</p><h3 id="DIskLruCache-remove"><a href="#DIskLruCache-remove" class="headerlink" title="DIskLruCache#remove()"></a>DIskLruCache#remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span> || entry.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> entry.getCleanFile(i);</span><br><span class="line">        <span class="keyword">if</span> (!file.delete()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;failed to delete &quot;</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">        size -= entry.lengths[i];</span><br><span class="line">        entry.lengths[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(REMOVE + <span class="string">&#x27; &#x27;</span> + key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保存在对应的缓存之后，判断是否有另一个操作正在进行，没有就会继续执行。然后就是删除缓存文件，写入操作记录，将 <code>Entry</code> 从 <code>lruEntries</code> 中移除，最后再判断是否需要对 journal 文件进行重建。</p><h3 id="LRU-算法的实现"><a href="#LRU-算法的实现" class="headerlink" title="LRU 算法的实现"></a>LRU 算法的实现</h3><p>最重要的 <strong>LRU</strong> 算法肯定要放在最后，看过 <code>DiskLruCache</code> 源码的同学可能会发现并没有找到有关 LRU 实现的一点蛛丝马迹。所见即所得，<code>DiskLruCache</code> 并没有自己去实现 LRU 算法，因为 LinkedHashMap 自带 LRU 属性。因为所有的 Entry 都存放在一个 LinkedHashMap 里，并且初始化的时候调用了 LinkedHashMap 三个参数的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>第三个参数的官方解释是：accessOrder - the ordering mode - true for access-order, false for insertion-order。这里是设为的 true ，所以表示是按照访问的时间来进行排序的，即 LRU 。如果还想知道 LRU 的具体实现，可以参考 LinkedHashMap 源码。</p><hr><p>到这里，关键的源码基本就全部分析了一遍，一些细枝末节的东西一眼就能看懂。刚开始看的时候没有注意 <strong>理清结构</strong> 和 <strong>类间关系</strong> ，阅读进度很慢，后来从别人博客学到的方法才能顺利的阅读。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.mindorks.com/this-post-is-about-the-implementation-details-of-jake-whartons-famous-disklrucache-9a87d90206fe">A deep dive into Jake Wharton’s DiskLruCache</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DiskLruCache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 之环境搭建</title>
      <link href="/2017/12/26/669e7b46d405.html"/>
      <url>/2017/12/26/669e7b46d405.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>来自 GitBook，完成第一篇迁移</p></blockquote><p>最近 React Native、weex 等跨平台框架都好火的样子，要是再不看看，可能就要听不懂他们前端的话了。万事开头难，搭环境、跑 Demo 啥的基本上没有不遇坑，当然解决之后也是蛮开心的。</p><span id="more"></span><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>OS：Ubuntu 17.04<br>IDE：Android Studio</p><blockquote><p>本来呢，不想在主力机上装各种环境，便想在只有 Windows 小破旧电脑上装，结果还是受不了 Windows ，于是也给 旧电脑装了 Ubuntu。</p></blockquote><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>我是按照ReactNative中文社区的 <a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.47/getting-started.html#content">教程</a> 来配置的，一套流程走下来基本上也没什么问题。</p><h3 id="node-安装"><a href="#node-安装" class="headerlink" title="node 安装"></a>node 安装</h3><p>打开 Terminal 执行下面几条命令就完成了 node 的安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y build-essential    <span class="comment"># -y 表示不留缓存</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -sL https://deb.nodesource.com/setup_5.x | sudo -E bash -</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y nodejs</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">ln</span> -s /usr/bin/nodejs /usr/bin/node    <span class="comment">#进行软链接</span></span></span><br></pre></td></tr></table></figure><p>这里遇到了一个问题，在执行完第二条命令的时候，最后输出了一段提示：</p><blockquote><p>## Confirming “zesty” is supported…</p><p>+ curl -sLf -o &#x2F;dev&#x2F;null ‘<a target="_blank" rel="noopener" href="https://deb.nodesource.com/node_5.x/dists/zesty/Release&#39;">https://deb.nodesource.com/node_5.x/dists/zesty/Release&#39;</a></p></blockquote><blockquote><p>## Your distribution, identified as “zesty”, is not currently supported, please contact NodeSource at <a target="_blank" rel="noopener" href="https://github.com/nodesource/distributions/issues">https://github.com/nodesource/distributions/issues</a> if you think this is incorrect or would like your distribution to be considered for support</p></blockquote><p>大概意思就是说当前的运行的 Ubuntu 发行版还没有得到正式的支持，不过也没有感觉到不兼容的问题，忽略就好了。如果是其他版本的操作系统，可能就没有这个问题了。</p><h3 id="npm-、yarn-、react-native-cli-安装"><a href="#npm-、yarn-、react-native-cli-安装" class="headerlink" title="npm 、yarn 、react-native-cli 安装"></a>npm 、yarn 、react-native-cli 安装</h3><p>上一步安装完 node 似乎并没有帮我们一并安装 npm ，所以还得多一条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install -y npm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo npm install -g yarn react-native-cli</span></span><br></pre></td></tr></table></figure><p><strong>yarn</strong> 是 FB 提供的 npm 替代品，能够加速 node 模块的下载（照抄的）。<br><strong>react-native-cli</strong> 是 ReactNative 命令行工具，有他之后我们就可以在 Terminal 里面完成 创建、初始化、更新、运行打包服务（packager）等任务了。</p><p>虽然说 yarn 加速node 模块下载，如果源在高墙之外，估计想快也快不起来。这里我们还要给 yarn 设置一下镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org --global</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn config <span class="built_in">set</span> disturl https://npm.taobao.org/dist --global</span></span><br></pre></td></tr></table></figure><blockquote><p>其实我个人不是很喜欢这种更改镜像的办法，看自己梯子的速度吧</p></blockquote><h3 id="Android-Dev-环境"><a href="#Android-Dev-环境" class="headerlink" title="Android Dev 环境"></a>Android Dev 环境</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>安装之前先下载可能存在的 OpenJDK，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo apt purge openjdk-\*</span></span><br></pre></td></tr></table></figure><p>首先前往 <a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK 站点</a> 下载一个合适的 JDK tar.gz 压缩包。下载完之后我们执行命令来进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 解压到指定目录</span><br><span class="line">$ sudo mkdir -p /usr/local/java            #创建 JDK 安装目录</span><br><span class="line">$ tar -zxvf jdk-8u144-linux-x64.tar.gz -C /usr/local/java    #这里文件名可能不一样</span><br><span class="line"></span><br><span class="line"># 配置ubuntu的JDK和JRE的位置， jdk1.8.0_144 替换成你的目录名</span><br><span class="line">$ sudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/local/java/jdk1.8.0_144/bin/java&quot; 1</span><br><span class="line">$ sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/local/java/jdk1.8.0_144/bin/javac&quot; 1</span><br><span class="line">$ sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/local/java/jdk1.8.0_144/bin/javaws&quot; 1</span><br><span class="line"></span><br><span class="line"># 配置Oracle为系统默认JDK/JRE</span><br><span class="line">$ sudo update-alternatives --set java /usr/local/java/jdk1.8.0_144/bin/java</span><br><span class="line">$ sudo update-alternatives --set javac /usr/local/java/jdk1.8.0_144/bin/javac</span><br><span class="line">$ sudo update-alternatives --set javaws /usr/local/java/jdk1.8.0_144/bin/javaws</span><br></pre></td></tr></table></figure><p>完成这些步骤后 JDK 环境就配好了，有些文章可能说还要配置环境变量，不过不配置也能够正常使用。</p><h4 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h4><p>Linux 版本的 SDK 和 Studio 都只提供zip，非常友好（之前用 Windows 也一直用的这种）。<br>先去 <a target="_blank" rel="noopener" href="https://developer.android.com/studio/index.html">Android 官方文档网站</a> 下载好压缩包。下载好之后还是使用命令行进行解压(安装)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.google.com/dl/android/studio/ide-zips/3.0.0.10/android-studio-ide-171.4263559-linux.zip -P ~/Downloads</span><br><span class="line">$ mkdir ~/Android</span><br><span class="line">$ unzip ~/Downloads/android-studio-ide-171.4263559-linux.zip -d ~/Android</span><br></pre></td></tr></table></figure><p>解压完成也就安转好了，我之前安装一直都是下载 Studio 和 SDK 两个压缩包，刚刚看文旦才知道只下载 Studio 就可以了，反正到时候还是会下载 SDK 的。<br>我们接着运行 Studio 来完成 SDK 的安装，也可以顺便进行一些个性化设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/Android/android-studio/bin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./studio.sh &amp;</span></span><br></pre></td></tr></table></figure><p>在下载 SDK 的界面，我们把 SDK 路径设为 <code>~/Android/android-sdk</code> ，这里只是为了后面的讲述方便，也可以自行更改。<br>Linux 也无法避免需要配置 SDK 环境变量的问题，打开 <code>~/.bashrc</code> ，在你喜欢的位置（推荐最后面）加入下面两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ANDROID_HOME=~/Android/android-sdk</span><br><span class="line">export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure><p>Android 开发环境也配置好了。至于 ReactNative 中文社区教程中说的要下载对应版本的 build-tools 啥的，我们先忽略，后面会提到。</p><blockquote><p>至于其他的工具或配置选项，有兴趣就看 中文社区 的教程。</p></blockquote><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>随便找个没有超级用户权限的目录，执行下面的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p ~/Documents/AnroidProjects</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/Documents/AndroidProjects</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">react-native init AwesomeRN</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> AwesomeProject</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">react-native run-android</span></span><br></pre></td></tr></table></figure><p>我可能比较倒霉，第三条第五条命令报错，GitHub、SO 上逛了 n 圈，遇到类似或相同错误的人还不少，下面讲讲我遇到的错误表现和解决办法。</p><h3 id="第三条：初始化项目"><a href="#第三条：初始化项目" class="headerlink" title="第三条：初始化项目"></a>第三条：初始化项目</h3><p>执行完第三条命令，最后 Terminal 输出了如下错误：</p><blockquote><p>this._nextStatusStr &#x3D; util.format(format, …args)</p><p>​                                     ^^^</p><p>SyntaxError: Unexpected token …<br>   at exports.runInThisContext (vm.js:53:16)</p></blockquote><p>最终在 <a target="_blank" rel="noopener" href="http://blog.csdn.net/xocom/article/details/76933996">这里</a> 找到了解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo npm install -g npm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo npm cache clean -f</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo npm install -g n</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo n stable</span></span><br></pre></td></tr></table></figure><p>具体干了什么我也不清楚，大概是升了个级，反正问题解决了。所以在安装完 npm 之后执行上面的操作就可以避免这个错误了。<br>再次执行第三条命令，成功后会得到下面的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">To run your app on iOS:</span><br><span class="line">   cd /media/xinliu/Files/Projects/Android/AwesomeRN</span><br><span class="line">   react-native run-ios</span><br><span class="line">   - or -</span><br><span class="line">   Open ios/AwesomeRN.xcodeproj in Xcode</span><br><span class="line">   Hit the Run button</span><br><span class="line">To run your app on Android:</span><br><span class="line">   cd /media/xinliu/Files/Projects/Android/AwesomeRN</span><br><span class="line">   Have an Android emulator running (quickest way to get started), or a device connected</span><br><span class="line">   react-native run-android</span><br></pre></td></tr></table></figure><h3 id="第五条：运行"><a href="#第五条：运行" class="headerlink" title="第五条：运行"></a>第五条：运行</h3><p>真没想到在这里还会遇到坑，敲入命令， Enter 一扣，立马见到输出中有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting JS server...</span><br><span class="line">Building and installing the app on the device (cd android &amp;&amp; ./gradlew installDebug)...</span><br></pre></td></tr></table></figure><p>紧接着输出的就是执行 <code>./gradlew installDebug</code> 的输出（中间会下载gradle 和一些其他的模块），眼看进度在增长，最后跑出个异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &#x27;:app:mergeDebugResources&#x27;.</span><br><span class="line">&gt; Error: java.util.concurrent.ExecutionException: java.lang.RuntimeException: AAPT process not ready to receive commands</span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</span><br><span class="line"></span><br><span class="line">BUILD FAILED</span><br><span class="line"></span><br><span class="line">Total time: 7.096 secs</span><br><span class="line">Could not install the app on the device, read the error above for details.</span><br><span class="line">Make sure you have an Android emulator running or a device connected and have</span><br><span class="line">set up your Android development environment:</span><br><span class="line">https://facebook.github.io/react-native/docs/android-setup.html</span><br></pre></td></tr></table></figure><p>然后各种搜索，见得最多的是执行 <code>cd android &amp;&amp; ./gradlew clean</code> ，这不就是 “clean project” 么，本以为有效，然并卵。<br>后来还是在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40284811/run-react-native-app-in-device">SO</a> 上找到了答案，修改 “android&#x2F;app&#x2F;build.gradle”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compileSdkVersion 26</span><br><span class="line">buildToolsVersion &quot;26.0.1&quot;</span><br><span class="line"></span><br><span class="line">minSdkVersion 21</span><br><span class="line">targetSdkVersion 26</span><br></pre></td></tr></table></figure><p>我都给换成最新的，然后居然成功了。中文社区教程中还强调了只能 <strong>buildToolsVersion “23.0.1”</strong> ，特别是看到有些文章给出的答案是按照中文社区的教程重新来一遍，真的是坑。所以之前并按照教程中说的安装特定版本 build-tools 啥的。<br>如果此时有模拟器正在运行，执行完第五条命令后就应该能够跑起来了。用真机测试的话，看 <a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.47/running-on-device-android.html#content">这里</a>。</p><blockquote><p>其实也可以不修改 gradle 脚本，因为第五条命令的作用就是打包一个 js bundle ，然后在 8081 端口启动 nodejs 服务器，再使用 gradle 进行 apk 打包安装。所以我们可以使用 Android Studio 来打包安装，然后在 <code>AwesomeRN</code> 目录执行 <code>react-native start</code> 启动服务器，最终效果是“一样”的。</p></blockquote><h2 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h2><p>安装好应用之后，第一次打开应用会跳转到授权界面，然后再回到 app，这时可能会看见 app 顶部闪过的绿色提示：“loading from localhost：8081”，似乎有点动态从服务拉取界面的意思。我们进入 app 在系统内部位置：<code>/data/data/com.awesomern</code>，然后里面会有一个 <strong>files</strong> 文件夹，里面有个 <strong>ReactNativeDevBundle.js</strong> 文件，刚才加载的就是这个文件。干点坏事，把它删了，关闭应用之后重新进入，又有可能看见闪过的绿色提示，回到刚才的 “files” 目录，会发下刚删掉的文件又出现，仔细看还会发现时间戳也变了。</p><p>还有一个问题就是这个 bundle 有点大，弱网环境的加载速度的肯定不能忍，配合上 <strong>rsync</strong> 或 <strong>bsdiff</strong> 等差量算法来拉去差量包会是一个比较好的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>成功跑起来很开心，ReactNative 的实时更新界面确实很棒，虽然一个空壳 App 打出来就 TM 10多M。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> React Native </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AndroidArchitectureComponent 之 ViewModel</title>
      <link href="/2017/12/25/3a5b44d671b6.html"/>
      <url>/2017/12/25/3a5b44d671b6.html</url>
      
        <content type="html"><![CDATA[<p>在学习 Android 稍微深入一点，就知道 <code>Activity/Fragment</code> 是受 Android 框架层控制的，具体表现在生命周期上面。系统会根据用户的操作或者设备状态来创建或销毁 <code>Activity/Fragment</code>，这个时候会带来数据的 <strong>保存和恢复(包括视图状态)</strong>  问题。一个典型场景就是表单页面，当用户旋转屏幕之后，系统会重建Activity&#x2F;Fragment，如果什么数据的保存恢复工作都没有做，那么系统重建的 <code>Activity/Fragment</code> 将失去用户已经输入的数据，丢失数据越多，用户体验越差。</p><span id="more"></span><p>上面的还只是最简单的场景，当存在异步操作，<code>Activity/Fragment</code> 有可能恰好在请求返回时恰好被系统回收了，如果重建的 <code>Activity/Fagment</code> 又重新请求一次，就会造成资源浪费，最理想的情况就是能够直接利用之前请求到的数据同时又不会有内存泄露的隐患。</p><p>虽然系统提供了 <code> onSaveInstanceState()</code> 来保存数据，但是这只适用于 <strong>少量的</strong> 、支持 <strong>序列化</strong> 和 <strong>反序列化</strong> 的数据，局限性很明显。</p><p>所以我们需要自行提供一套数据保存与恢复的机制。</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>Android Architecture Component 提供 ViewModel 来帮助我们为视图提供数据,同时，它还能在视图重建的过程中生存下来，也就保证了数据保存恢复的可行性。</p><p>要使用 ViewModel 也很简单，只需要继承 ViewModel 并通过规定的方式获取它的实例就可以了。下面是一个简单的例子：</p><p>首先继承 ViewModel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;initial content&quot;</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在我们的视图层请求一个 <code>MyViewModel</code> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VMActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;VMActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> MyViewModel mvm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(...)</span>&#123;</span><br><span class="line">        mvm = ViewModelProviders.of(<span class="built_in">this</span>).get(MyViewModel.class);</span><br><span class="line">        Log.d(TAG,mvm.toString());</span><br><span class="line">        Log.d(TAG,mvm.content);</span><br><span class="line">        mvm.content = <span class="string">&quot;modified content&quot;</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能使 <code>MyViewModel.content</code> 在 Activity 的重建中生存下来了。</p><h2 id="ViewModel-的生命周期"><a href="#ViewModel-的生命周期" class="headerlink" title="ViewModel 的生命周期"></a>ViewModel 的生命周期</h2><p>我们先看官方文档提供的一张示意图：<br><img src="https://developer.android.com/images/topic/libraries/architecture/viewmodel-lifecycle.png"></p><p>这里 ViewModel 的生存期会和 Activity 的生命周期关联，ViewModel 只有在确定 Activity 不会再重建后才会销毁（<code>this.finish()</code> 调用），这里需要的表述可能有问题，需要结合 Activity 的启动模式来理解。</p><blockquote><p>Fragment 情况差不多，ViewModel 在被 <strong>detached</strong> 之后销毁。</p></blockquote><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>刚刚知道了 ViewModel 的生存期与创建它时传递进去的参数有关（Activity&#x2F;Fragment），那么当我们传递进去的是 Activity 时，就能获取和 Activity 的生命周期对应的 ViewModel，大概的情况就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AFrag <span class="keyword">extends</span> <span class="title class_">Fragment</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyViewModel vma;</span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(...)</span>&#123;</span><br><span class="line">        vma  = ViewModelProviders.of(getActivity()).get(MyViewModel.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BFrag <span class="keyword">extends</span> <span class="title class_">Fragment</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyViewModel vmb;</span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(...)</span>&#123;</span><br><span class="line">        vmb  = ViewModelProviders.of(getActivity()).get(MyViewModel.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这两个 Fragment 被添加到了同一个宿主 Activity 中，那么 <code>vma</code> 和 <code>vmb</code> 就是同一个实例。</p><blockquote><p>添加到 Fragment 中同理。</p></blockquote><h2 id="ViewModel-带参构造器"><a href="#ViewModel-带参构造器" class="headerlink" title="ViewModel 带参构造器"></a>ViewModel 带参构造器</h2><p>到现在还有一个问题，那就是 ViewModel 的创建。通过传递 ViewModel  的字节码信息就可以获取一个实例，第一反应应该是 <strong>反射</strong> ，内部通过反射调用 ViewModel 的 <strong>无参构造器</strong> 来创建实例。如果需要使用带参构造器，需要借助于另一个接口—— <code>ViewModelProvider.Factory </code> ，ViewModelProvider 有一个它的默认实现实例，我们要做的就是替换这个默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewModelFactory</span> <span class="keyword">implements</span> <span class="title class_">ViewModeProvider</span>.Factory&#123;</span><br><span class="line">  <span class="keyword">private</span> Params params;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyViewModelFactory</span><span class="params">(Params params)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.params = params;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; modelClass)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> modelClass.getConstructor(Params.class).newInstance(params);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在获取的时候，传递它的实例进去就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyViewModelFactry</span> <span class="variable">f</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">MyViewModelFactory</span>(params);</span><br><span class="line">mvm = ViewModelProviders.of(<span class="built_in">this</span>,f).get(MyViewModel.class);</span><br></pre></td></tr></table></figure><p>这样就能够通过构造器向 VIewModel 传递参数了。</p><blockquote><p>  注意：不建以让 ViewModel 持有Android 框架层的实例，如果需要 Context 的话，可以通过继承 <code>AndroidViewModel</code> 来实现</p></blockquote><h2 id="改造MVP"><a href="#改造MVP" class="headerlink" title="改造MVP"></a>改造MVP</h2><p>刚刚通过 <code>ViewModelProvider.Factory</code> 向 ViewModel 的构造器传递参数，结合 MVP ，可以让 ViewModel 承担 P 层的职责，而不仅仅是做一个数据的容器。我们接着<a href="/posts/61434b2a.html">上一篇文章</a> 中的 MVP 继续改造：</p><p>我们让 <code>AbsPresenter</code> 继承 <code>ViewModel</code> 并实现它的 <code>onClear()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsPresenter</span>&lt;V <span class="keyword">extends</span> <span class="title class_">AbsView</span>&gt; <span class="keyword">extends</span> <span class="title class_">ViewModel</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;AbsPresenter&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">CompositeDisposable</span> <span class="variable">compositeDisposable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositeDisposable</span>();</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;V&gt; view = <span class="keyword">new</span> <span class="title class_">WeakReference</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(V v)</span> &#123;</span><br><span class="line">        view = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(v);</span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            ((LifecycleOwner) v).getLifecycle().addObserver(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> view.get();</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Fragment &amp;&amp; ((Fragment) v).isDetached() ||</span><br><span class="line">                    v <span class="keyword">instanceof</span> android.app.Fragment &amp;&amp; ((android.app.Fragment) v).isDetached()) &#123;</span><br><span class="line">              view.clear();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addDisposable</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">        compositeDisposable.add(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy called&quot;</span>);</span><br><span class="line">        view.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCleared</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onClear called&quot;</span>);</span><br><span class="line">        compositeDisposable.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据 ViewModel 的生命周期，我们将 <code>compositeDisposable.clear()</code> 移动到了 <code>onClear()</code> 方法中，同时提供了一个 <code>getView()</code> 方法提供 V 层实例。</p><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>定义一个 Contract 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VMContract</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">VMView</span> <span class="keyword">extends</span> <span class="title class_">BaseView</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onLoadMsg</span><span class="params">(String msg)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseVMPresenter</span> <span class="keyword">extends</span> <span class="title class_">BasePresenter</span>&lt;VMView&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">loadMsg</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承 <code>BaseVMPresenter</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> VMPresenter <span class="keyword">extends</span> <span class="title class_">BaseVMPresenter</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Repo local;</span><br><span class="line">    <span class="keyword">private</span> Repo remote;</span><br><span class="line">    String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VMPresenter</span><span class="params">(Repo local, Repo remote)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.local = local;</span><br><span class="line">        <span class="built_in">this</span>.remote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">            getView().onLoadMsg(<span class="string">&quot;restored msg&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Disposable</span> <span class="variable">disposable</span> <span class="operator">=</span> Observable</span><br><span class="line">                .fromCallable(() -&gt; &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    <span class="keyword">return</span> remote.loadMsg();</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(</span><br><span class="line">                        msg -&gt; &#123;</span><br><span class="line">                            <span class="built_in">this</span>.msg = msg;</span><br><span class="line">                            VMContract.<span class="type">VMView</span> <span class="variable">view</span> <span class="operator">=</span> getView();</span><br><span class="line">                            <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">                                view.onLoadMsg(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        Throwable::printStackTrace,</span><br><span class="line">                        () -&gt; Log.i(TAG, <span class="string">&quot;onComplete&quot;</span>)</span><br><span class="line">                );</span><br><span class="line">        addDisposable(disposable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Factory</span> <span class="keyword">extends</span> <span class="title class_">ViewModelProvider</span>.NewInstanceFactory &#123;</span><br><span class="line">        <span class="keyword">private</span> Repo local;</span><br><span class="line">        <span class="keyword">private</span> Repo remote;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Factory</span><span class="params">(Repo local, Repo remote)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.local = local;</span><br><span class="line">            <span class="built_in">this</span>.remote = remote;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modelClass.isAssignableFrom(VMPresenter.class)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> modelClass.getConstructor(Repo.class, Repo.class)</span><br><span class="line">                            .newInstance(local, remote);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.create(modelClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>VMPresenter</code> 有两个 Repo 依赖，所以还需要创建一个 <code>Factory</code>。</p><p>最后就是让 Activity 实现接口并使用 VMPresenter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> VMActivity <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">VMView</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> BaseVMPresenter p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(...)</span>&#123;</span><br><span class="line">        VMPresenter.<span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VMPresenter</span>.Factory(<span class="keyword">new</span> <span class="title class_">LocalRepo</span>(), <span class="keyword">new</span> <span class="title class_">RemoteRepo</span>());</span><br><span class="line">        <span class="type">VMPresenter</span> <span class="variable">presenter</span> <span class="operator">=</span> ViewModelProviders.of(<span class="built_in">this</span>, factory).get(VMPresenter.class);</span><br><span class="line">        presenter.setView(<span class="built_in">this</span>);</span><br><span class="line">        presenter.loadMsg();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMsg</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    Toast.makeText(<span class="built_in">this</span>, msg, Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后我们先等第一次弹出 Toast ，然后再旋转屏幕，看看是不是会有另一个 toast 弹出。可以看出，这里没有对 <code>savedInstanceState</code> 进行判断，直接获取 presenter 实例，逻辑也很清晰，如果你对屏幕旋转前后的 presenter 是不是同一个实例持怀疑态度的话，可以打印 log 来进行验证。</p><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p>虽然 Presenter 结合 ViewModel 的特性能够使它在屏幕旋转中生存下来，但是我们发现，一旦 Presenter 需要依赖其他模块来完成功能（这非常常见），为了兼顾单元测试和代码优雅性，就要给它添加有参构造器，继而需要为它创建 <code>Factory</code> 。我们都知道，MVP 为人所诟病的一点就是要定义接口，现在又要多定义一个 <code>Factory</code> 。再一个，我们可以发现这个 Factory 啊，它是有套路的，进一步可以得到这样的公式 ： <code>Factory  = f( params of presetner&#39;constructor )</code> 。每次都写这样的类并不会提高我们的技术，只能凑凑代码量，所以我们需要把这个锅丢给编译器，让这个 Factory 能够自动生成。<br>这里安利一下我自己造的轮子—— <a target="_blank" rel="noopener" href="https://github.com/dashMrl/AutoVM">AutoVM</a> ，只需要在构造器上添加一个注解，就可以生成 Factory 了。<br>欢迎 star hhh！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刚接触这一套框架的时候，觉得应该围绕这一套框架为核心来构思架构，但是后来发现，相对于 MVP ，并没有太多优势。现在换个角度，将它们作为 MVP 的辅助，为现有 MVP 提供更加有趣的特性，所以，官方文档上的演示可能只是为了展示这一套框架能够发挥出什么样的威力。</p><p>完整代码在 <a target="_blank" rel="noopener" href="https://github.com/dashMrl/Android_Demos/tree/8f9e0472f97ad669945d84b4bc7c8723759045c6">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AAC </tag>
            
            <tag> ViewModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Architecture Components 之 Lifecycle</title>
      <link href="/2017/12/21/83842e2f251f.html"/>
      <url>/2017/12/21/83842e2f251f.html</url>
      
        <content type="html"><![CDATA[<p>现在都流行 MVP + RxJava2 开发，然后 RxJava 带来的一个问题就是需要在适当的时候取消订阅关系以避免 <strong>内存泄露</strong> ，最常见的做法就是在 <code>Activity/Fragment#onDestroy()</code> 方法中调用 <code>disposable.dispose()</code> 来解决。然后，官方文档中是用 <code>LocationManager</code> 来举例，这种情况就比较典型，需要重写 Activity&#x2F;Fragment 的每个生命周期方法来处理它的状态。官方文档中又单独封装了一个类来处理，保持生命周期方法中的代码不会太臃肿。但是这还是没有彻底解决问题，毕竟还是要重写方法，难免不会有一次忘记重写某个生命周期函数。最理想的情况就是，我们封装的类能够 <strong>自动察觉</strong> 到生命周期的变化。</p><span id="more"></span><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>正式开始前，先了解几个概念。<br>Lifecycle 这个类封装了组件的生命周期信息，并且使得这些信息可以被其他人监视。</p><p>Lifecycle 使用两个 枚举类 来追踪和它关联的组件生命周期：</p><ul><li>Event：这个枚举类代表了生命周期 <strong>变化</strong>，并且与 Activity&#x2F;Fragment 中的生命周期回调方法一一对应</li><li>State：生命周期组件当前的状态</li></ul><p>下面是官方文档上的一张示意图，它展示了 Event、State 之间的关系：<br><img src="https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.svg" alt="States and events that comprise the Android activity lifecycle"></p><p>一般情况下，我们更关心的可能是生命周期状态的变化，通过监听这些变化来作出相应的处理，这里我们通过实现 <code>LifecycleObserver</code> 来完成监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObserver</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，通过 <strong>注解</strong> 的方式就能指定某个方法在哪个生命周期事件发生时被调用，至于如何注册这个 Observer ，等另一个类讲解之后再说。</p><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><p>刚刚介绍了 Lifecycle 这类，以及如何监听它的各种事件，但是我们还需要一个能偶提供的 Lifecycle 的宿主，这里就需要使用到 <code>LifecycleOwner</code> 。</p><p>LifecycleOwner 是一个 <strong>只有一个方法</strong> 的接口，它表示这个类能够提供 <code>Lifecycle</code> 。最新 support 包里的 <code>AppCompatActivity/Fragment</code> 已经实现了这个接口，所以我们可以直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifecycActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(...)</span> &#123;</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">MyLifecycleObserver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样简单的一行代码，就可以完成生命周期事件的监听了。</p><blockquote><p>注意：在 <code>MyObserver</code> 中，在执行生命周期相关的操做前最好判断一下当前生命周期。这时官方原话，我暂时还不知道是什么原因，先留个坑，等看了源码再过来补充。</p></blockquote><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>了解完这个生命周期感知的类，还需要思考怎么利用这个特性来改进我们现有的代码。这里我们通过改造一个 MVP 来练习：</p><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>按照 MVP 的套路，我们需要先定义 V 和 P 的基类&#x2F;接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsView</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 AbsView 什么接口方法都没有定义，飘过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsPresenter</span>&lt;V <span class="keyword">extends</span> <span class="title class_">AbsView</span>&gt; <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;AbsPresenter&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">CompositeDisposable</span> <span class="variable">compositeDisposable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositeDisposable</span>();</span><br><span class="line">    <span class="keyword">protected</span> WeakReference&lt;V&gt; view = <span class="keyword">new</span> <span class="title class_">WeakReference</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">setView</span><span class="params">(V v)</span> &#123;</span><br><span class="line">        view = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(v);</span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            ((LifecycleOwner) v).getLifecycle().addObserver(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addDisposable</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">        compositeDisposable.add(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;lifecycle component state onDestroy&quot;</span>);</span><br><span class="line">        compositeDisposable.clear();</span><br><span class="line">        view.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点看看这个 AbsPresenter ，它实现了 LifecycleObserver，同时定义一系列被 <code>Lifecycle.Event</code> 标注的方法，这些方法在 Activity&#x2F;Fragment 的生命周期变化的时候被调用，所以我们就可以把 RxJava2 的 <strong>解订阅操作</strong> 放在 <code>onDestroy</code> 这个方法里面。<br>需要注意的是，这些生命周期感知的方法不能使用 private 修饰，否则编译不过。</p><p>完成了这些基础工作，我们就可以专注于业务逻辑，而避免自己重写 onDestroy 方法解除订阅，也避免的因为疏忽忘记重写而造成内存泄漏的问题。</p><h3 id="定义协议"><a href="#定义协议" class="headerlink" title="定义协议"></a>定义协议</h3><p>按照 Google Samples 中的套路，我们再定义一个协议接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LOContract</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseLifecyclePresenter</span> <span class="keyword">extends</span> <span class="title class_">AbsPresenter</span>&lt;LifecycleView&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BaseLifecyclePresenter</span><span class="params">(LifecycleView lifecycleView)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(lifecycleView);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">getMsg</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">LifecycleView</span> <span class="keyword">extends</span> <span class="title class_">AbsView</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">showMsg</span><span class="params">(String msg)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现VP"><a href="#实现VP" class="headerlink" title="实现VP"></a>实现VP</h3><p>最后就是实现了</p><p>LOActivity 实现 LifecycleView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LOActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserverContract</span>.LifecycleView &#123;</span><br><span class="line">    <span class="keyword">private</span> BaseLifecyclePresenter p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">LOPresenter</span>();</span><br><span class="line">        p.setView(<span class="built_in">this</span>);</span><br><span class="line">        findViewById(R.id.load_btn).setOnClickListener(</span><br><span class="line">            view -&gt; p.getMsg()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, msg, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LOPresenter 实现 BaseLifecyclePresenter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LOPresenter</span> <span class="keyword">extends</span> <span class="title class_">LifecycleObserverContract</span>.BaseLifecyclePresenter &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;LOPresenter&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Disposable</span> <span class="variable">d</span> <span class="operator">=</span> Observable</span><br><span class="line">                .fromCallable(() -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 模拟一个耗时操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;message&quot;</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(</span><br><span class="line">                        msg -&gt; view.get().showMsg(msg),</span><br><span class="line">                        Throwable::printStackTrace,</span><br><span class="line">                        () -&gt; Log.i(TAG, <span class="string">&quot;onComplete&quot;</span>)</span><br><span class="line">                );</span><br><span class="line">        addDisposable(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，点击按钮，五秒钟后就能看到一条 toast 弹出，点击返回退出当前界面，在 logcat 里面能看到 <code>AbsPresenter#onDestroy()</code> 方法被调用：</p><p><img src="https://i.loli.net/2017/12/22/5a3d0d11994c7.png"></p><p><img src="https://i.loli.net/2017/12/22/5a3d0d686977f.png"></p><p>这里看到 <code>AbsPresenter#onDestroy()</code> 被自动调用了，完全不需要我们处理。</p><p>完整代码在 <a target="_blank" rel="noopener" href="https://github.com/dashMrl/Android_Demos/tree/15a266e6edfd10b2c4dd39b32f6d9e66dafec66e">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LifeCycle </tag>
            
            <tag> AAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidArchitectureComponents 序言</title>
      <link href="/2017/12/21/5b8016b1834f.html"/>
      <url>/2017/12/21/5b8016b1834f.html</url>
      
        <content type="html"><![CDATA[<p>Google 在今年的 IO 大会上推出了一套新的 Android 应用开发框架————Android Architecture Components，从我个人的理解来看，它主要的功能还是帮你解决一些开发时一些比较琐碎的工作，比如 <strong>数据保存与恢复</strong> ，一个突出的思想就是 <strong>数据视图分离</strong> 、<strong>数据驱动视图</strong> 。当然这些概念并不是这套框架所新诞生的，目前也有很多优秀的解决方案，所以 Google 也强调了，没有必要强行迁移现有的开发模式，<strong>新项目&#x2F;模块</strong> 可以试试。</p><span id="more"></span><p>按照惯例，这套框架在国内的使用情况应该是和 DataBinding 差不多————不愠不火。不过呢，我个人还是比较喜欢尝鲜，所以，最近的一个项目中，我开始大规模尝试这些在国内不怎么火的框架，遇到了一些坑，也有蛮多的收获。</p><p>然后论坛上也有很多的相关的文章，可是感觉大多数就是把官方的文档给翻译了一遍，并没有进一步给出实践中可能遇到的问题，所以踩坑的时候也是废了挺大的劲的。所以这系列文章将会结合我的使用体验和并给出简单的分析。</p><p>目前这一套框架都被集成到了 support 包里面，所以请务必升级到最新的 support 包。</p><blockquote><p>注意: 这一系列文章都假定读者对传统的开发方式有一定的经验。如果你是一名初学者，我建议你先了解目前最常见架构模式(MVC,MVP等)后再来学习本系列文章。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/12/19/103ba3e4a835.html"/>
      <url>/2017/12/19/103ba3e4a835.html</url>
      
        <content type="html"><![CDATA[<p>最近刚刚重新打造了一下我的新博客（也就是你现在所看到的），免不了想要产出一点点文章来充实充实它。上一次的博客写完两篇博客的搭建笔记就没有然后了，希望这次的博客能够一直好好的经营下去，算是立了一个 Flag 吧。</p><span id="more"></span><p>其实这个博客最主要的目的还是对平常学习做个笔记，之前把笔记都托管在 Gitbook ，也挺不错的，不过 Gitbook 的写作体验实在不怎么爽（GitBookEditor 很容易卡顿），所以笔记更新得也不是非常勤快。</p><p>所以接下来的一段时间里，主要任务还是把那边的笔记给迁移过来…</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
