<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>缓存之 DiskLruCache | 爱吃胡萝卜</title><meta name="keywords" content="DiskLruCache"><meta name="author" content="Clsrfish"><meta name="copyright" content="Clsrfish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="DiskLruCache 在 Glide 、 OkHttp 中都有使用，不过这些第三方库有可能根据自己的需求进行了一定的修改，不过总体上的还是一样的。下载地址"><meta property="og:type" content="article"><meta property="og:title" content="缓存之 DiskLruCache"><meta property="og:url" content="https://clsrfish.github.io/2017/12/26/d03b71bc367c.html"><meta property="og:site_name" content="爱吃胡萝卜"><meta property="og:description" content="DiskLruCache 在 Glide 、 OkHttp 中都有使用，不过这些第三方库有可能根据自己的需求进行了一定的修改，不过总体上的还是一样的。下载地址"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><meta property="article:published_time" content="2017-12-26T03:15:05.000Z"><meta property="article:modified_time" content="2023-08-05T13:23:07.812Z"><meta property="article:author" content="Clsrfish"><meta property="article:tag" content="DiskLruCache"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://clsrfish.github.io/2017/12/26/d03b71bc367c"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google_site_verification" content="ALggV8fMlqU6kz5jiwX3wgHN9jKRCZmbXpqjS6s_Ec8"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/favicon-16x16.png"><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script async src="https://www.googletagmanager.com/gtag/js?id=UA-199327316-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-199327316-1")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:{limitDay:365,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Clsrfish",link:"链接: ",source:"来源: 爱吃胡萝卜",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!0,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"缓存之 DiskLruCache",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-08-05 21:23:07"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const r=saveToLocal.get("global-font-size");void 0!==r&&document.documentElement.style.setProperty("--global-font-size",r+"px");GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><style>.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="爱吃胡萝卜" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/pwa/144.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">爱吃胡萝卜</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">缓存之 DiskLruCache</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-12-26T03:15:05.000Z" title="发表于 2017-12-26 11:15:05">2017-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-05T13:23:07.812Z" title="更新于 2023-08-05 21:23:07">2023-08-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="缓存之 DiskLruCache"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><code>DiskLruCache</code> 在 Glide 、 OkHttp 中都有使用，不过这些第三方库有可能根据自己的需求进行了一定的修改，不过总体上的还是一样的。<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html">下载地址</a></p><span id="more"></span><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>当缓存损坏的时候，它能够高效地进行处理。最明显的方法就是删除缓存，其他大多数缓存是没有这种机制的。不过一般来说，缓存损坏的情况还是比较少见的。</li><li>维护了一个缓存条目的内存LRU缓存，避免在每次访问缓存条目都需要查询数据库和磁盘，提高数据加载效率。</li><li>能够自己判断缓存是不是最新的，也就是说，每次使用 Editor 进行操作的时候都会做一个版本控制。</li><li>写入缓存发生错误时，可以调用 <code>Editor#abort()</code> 来放弃本次操作，并且产生的临时文件也将被删除。即使 app 在操作的时候意外停止运行，我们可以通过调用 <code>DiskLruCache#close()</code> 来删除所有的临时文件来保证缓存的状态连续性。</li><li>对同一份缓存的读写是线程安全的。</li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化并获取实例</span></span><br><span class="line"><span class="type">DiskLruCache</span> <span class="variable">cache</span> <span class="operator">=</span> DiskLruCache.open(directory, appVersion, valueCount, maxSize)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 key 拿到 Editor 对象</span></span><br><span class="line">DiskLruCache.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> cache.edit(key);</span><br><span class="line"><span class="comment">// 拿到一个没有缓冲的输出流，通过它向磁盘写入需要缓存的数据</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 完成数据写入之后调用 commit() 提交</span></span><br><span class="line">editor.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 key 拿到 Snapshot 对象</span></span><br><span class="line">DiskLruCache.<span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"><span class="comment">// 拿到一个没有缓冲的 输入流，通过它读取磁盘缓存</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> snapshot.getInputStream(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要使用缓存的时候可以选择关闭，关闭后再不能执行读写操作</span></span><br><span class="line">cache.close();</span><br></pre></td></tr></table></figure><p>上面代码就是 DiskLruCache 提供的一些基本操作，还有另外一些 API，如：remove(key)、getDirectory() 等。至于调用这些方法所需要提供的参数的原因，再分析了其他部分之后就清楚了。</p><br>## journal 文件 `DiskLruCache` 基于 journa 文件来进行缓存，在操作缓存的时候这个文件会有大量的读写操作。 先瞄一眼这些缓存在磁盘上的组织形式(这里以简书的缓存为例)：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ef41763bb5d73d8c0ed56342d192c470.1</span><br><span class="line">f004340685af913064825e5e67dbbda9.0</span><br><span class="line">f004340685af913064825e5e67dbbda9.1</span><br><span class="line">f1e314bfd0834ddcc5decfa52d81f9f7.0</span><br><span class="line">f1e314bfd0834ddcc5decfa52d81f9f7.1</span><br><span class="line">fbaee0fc0b5d9aca24ab3937d55fbb28.0</span><br><span class="line">fbaee0fc0b5d9aca24ab3937d55fbb28.1</span><br><span class="line">journal</span><br></pre></td></tr></table></figure>我们看到这里有很多有着 **不明觉厉的命名** 的文件和一个 **journal** 文件，再仔细看看发现有些文件只是后缀不一样，前面都一长串字符。其实这些命名很屌的文件就是缓存，可能是一张图片或者一篇文章，而 **journal** 就是一个文本文件，里面记录的就是这些缓存的信息：**状态** 、**key** 、**大小** ，打开后是这样的：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">libcore.io.DiskLruCache        // 表示这是一个 DiskLruCache 的日志文件</span><br><span class="line">1                              // 当前 DiskLruCache 的版本</span><br><span class="line">201105                         // 应用的版本号</span><br><span class="line">2                              // 一个 key 对应缓存的数量，即 valueCount</span><br><span class="line">                               // 空行</span><br><span class="line">CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054</span><br><span class="line">DIRTY 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line">CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342</span><br><span class="line">REMOVE 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line">DIRTY 1ab96a171faeeee38496d8b330771a7a</span><br><span class="line">CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</span><br><span class="line">READ 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line">READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</span><br><span class="line">...</span><br></pre></td></tr></table></figure>前面的五行组成了日志文件的头信息（Headers），格式是固定的。头下面就是缓存操作记录了，我们的每一次存取都会在里面形成一条记录。当然，内部肯定会定期的做一个日志的清理以保证这个日志文件大小在可接受的范围之内。 每一行代表一个操作记录，一条记录由 state 空格 key [sizes] 组成。下面是四种操作状态的含义： > - **DIRTY**：一条缓存条目正在创建或者更新。每一个 DIRTY 动作后面都跟着一个 CLEAN/REMOVE ，如果不是则表示需要删除临时文件。我们还能知道，每一个 key 在 journal 文件里面的 **第一条** 记录就是 DIRTY **打头** 的。 - **CLEAN**：表示一个缓存是可以读取的，这种类型的记录还会有 **缓存大小** 跟在尾部。 - **READ**：每一次对缓存的访问都会产生一条 READ 记录。 - **REMOVE**：表示 key 所对应的缓存已经被删除了。<p>这里可能有同学会感到疑惑：为什么不直接在每次写入缓存成功后写入 CLEAN 到 journal 文件，省去中间的步骤？<br>这里我们设想这样的场景：我们缓存图片缓存到一半，然后 app 突然崩溃，然后除了临时文件我们什么都没留下。如果我们使用 DIRTY ，至少能保证下次打开 app 的时候通过 DIRTY 来删除这个临时文件。</p><h2 id="重要内部类"><a href="#重要内部类" class="headerlink" title="重要内部类"></a>重要内部类</h2><p><code>DiskLruCache</code> 内部有三个重要的类，它们提供缓存的抽象、读和写。</p><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>每一个 Entry 实例都是一条缓存记录的抽象，它包含了缓存的key、长度、状态等。下面是这个类的关键声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] lengths;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> readable;</span><br><span class="line">    <span class="keyword">private</span> Editor currentEditor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> File <span class="title function_">getCleanFile</span><span class="params">(<span class="type">int</span> i)</span>；</span><br><span class="line">    <span class="keyword">public</span> File <span class="title function_">getDirtyFile</span><span class="params">(<span class="type">int</span> i)</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>key</strong>：这个缓存的唯一身份标示</li><li><strong>lengths</strong>：初始化 DiskLruCache 时我们传入了一个 valueCount，这表示一个 key 可以又多个缓存，所以大小也用一个长整型数组表示。</li><li><strong>readable</strong>：表示改缓存可以读取。</li><li><strong>currentEditor</strong>：<strong>NON-NULL</strong> 表示该缓存目前正在进行一个写操作。</li><li><strong>sequenceNumber</strong>：这个和 <code>Snapshot</code> 里面的 sequenceNumber 进行配合，以此分辨 <code>Snapshot</code> 的数据是否过期。</li><li><strong>getDirtyFile(index)<strong>：获取该缓存与 index 对应的写入</strong>成功之前</strong>的临时文件。</li><li><strong>getCleanFile(index)<strong>：获取该缓存与 index 对应的写入</strong>成功之后</strong>的缓存文件。</li></ul><h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p><code>Snapshot</code> 是 <code>DiskLruCache</code> 另一个非常重要的内部类，通过它可以读取缓存，下面是它的重要声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Snapshot</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> sequenceNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream[] ins;</span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">(<span class="type">int</span> index)</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>key</strong>：对应缓存的唯一身份标示</li><li><strong>sequenceNumber</strong>：正如在 <code>Entry</code> 中所说，这里也包含了一个 sequenceNumber。在 <code>Snapshot</code> 被实例化的时候，sequenceNumber 是直接从 <code>Entry</code> 里复制过来的。如果在此之后有人对缓存进行的了编辑或者更新操作，<code>Entry</code> 里面的 sequenceNumber 就会自增，这时两边的值就不相等了，也就意味着 <code>Snapshot</code> 里的数据过期了。</li><li>**getInputStream(index)**：获取缓存与 index 对应的没有缓冲的输入流。</li></ul><h3 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h3><p><code>Editor</code> 是对缓存写入的一个封装，下面是它的一些重要声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Entry entry;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> hasErrors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">newInputStream</span><span class="params">(<span class="type">int</span> index)</span>；</span><br><span class="line">    <span class="keyword">public</span> OutputStream <span class="title function_">newOutputStream</span><span class="params">(<span class="type">int</span> index)</span>；</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>；</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Entry</strong>：editor 操作的对象。</li><li><strong>hasError</strong>：标示缓存写入是否发生异常。</li><li>**newInputStream(index)**：获取与 index 对应的最近的缓存输入流。</li><li>**newOutputStream(index)**：获取与 index 对应的缓存输出流，如果写入期间发生异常，写入将会被撤销。</li><li>**commit()**：写入完成后进行提交。</li><li>**abort()**：撤销本次对 Entry 的操作。</li></ul><h2 id="journal-文件的管理"><a href="#journal-文件的管理" class="headerlink" title="journal 文件的管理"></a>journal 文件的管理</h2><p>上面的三个内部类对 缓存条目、读、写进行了抽象，那么留给 <code>DiskLruCache</code> 的工作显然就是对日志的管理了。这里我们通过分析缓存的初始化、读写来分析日志的管理机制。</p><h3 id="DiskLruCache-open"><a href="#DiskLruCache-open" class="headerlink" title="DiskLruCache#open()"></a>DiskLruCache#open()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title function_">open</span><span class="params">(File directory, <span class="type">int</span> appVersion,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> valueCount, <span class="type">long</span> maxSize)</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DiskLruCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskLruCache</span>(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.readJournal();</span><br><span class="line">            cache.processJournal();</span><br><span class="line">            cache.journalWriter = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(cache.journalFile, <span class="literal">true</span>),</span><br><span class="line">                    IO_BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">return</span> cache;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">            cache.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new empty cache</span></span><br><span class="line">    directory.mkdirs();</span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">DiskLruCache</span>(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    cache.rebuildJournal();</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果之前有使用过缓存，则尝试去读取。读取过程就是验证 journal 文件头信息的合法性并且逐行读取缓存条目。然后对缓存条目进行一些类似筛选的操作，这里会删除一些临时文件。这些操作过程中都有可能发生异常，异常发生就会删除所有缓存。</p><p>如果之前没有使用过缓存，就会尝试去重新建立一个缓存，这里没有对异常进行捕获，而是交给使用者处理，这表明如果重新建立缓存也失败，那么 <code>DiskLruCache</code> 将不可用。</p><h3 id="DiskLruCache-readJournalLine"><a href="#DiskLruCache-readJournalLine" class="headerlink" title="DiskLruCache#readJournalLine()"></a>DiskLruCache#readJournalLine()</h3><p>当 journal 文件的头信息合法之后，就是逐行读取缓存条目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    String[] parts = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (parts.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;unexpected journal line: &quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> parts[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(REMOVE) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</span><br><span class="line">        lruEntries.remove(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        entry = <span class="keyword">new</span> <span class="title class_">Entry</span>(key);</span><br><span class="line">        lruEntries.put(key, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(CLEAN) &amp;&amp; parts.length == <span class="number">2</span> + valueCount) &#123;</span><br><span class="line">        entry.readable = <span class="literal">true</span>;</span><br><span class="line">        entry.currentEditor = <span class="literal">null</span>;</span><br><span class="line">        entry.setLengths(copyOfRange(parts, <span class="number">2</span>, parts.length));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(DIRTY) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</span><br><span class="line">        entry.currentEditor = <span class="keyword">new</span> <span class="title class_">Editor</span>(entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(READ) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// this work was already done by calling lruEntries.get()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;unexpected journal line: &quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易看到，这里主要对四种不同状态进行具体情况具体分析：</p><ul><li>REMOVE：表示这个 key 对应的缓存已经删除，相应的缓存条目也需要删除。</li><li>CLEAN：表示 key 对应的缓存存在，并且可读。然后继续解析尾部的大小信息。</li><li>DIRTY：表示 key 对应的缓存最近执行过一次写入操作，但是最后写入失败。</li><li>READ：表示最近读取过该条缓存。</li></ul><p>这里需要知道的是，每条缓存可能不止一条记录，所以一条缓存最终状态的是它所有操作记录的总和，不过最后一次记录会起到很关键的作用。<br>到这里我们就完成缓存记录的读取，不过读取出来的数据还没有经过筛选，其中还有一些坏缓存的记录，下一步操作需要剔除它们并删除与之对应的缓存文件。</p><h3 id="DiskLruCache-processJournal"><a href="#DiskLruCache-processJournal" class="headerlink" title="DiskLruCache#processJournal()"></a>DiskLruCache#processJournal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    deleteIfExists(journalFileTmp);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> i.next();</span><br><span class="line">        <span class="keyword">if</span> (entry.currentEditor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">                size += entry.lengths[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry.currentEditor = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">                deleteIfExists(entry.getCleanFile(t));</span><br><span class="line">                deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">            &#125;</span><br><span class="line">            i.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上一步的筛选，这里处理的数据都是以 <strong>DIRTY</strong> 、 <strong>CLEAN</strong> 、 <strong>READ</strong> 开头的记录。<br>这里的筛选操作主要依据 <code>Entry.currentEditor</code> 是不是 <strong>null</strong> ，上一步中知道只有 <strong>DIRTY</strong> 打头的记录才满足这个条件。如果不为 null ，表明最近有失败的写入操作，需要删除临时文件和过期的缓存文件。如果不死的话，表明这是一条合法可用的缓存，读取缓存占用磁盘的空间大小。</p><h3 id="DiskLruCache-rebuildJournal"><a href="#DiskLruCache-rebuildJournal" class="headerlink" title="DiskLruCache#rebuildJournal()"></a>DiskLruCache#rebuildJournal()</h3><p>如果是第一次使用的缓存，那么就会调用 <code>DiskLruCache#rebuildJournal</code> 来新建缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">rebuildJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (journalWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">        journalWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(journalFileTmp), IO_BUFFER_SIZE);</span><br><span class="line">    writer.write(MAGIC);</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    writer.write(VERSION_1);</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    writer.write(Integer.toString(appVersion));</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    writer.write(Integer.toString(valueCount));</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">            writer.write(DIRTY + <span class="string">&#x27; &#x27;</span> + entry.key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writer.write(CLEAN + <span class="string">&#x27; &#x27;</span> + entry.key + entry.getLengths() + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writer.close();</span><br><span class="line">    journalFileTmp.renameTo(journalFile);</span><br><span class="line">    journalWriter = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(journalFile, <span class="literal">true</span>), IO_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法还是很好懂，先创建一临时的 journal 文件，然后向里面写入头信息，写入成功之后就重命名为 journal 文件。因为这个方法不止在新建journal 文件的时候调用，所以还需要将已有所有的 Entry 写入到 journal 里面，这里新建的情况下 lruEntries 是空的。</p><h3 id="DiskLruCache-edit"><a href="#DiskLruCache-edit" class="headerlink" title="DiskLruCache#edit()"></a>DiskLruCache#edit()</h3><p>调用 <code>DiskLruCache#edit(key)</code> 最终会调用 <code>DiskLruCache#edit(key,expectedSequenceNumber)</code> ，这里第二个参数可能会给大家另一个惊喜：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Editor <span class="title function_">edit</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> edit(key, ANY_SEQUENCE_NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Editor <span class="title function_">edit</span><span class="params">(String key,</span></span><br><span class="line"><span class="params">                                <span class="type">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER</span><br><span class="line">            &amp;&amp; (entry == <span class="literal">null</span> || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// snapshot is stale</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        entry = <span class="keyword">new</span> <span class="title class_">Entry</span>(key);</span><br><span class="line">        lruEntries.put(key, entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// another edit is in progress</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Editor</span>(entry);</span><br><span class="line">    entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flush the journal before creating files to prevent file leaks</span></span><br><span class="line">    journalWriter.write(DIRTY + <span class="string">&#x27; &#x27;</span> + key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    journalWriter.flush();</span><br><span class="line">    <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>DiskLruCache#edit(key)</code> ，那么 <code>expectedSequenceNumber</code> &#x3D;&#x3D; ANY_SEQUENCE_NUMBER 是恒成立的，所以第一个条件语句我们直接跳过。接下来的操作就是，如果不存在与 key 多对应的缓存，则新建一个 Entry；如果存在就判断 Entry 的 Editor 是不是为空，不为空表示有另一个线程正在进行写操作。判断操作合法性之后就给这个 Entry 分配一个 Editor，同时向 journal 文件里面写入一条 <strong>DIRTY</strong> 记录。</p><h3 id="DiskLruCache-completeEdit"><a href="#DiskLruCache-completeEdit" class="headerlink" title="DiskLruCache#completeEdit()"></a>DiskLruCache#completeEdit()</h3><p>在使用 Editor 完成操作后，需要调用 <code>Editor#abort()</code> 或 <code>Editor#commit()</code> 最终向 <code>DiskLruCache</code> 提交，这两个方法最终都会调用 <code>DiskLruCache#completeEdit()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">completeEdit</span><span class="params">(Editor editor, <span class="type">boolean</span> success)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> editor.entry;</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor != editor) &#123;<span class="comment">// 安全性检查</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if this edit is creating the entry for the first time, every index must have a value</span></span><br><span class="line">    <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">                editor.abort();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;edit didn&#x27;t create file &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valueCount; i++) &#123;<span class="comment">// 将写入成功的临时文件重命名为正式的缓存文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dirty</span> <span class="operator">=</span> entry.getDirtyFile(i);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dirty.exists()) &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">clean</span> <span class="operator">=</span> entry.getCleanFile(i);</span><br><span class="line">                dirty.renameTo(clean);</span><br><span class="line">                <span class="type">long</span> <span class="variable">oldLength</span> <span class="operator">=</span> entry.lengths[i];</span><br><span class="line">                <span class="type">long</span> <span class="variable">newLength</span> <span class="operator">=</span> clean.length();</span><br><span class="line">                entry.lengths[i] = newLength;</span><br><span class="line">                size = size - oldLength + newLength;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deleteIfExists(dirty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;    <span class="comment">// 多余的操作数量+1，用来判断是否需要重建 journal 文件用的</span></span><br><span class="line">    entry.currentEditor = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry.readable | success) &#123;</span><br><span class="line">        entry.readable = <span class="literal">true</span>;</span><br><span class="line">        journalWriter.write(CLEAN + <span class="string">&#x27; &#x27;</span> + entry.key + entry.getLengths() + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            entry.sequenceNumber = nextSequenceNumber++;    <span class="comment">// 如果在此之前有获取过该 Entry 的 Snapshot ，这一步操作将使 Snapshot 过期</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 写入 REMOVE 记录，便于下次移除临时文件</span></span><br><span class="line">        lruEntries.remove(entry.key);</span><br><span class="line">        journalWriter.write(REMOVE + <span class="string">&#x27; &#x27;</span> + entry.key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;    <span class="comment">// journal 文件清理</span></span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个方法比较长，自己看代码的效果应该会好一点，里面的注释基本上也讲清楚了大概的操作。唯一要注意的就是，<code>Entry.readable</code> 这个成员变量，初始值为 <code>false</code> ，只有当完成一次读取或者成功的写入操作的时候才会被置为 <code>true</code> 。</p><h3 id="DiskLruCache-get"><a href="#DiskLruCache-get" class="headerlink" title="DiskLruCache#get()"></a>DiskLruCache#get()</h3><p>写入缓存就是为了读取，下面看看 <code>DiskLruCache</code> 是怎么构建一个缓存快照 <code>Snapshot</code> 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title function_">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!entry.readable) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Open all streams eagerly to guarantee that we see a single published</span></span><br><span class="line"><span class="comment">     * snapshot. If we opened streams lazily then the streams could come</span></span><br><span class="line"><span class="comment">     * from different edits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InputStream[] ins = <span class="keyword">new</span> <span class="title class_">InputStream</span>[valueCount];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">            ins[i] = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(entry.getCleanFile(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// a file must have been deleted manually!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(READ + <span class="string">&#x27; &#x27;</span> + key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(key, entry.sequenceNumber, ins);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也很简单，大概情况就是，拿到 key 所对应的缓存，然后打开所有的文件输入流，将操作记录写入 journal 文件，最后再判断是否需要重建 journal 文件。至于那个一大段文本注释中的解释，我也不是很清楚，大概就是说如果不马上打开的话，之后打开获取的缓存可能是被更新过的。然后我们又看到了 sequenceNumber ，就是直接从 Entry 里面复制过来的，所以可以根据两边的值来判断 Snapshot 过期与否。</p><h3 id="DIskLruCache-remove"><a href="#DIskLruCache-remove" class="headerlink" title="DIskLruCache#remove()"></a>DIskLruCache#remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span> || entry.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> entry.getCleanFile(i);</span><br><span class="line">        <span class="keyword">if</span> (!file.delete()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;failed to delete &quot;</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">        size -= entry.lengths[i];</span><br><span class="line">        entry.lengths[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(REMOVE + <span class="string">&#x27; &#x27;</span> + key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保存在对应的缓存之后，判断是否有另一个操作正在进行，没有就会继续执行。然后就是删除缓存文件，写入操作记录，将 <code>Entry</code> 从 <code>lruEntries</code> 中移除，最后再判断是否需要对 journal 文件进行重建。</p><h3 id="LRU-算法的实现"><a href="#LRU-算法的实现" class="headerlink" title="LRU 算法的实现"></a>LRU 算法的实现</h3><p>最重要的 <strong>LRU</strong> 算法肯定要放在最后，看过 <code>DiskLruCache</code> 源码的同学可能会发现并没有找到有关 LRU 实现的一点蛛丝马迹。所见即所得，<code>DiskLruCache</code> 并没有自己去实现 LRU 算法，因为 LinkedHashMap 自带 LRU 属性。因为所有的 Entry 都存放在一个 LinkedHashMap 里，并且初始化的时候调用了 LinkedHashMap 三个参数的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>第三个参数的官方解释是：accessOrder - the ordering mode - true for access-order, false for insertion-order。这里是设为的 true ，所以表示是按照访问的时间来进行排序的，即 LRU 。如果还想知道 LRU 的具体实现，可以参考 LinkedHashMap 源码。</p><hr><p>到这里，关键的源码基本就全部分析了一遍，一些细枝末节的东西一眼就能看懂。刚开始看的时候没有注意 <strong>理清结构</strong> 和 <strong>类间关系</strong> ，阅读进度很慢，后来从别人博客学到的方法才能顺利的阅读。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.mindorks.com/this-post-is-about-the-implementation-details-of-jake-whartons-famous-disklrucache-9a87d90206fe">A deep dive into Jake Wharton’s DiskLruCache</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">Clsrfish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://clsrfish.github.io/2017/12/26/d03b71bc367c.html">https://clsrfish.github.io/2017/12/26/d03b71bc367c.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://clsrfish.github.io" target="_blank">爱吃胡萝卜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DiskLruCache/">DiskLruCache</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2017/12/26/669e7b46d405.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">React Native 之环境搭建</div></div></a></div><div class="next-post pull-right"><a href="/2017/12/26/f29039e0c557.html"><img class="next-cover" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">缓存之 MemoryLruCache</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/pwa/144.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Clsrfish</div><div class="author-info__description">互联网，读书，计算机</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/Clsrfish" rel="external nofollow noreferrer"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:clsrfish@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">《置身事内》ing...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">简单使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">重要内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Entry"><span class="toc-number">3.1.</span> <span class="toc-text">Entry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Snapshot"><span class="toc-number">3.2.</span> <span class="toc-text">Snapshot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Editor"><span class="toc-number">3.3.</span> <span class="toc-text">Editor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#journal-%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">journal 文件的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DiskLruCache-open"><span class="toc-number">4.1.</span> <span class="toc-text">DiskLruCache#open()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiskLruCache-readJournalLine"><span class="toc-number">4.2.</span> <span class="toc-text">DiskLruCache#readJournalLine()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiskLruCache-processJournal"><span class="toc-number">4.3.</span> <span class="toc-text">DiskLruCache#processJournal()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiskLruCache-rebuildJournal"><span class="toc-number">4.4.</span> <span class="toc-text">DiskLruCache#rebuildJournal()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiskLruCache-edit"><span class="toc-number">4.5.</span> <span class="toc-text">DiskLruCache#edit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiskLruCache-completeEdit"><span class="toc-number">4.6.</span> <span class="toc-text">DiskLruCache#completeEdit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiskLruCache-get"><span class="toc-number">4.7.</span> <span class="toc-text">DiskLruCache#get()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DIskLruCache-remove"><span class="toc-number">4.8.</span> <span class="toc-text">DIskLruCache#remove()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.9.</span> <span class="toc-text">LRU 算法的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/29/a22615e5cdae.html" title="LSM-Tree">LSM-Tree</a><time datetime="2023-07-29T13:16:22.000Z" title="发表于 2023-07-29 21:16:22">2023-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/17/49937ddf50aa.html" title="Rate-limiting algorithms">Rate-limiting algorithms</a><time datetime="2023-07-17T14:17:28.000Z" title="发表于 2023-07-17 22:17:28">2023-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/16/44c822c98a72.html" title="Consistent hashing">Consistent hashing</a><time datetime="2023-07-16T06:24:30.000Z" title="发表于 2023-07-16 14:24:30">2023-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/f74286649fc7.html" title="Bloom filter">Bloom filter</a><time datetime="2023-07-15T14:19:02.000Z" title="发表于 2023-07-15 22:19:02">2023-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/12/524fd56f9760.html" title="Cache problems">Cache problems</a><time datetime="2023-07-12T13:37:02.000Z" title="发表于 2023-07-12 21:37:02">2023-07-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2023 By Clsrfish</div><div class="framework-info"><span>框架</span> <a href="https://hexo.io" rel="external nofollow noreferrer">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a href="https://github.com/jerryc127/hexo-theme-butterfly" rel="external nofollow noreferrer">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()">点击刷新</a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",(function(){showNotification()})),window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})))</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>